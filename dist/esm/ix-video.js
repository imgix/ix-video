/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof undefined === "function") r = undefined(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3=window.ShadowRoot&&(void 0===window.ShadyCSS||window.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,e$6=Symbol(),n$7=new Map;class s$3{constructor(t,n){if(this._$cssResult$=!0,n!==e$6)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t;}get styleSheet(){let e=n$7.get(this.cssText);return t$3&&void 0===e&&(n$7.set(this.cssText,e=new CSSStyleSheet),e.replaceSync(this.cssText)),e}toString(){return this.cssText}}const o$5=t=>new s$3("string"==typeof t?t:t+"",e$6),r$4=(t,...n)=>{const o=1===t.length?t[0]:n.reduce(((e,n,s)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(n)+t[s+1]),t[0]);return new s$3(o,e$6)},i$3=(e,n)=>{t$3?e.adoptedStyleSheets=n.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):n.forEach((t=>{const n=document.createElement("style"),s=window.litNonce;void 0!==s&&n.setAttribute("nonce",s),n.textContent=t.cssText,e.appendChild(n);}));},S$1=t$3?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const n of t.cssRules)e+=n.cssText;return o$5(e)})(t):t;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var s$2;const e$5=window.trustedTypes,r$3=e$5?e$5.emptyScript:"",h$3=window.reactiveElementPolyfillSupport,o$4={toAttribute(t,i){switch(i){case Boolean:t=t?r$3:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,i){let s=t;switch(i){case Boolean:s=null!==t;break;case Number:s=null===t?null:Number(t);break;case Object:case Array:try{s=JSON.parse(t);}catch(t){s=null;}}return s}},n$6=(t,i)=>i!==t&&(i==i||t==t),l$3={attribute:!0,type:String,converter:o$4,reflect:!1,hasChanged:n$6};class a$1 extends HTMLElement{constructor(){super(),this._$Et=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Ei=null,this.o();}static addInitializer(t){var i;null!==(i=this.l)&&void 0!==i||(this.l=[]),this.l.push(t);}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((i,s)=>{const e=this._$Eh(s,i);void 0!==e&&(this._$Eu.set(e,s),t.push(e));})),t}static createProperty(t,i=l$3){if(i.state&&(i.attribute=!1),this.finalize(),this.elementProperties.set(t,i),!i.noAccessor&&!this.prototype.hasOwnProperty(t)){const s="symbol"==typeof t?Symbol():"__"+t,e=this.getPropertyDescriptor(t,s,i);void 0!==e&&Object.defineProperty(this.prototype,t,e);}}static getPropertyDescriptor(t,i,s){return {get(){return this[i]},set(e){const r=this[t];this[i]=e,this.requestUpdate(t,r,s);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||l$3}static finalize(){if(this.hasOwnProperty("finalized"))return !1;this.finalized=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),this.elementProperties=new Map(t.elementProperties),this._$Eu=new Map,this.hasOwnProperty("properties")){const t=this.properties,i=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const s of i)this.createProperty(s,t[s]);}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(i){const s=[];if(Array.isArray(i)){const e=new Set(i.flat(1/0).reverse());for(const i of e)s.unshift(S$1(i));}else void 0!==i&&s.push(S$1(i));return s}static _$Eh(t,i){const s=i.attribute;return !1===s?void 0:"string"==typeof s?s:"string"==typeof t?t.toLowerCase():void 0}o(){var t;this._$Ep=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$Em(),this.requestUpdate(),null===(t=this.constructor.l)||void 0===t||t.forEach((t=>t(this)));}addController(t){var i,s;(null!==(i=this._$Eg)&&void 0!==i?i:this._$Eg=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(s=t.hostConnected)||void 0===s||s.call(t));}removeController(t){var i;null===(i=this._$Eg)||void 0===i||i.splice(this._$Eg.indexOf(t)>>>0,1);}_$Em(){this.constructor.elementProperties.forEach(((t,i)=>{this.hasOwnProperty(i)&&(this._$Et.set(i,this[i]),delete this[i]);}));}createRenderRoot(){var t;const s=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return i$3(s,this.constructor.elementStyles),s}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostConnected)||void 0===i?void 0:i.call(t)}));}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostDisconnected)||void 0===i?void 0:i.call(t)}));}attributeChangedCallback(t,i,s){this._$AK(t,s);}_$ES(t,i,s=l$3){var e,r;const h=this.constructor._$Eh(t,s);if(void 0!==h&&!0===s.reflect){const n=(null!==(r=null===(e=s.converter)||void 0===e?void 0:e.toAttribute)&&void 0!==r?r:o$4.toAttribute)(i,s.type);this._$Ei=t,null==n?this.removeAttribute(h):this.setAttribute(h,n),this._$Ei=null;}}_$AK(t,i){var s,e,r;const h=this.constructor,n=h._$Eu.get(t);if(void 0!==n&&this._$Ei!==n){const t=h.getPropertyOptions(n),l=t.converter,a=null!==(r=null!==(e=null===(s=l)||void 0===s?void 0:s.fromAttribute)&&void 0!==e?e:"function"==typeof l?l:null)&&void 0!==r?r:o$4.fromAttribute;this._$Ei=n,this[n]=a(i,t.type),this._$Ei=null;}}requestUpdate(t,i,s){let e=!0;void 0!==t&&(((s=s||this.constructor.getPropertyOptions(t)).hasChanged||n$6)(this[t],i)?(this._$AL.has(t)||this._$AL.set(t,i),!0===s.reflect&&this._$Ei!==t&&(void 0===this._$E_&&(this._$E_=new Map),this._$E_.set(t,s))):e=!1),!this.isUpdatePending&&e&&(this._$Ep=this._$EC());}async _$EC(){this.isUpdatePending=!0;try{await this._$Ep;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this._$Et&&(this._$Et.forEach(((t,i)=>this[i]=t)),this._$Et=void 0);let i=!1;const s=this._$AL;try{i=this.shouldUpdate(s),i?(this.willUpdate(s),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostUpdate)||void 0===i?void 0:i.call(t)})),this.update(s)):this._$EU();}catch(t){throw i=!1,this._$EU(),t}i&&this._$AE(s);}willUpdate(t){}_$AE(t){var i;null===(i=this._$Eg)||void 0===i||i.forEach((t=>{var i;return null===(i=t.hostUpdated)||void 0===i?void 0:i.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$EU(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$Ep}shouldUpdate(t){return !0}update(t){void 0!==this._$E_&&(this._$E_.forEach(((t,i)=>this._$ES(i,this[i],t))),this._$E_=void 0),this._$EU();}updated(t){}firstUpdated(t){}}a$1.finalized=!0,a$1.elementProperties=new Map,a$1.elementStyles=[],a$1.shadowRootOptions={mode:"open"},null==h$3||h$3({ReactiveElement:a$1}),(null!==(s$2=globalThis.reactiveElementVersions)&&void 0!==s$2?s$2:globalThis.reactiveElementVersions=[]).push("1.2.2");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var t$2;const i$2=globalThis.trustedTypes,s$1=i$2?i$2.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$4=`lit$${(Math.random()+"").slice(9)}$`,o$3="?"+e$4,n$5=`<${o$3}>`,l$2=document,h$2=(t="")=>l$2.createComment(t),r$2=t=>null===t||"object"!=typeof t&&"function"!=typeof t,d$1=Array.isArray,u=t=>{var i;return d$1(t)||"function"==typeof(null===(i=t)||void 0===i?void 0:i[Symbol.iterator])},c=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,a=/>/g,f=/>|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g,_=/'/g,m=/"/g,g=/^(?:script|style|textarea|title)$/i,p=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),$=p(1),b=Symbol.for("lit-noChange"),w=Symbol.for("lit-nothing"),T=new WeakMap,x=(t,i,s)=>{var e,o;const n=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new N(i.insertBefore(h$2(),t),t,void 0,null!=s?s:{});}return l._$AI(t),l},A=l$2.createTreeWalker(l$2,129,null,!1),C=(t,i)=>{const o=t.length-1,l=[];let h,r=2===i?"<svg>":"",d=c;for(let i=0;i<o;i++){const s=t[i];let o,u,p=-1,$=0;for(;$<s.length&&(d.lastIndex=$,u=d.exec(s),null!==u);)$=d.lastIndex,d===c?"!--"===u[1]?d=v:void 0!==u[1]?d=a:void 0!==u[2]?(g.test(u[2])&&(h=RegExp("</"+u[2],"g")),d=f):void 0!==u[3]&&(d=f):d===f?">"===u[0]?(d=null!=h?h:c,p=-1):void 0===u[1]?p=-2:(p=d.lastIndex-u[2].length,o=u[1],d=void 0===u[3]?f:'"'===u[3]?m:_):d===m||d===_?d=f:d===v||d===a?d=c:(d=f,h=void 0);const y=d===f&&t[i+1].startsWith("/>")?" ":"";r+=d===c?s+n$5:p>=0?(l.push(o),s.slice(0,p)+"$lit$"+s.slice(p)+e$4+y):s+e$4+(-2===p?(l.push(void 0),i):y);}const u=r+(t[o]||"<?>")+(2===i?"</svg>":"");if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return [void 0!==s$1?s$1.createHTML(u):u,l]};class E{constructor({strings:t,_$litType$:s},n){let l;this.parts=[];let r=0,d=0;const u=t.length-1,c=this.parts,[v,a]=C(t,s);if(this.el=E.createElement(v,n),A.currentNode=this.el.content,2===s){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes);}for(;null!==(l=A.nextNode())&&c.length<u;){if(1===l.nodeType){if(l.hasAttributes()){const t=[];for(const i of l.getAttributeNames())if(i.endsWith("$lit$")||i.startsWith(e$4)){const s=a[d++];if(t.push(i),void 0!==s){const t=l.getAttribute(s.toLowerCase()+"$lit$").split(e$4),i=/([.?@])?(.*)/.exec(s);c.push({type:1,index:r,name:i[2],strings:t,ctor:"."===i[1]?M:"?"===i[1]?H:"@"===i[1]?I:S});}else c.push({type:6,index:r});}for(const i of t)l.removeAttribute(i);}if(g.test(l.tagName)){const t=l.textContent.split(e$4),s=t.length-1;if(s>0){l.textContent=i$2?i$2.emptyScript:"";for(let i=0;i<s;i++)l.append(t[i],h$2()),A.nextNode(),c.push({type:2,index:++r});l.append(t[s],h$2());}}}else if(8===l.nodeType)if(l.data===o$3)c.push({type:2,index:r});else {let t=-1;for(;-1!==(t=l.data.indexOf(e$4,t+1));)c.push({type:7,index:r}),t+=e$4.length-1;}r++;}}static createElement(t,i){const s=l$2.createElement("template");return s.innerHTML=t,s}}function P(t,i,s=t,e){var o,n,l,h;if(i===b)return i;let d=void 0!==e?null===(o=s._$Cl)||void 0===o?void 0:o[e]:s._$Cu;const u=r$2(i)?void 0:i._$litDirective$;return (null==d?void 0:d.constructor)!==u&&(null===(n=null==d?void 0:d._$AO)||void 0===n||n.call(d,!1),void 0===u?d=void 0:(d=new u(t),d._$AT(t,s,e)),void 0!==e?(null!==(l=(h=s)._$Cl)&&void 0!==l?l:h._$Cl=[])[e]=d:s._$Cu=d),void 0!==d&&(i=P(t,d._$AS(t,i.values),d,e)),i}class V{constructor(t,i){this.v=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}p(t){var i;const{el:{content:s},parts:e}=this._$AD,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:l$2).importNode(s,!0);A.currentNode=o;let n=A.nextNode(),h=0,r=0,d=e[0];for(;void 0!==d;){if(h===d.index){let i;2===d.type?i=new N(n,n.nextSibling,this,t):1===d.type?i=new d.ctor(n,d.name,d.strings,this,t):6===d.type&&(i=new L(n,this,t)),this.v.push(i),d=e[++r];}h!==(null==d?void 0:d.index)&&(n=A.nextNode(),h++);}return o}m(t){let i=0;for(const s of this.v)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class N{constructor(t,i,s,e){var o;this.type=2,this._$AH=w,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cg=null===(o=null==e?void 0:e.isConnected)||void 0===o||o;}get _$AU(){var t,i;return null!==(i=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==i?i:this._$Cg}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=P(this,t,i),r$2(t)?t===w||null==t||""===t?(this._$AH!==w&&this._$AR(),this._$AH=w):t!==this._$AH&&t!==b&&this.$(t):void 0!==t._$litType$?this.T(t):void 0!==t.nodeType?this.S(t):u(t)?this.A(t):this.$(t);}M(t,i=this._$AB){return this._$AA.parentNode.insertBefore(t,i)}S(t){this._$AH!==t&&(this._$AR(),this._$AH=this.M(t));}$(t){this._$AH!==w&&r$2(this._$AH)?this._$AA.nextSibling.data=t:this.S(l$2.createTextNode(t)),this._$AH=t;}T(t){var i;const{values:s,_$litType$:e}=t,o="number"==typeof e?this._$AC(t):(void 0===e.el&&(e.el=E.createElement(e.h,this.options)),e);if((null===(i=this._$AH)||void 0===i?void 0:i._$AD)===o)this._$AH.m(s);else {const t=new V(o,this),i=t.p(this.options);t.m(s),this.S(i),this._$AH=t;}}_$AC(t){let i=T.get(t.strings);return void 0===i&&T.set(t.strings,i=new E(t)),i}A(t){d$1(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const o of t)e===i.length?i.push(s=new N(this.M(h$2()),this.M(h$2()),this,this.options)):s=i[e],s._$AI(o),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){var i;void 0===this._$AM&&(this._$Cg=t,null===(i=this._$AP)||void 0===i||i.call(this,t));}}class S{constructor(t,i,s,e,o){this.type=1,this._$AH=w,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=o,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=w;}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,i=this,s,e){const o=this.strings;let n=!1;if(void 0===o)t=P(this,t,i,0),n=!r$2(t)||t!==this._$AH&&t!==b,n&&(this._$AH=t);else {const e=t;let l,h;for(t=o[0],l=0;l<o.length-1;l++)h=P(this,e[s+l],i,l),h===b&&(h=this._$AH[l]),n||(n=!r$2(h)||h!==this._$AH[l]),h===w?t=w:t!==w&&(t+=(null!=h?h:"")+o[l+1]),this._$AH[l]=h;}n&&!e&&this.k(t);}k(t){t===w?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"");}}class M extends S{constructor(){super(...arguments),this.type=3;}k(t){this.element[this.name]=t===w?void 0:t;}}const k=i$2?i$2.emptyScript:"";class H extends S{constructor(){super(...arguments),this.type=4;}k(t){t&&t!==w?this.element.setAttribute(this.name,k):this.element.removeAttribute(this.name);}}class I extends S{constructor(t,i,s,e,o){super(t,i,s,e,o),this.type=5;}_$AI(t,i=this){var s;if((t=null!==(s=P(this,t,i,0))&&void 0!==s?s:w)===b)return;const e=this._$AH,o=t===w&&e!==w||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,n=t!==w&&(e===w||o);o&&this.element.removeEventListener(this.name,this,e),n&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){var i,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t);}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){P(this,t);}}const z=window.litHtmlPolyfillSupport;null==z||z(E,N),(null!==(t$2=globalThis.litHtmlVersions)&&void 0!==t$2?t$2:globalThis.litHtmlVersions=[]).push("2.1.3");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var l$1,o$2;class s extends a$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Dt=void 0;}createRenderRoot(){var t,e;const i=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=i.firstChild),i}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Dt=x(i,this.renderRoot,this.renderOptions);}connectedCallback(){var t;super.connectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!0);}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!1);}render(){return b}}s.finalized=!0,s._$litElement$=!0,null===(l$1=globalThis.litElementHydrateSupport)||void 0===l$1||l$1.call(globalThis,{LitElement:s});const n$4=globalThis.litElementPolyfillSupport;null==n$4||n$4({LitElement:s});(null!==(o$2=globalThis.litElementVersions)&&void 0!==o$2?o$2:globalThis.litElementVersions=[]).push("3.1.2");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const n$3=n=>e=>"function"==typeof e?((n,e)=>(window.customElements.define(n,e),e))(n,e):((n,e)=>{const{kind:t,elements:i}=e;return {kind:t,elements:i,finisher(e){window.customElements.define(n,e);}}})(n,e);

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const i$1=(i,e)=>"method"===e.kind&&e.descriptor&&!("value"in e.descriptor)?{...e,finisher(n){n.createProperty(e.key,i);}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:e.key,initializer(){"function"==typeof e.initializer&&(this[e.key]=e.initializer.call(this));},finisher(n){n.createProperty(e.key,i);}};function e$3(e){return (n,t)=>void 0!==t?((i,e,n)=>{e.constructor.createProperty(n,i);})(e,n,t):i$1(e,n)}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function t$1(t){return e$3({...t,state:!0})}

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var n$2;null!=(null===(n$2=window.HTMLSlotElement)||void 0===n$2?void 0:n$2.prototype.assignedElements)?(o,n)=>o.assignedElements(n):(o,n)=>o.assignedNodes(n).filter((o=>o.nodeType===Node.ELEMENT_NODE));

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const r$1=o=>void 0===o.strings;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e$2=t=>(...e)=>({_$litDirective$:t,values:e});class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const e$1=(i,t)=>{var s,o;const n=i._$AN;if(void 0===n)return !1;for(const i of n)null===(o=(s=i)._$AO)||void 0===o||o.call(s,t,!1),e$1(i,t);return !0},o$1=i=>{let t,s;do{if(void 0===(t=i._$AM))break;s=t._$AN,s.delete(i),i=t;}while(0===(null==s?void 0:s.size))},n$1=i=>{for(let t;t=i._$AM;i=t){let s=t._$AN;if(void 0===s)t._$AN=s=new Set;else if(s.has(i))break;s.add(i),l(t);}};function r(i){void 0!==this._$AN?(o$1(this),this._$AM=i,n$1(this)):this._$AM=i;}function h$1(i,t=!1,s=0){const n=this._$AH,r=this._$AN;if(void 0!==r&&0!==r.size)if(t)if(Array.isArray(n))for(let i=s;i<n.length;i++)e$1(n[i],!1),o$1(n[i]);else null!=n&&(e$1(n,!1),o$1(n));else e$1(this,i);}const l=i=>{var t$1,e,o,n;i.type==t.CHILD&&(null!==(t$1=(o=i)._$AP)&&void 0!==t$1||(o._$AP=h$1),null!==(e=(n=i)._$AQ)&&void 0!==e||(n._$AQ=r));};class d extends i{constructor(){super(...arguments),this._$AN=void 0;}_$AT(i,t,s){super._$AT(i,t,s),n$1(this),this.isConnected=i._$AU;}_$AO(i,t=!0){var s,n;i!==this.isConnected&&(this.isConnected=i,i?null===(s=this.reconnected)||void 0===s||s.call(this):null===(n=this.disconnected)||void 0===n||n.call(this)),t&&(e$1(this,i),o$1(this));}setValue(t){if(r$1(this._$Ct))this._$Ct._$AI(t,this);else {const i=[...this._$Ct._$AH];i[this._$Ci]=t,this._$Ct._$AI(i,this,0);}}disconnected(){}reconnected(){}}

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const e=()=>new o;class o{}const h=new WeakMap,n=e$2(class extends d{render(i){return w}update(i,[s]){var e;const o=s!==this.U;return o&&void 0!==this.U&&this.ot(void 0),(o||this.rt!==this.lt)&&(this.U=s,this.ht=null===(e=i.options)||void 0===e?void 0:e.host,this.ot(this.lt=i.element)),w}ot(t){"function"==typeof this.U?(void 0!==h.get(this.U)&&this.U.call(this.ht,void 0),h.set(this.U,t),void 0!==t&&this.U.call(this.ht,t)):this.U.value=t;}get rt(){var t;return "function"==typeof this.U?h.get(this.U):null===(t=this.U)||void 0===t?void 0:t.value}disconnected(){this.rt===this.lt&&this.ot(void 0);}reconnected(){this.ot(this.lt);}});

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === 'undefined') { return; }
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = r$4`@charset "UTF-8";.video-js .vjs-big-play-button .vjs-icon-placeholder:before,.video-js .vjs-modal-dialog,.vjs-button>.vjs-icon-placeholder:before,.vjs-modal-dialog .vjs-modal-dialog-content{position:absolute;top:0;left:0;width:100%;height:100%}.video-js .vjs-big-play-button .vjs-icon-placeholder:before,.vjs-button>.vjs-icon-placeholder:before{text-align:center}@font-face{font-family:VideoJS;src:url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAABDkAAsAAAAAG6gAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAPgAAAFZRiV3hY21hcAAAAYQAAADaAAADPv749/pnbHlmAAACYAAAC3AAABHQZg6OcWhlYWQAAA3QAAAAKwAAADYZw251aGhlYQAADfwAAAAdAAAAJA+RCLFobXR4AAAOHAAAABMAAACM744AAGxvY2EAAA4wAAAASAAAAEhF6kqubWF4cAAADngAAAAfAAAAIAE0AIFuYW1lAAAOmAAAASUAAAIK1cf1oHBvc3QAAA/AAAABJAAAAdPExYuNeJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGS7wTiBgZWBgaWQ5RkDA8MvCM0cwxDOeI6BgYmBlZkBKwhIc01hcPjI+FGJHcRdyA4RZgQRADK3CxEAAHic7dFZbsMgAEXRS0ycyZnnOeG7y+qC8pU1dHusIOXxuoxaOlwZYWQB0Aea4quIEN4E9LzKbKjzDeM6H/mua6Lmc/p8yhg0lvdYx15ZG8uOLQOGjMp3EzqmzJizYMmKNRu27Nhz4MiJMxeu3Ljz4Ekqm7T8P52G8PP3lnTOVk++Z6iN6QZzNN1F7ptuN7eGOjDUoaGODHVsuvU8MdTO9Hd5aqgzQ50b6sJQl4a6MtS1oW4MdWuoO0PdG+rBUI+GejLUs6FeDPVqqDdDvRvqw1CfhpqM9At0iFLaAAB4nJ1YDXBTVRZ+5/22TUlJ8we0pHlJm7RJf5O8F2j6EymlSPkpxaL8U2xpa3DKj0CBhc2IW4eWKSokIoLsuMqssM64f+jA4HSdWXXXscBq67IOs3FXZ1ZYWVyRFdo899yXtIBQZ90k7717zz3v3HPPOfd854YCCj9cL9dL0RQFOqCbGJnrHb5EayiKIWN8iA/hWBblo6hUWm8TtCDwE80WMJus/irwyxOdxeB0MDb14VNJHnXYoLLSl6FfCUYO9nYPTA8Epg9090LprfbBbZ2hY0UlJUXHQp3/vtWkS6EBv8+rPMq5u9692f/dNxJNiqwC1xPE9TCUgCsSdQWgE3XQD25lkG4CN2xmTcOXWBOyser6RN6KnGbKSbmQ3+d0OI1m2W8QzLLkI2sykrWAgJJEtA8vGGW/2Q+CmT3n8zS9wZwu2DCvtuZKZN3xkrLh36yCZuUomQSqGpY8t/25VfHVhw8z4ebGBtfLb0ya9PCaDc+8dGTvk2dsh6z7WzvowlXKUSWo9MJ15a3KrEP2loOr2Ojhw6iW6hf2BDdEccQvZGpaAy7YovSwq8kr7HGllxpd71rkS6G0Sf11sl9OvMK1+jwPPODxjUwkOim9CU3ix1wNjXDfmJSEn618Bs6lpWwUpU+8PCqLMY650zjq8VhCIP17NEKTx3eaLL+s5Pi6yJWaWjTHLR1jYzPSV9VF/6Ojdb/1kO3Mk3uhHC0x6gc1BjlKQ+nQFxTYdaJkZ7ySVxLBbhR1dsboNXp1tCYKW2LRaEzpYcIx2BKNxaL0ZaUnSqfFoiNhHKR/GkX6PWUSAaJelQaqZL1EpoHNsajSEyPSoJ9IjhIxTdjHLmwZvhRDOiFTY/YeQnvrVZmiTQtGncECXtFTBZLOVwwMRgoXHAkXzMzPn1nAJJ8jYSbMDaqN2waGLzNhih/bZynUBMpIWSg7VYi7DRx2m8ALkIdRCJwI6ArJx2EI8kaDWeTQKeAFk9fjl/1AvwktjQ1P7NjyMGQyfd4vjipX6M/i52D7Cq80kqlcxEcGXRr/FEcgs0u5uGgB4VWuMFfpdn2Re6Hi3PqzmxWKsz6+ae2Pn9hXXw/fqM859UiGC0oKYYILJBqJrsn1Z1E5qOs9rQCiUQRREjm8yJcbHF5cUJufX1vAHlefw0XgUoboS3ETfQlTxBC4SOtuE8VPRJTBSCQSjZCpk7Gqzu+masaZ2y7Zjehho4F3g82BNDkAHpORG4+OCS+f6JTPmtRn/PH1kch6d04sp7AQb25aQ/pqUyXeQ8vrebG8OYQdXOQ+585u0sdW9rqalzRURiJ+9F4MweRFrKUjl1GUYhH1A27WOHw5cTFSFPMo9EeUIGnQTZHIaJ7AHLaOKsOODaNF9jkBjYG2QEsQ2xjMUAx2bBEbeTBWMHwskBjngq56S/yfgkBnWBa4K9sqKtq2t1UI8S9He5XuBRbawAdatrQEAi30Aks2+LM8WeCbalVZkWNylvJ+dqJnzVb+OHlSoKW8nPCP7Rd+CcZ2DdWAGqJ2CBFOphgywFFCFBNtfAbGtNPBCwxvygHeYMZMY9ZboBqwq/pVrsbgN5tkv152ODlbMfiqwGMBgxa4Exz3QhovRIUp6acqZmQzRq0ypDXS2TPLT02YIkQETnOE445oOGxOmXAqUJNNG7XgupMjPq2ua9asrj5yY/yuKteO1Kx0YNJTufrirLe1mZnat7OL6rnUdCWenpW6I8mAnbsY8KWs1PuSovCW9A/Z25PQ24a7cNOqgmTkLmBMgh4THgc4b9k2IVv1/g/F5nGljwPLfOgHAzJzh45V/4+WenTzmMtR5Z7us2Tys909UHqrPY7KbckoxRvRHhmVc3cJGE97uml0R1S0jdULVl7EvZtDFVBF35N9cEdjpgmAiOlFZ+Dtoh93+D3zzHr8RRNZQhnCNMNbcegOvpEwZoL+06cJQ07h+th3fZ/7PVbVC6ngTAV/KoLFuO6+2KFcU651gEb5ugPSIb1D+Xp8V4+k3sEIGnw5mYe4If4k1lFYr6SCzmM2EQ8iWtmwjnBI9kTwe1TlfAmXh7H02by9fW2gsjKwtv0aaURKil4OdV7rDL1MXIFNrhdxohcZXYTnq47WisrKitaObbf5+yvkLi5J6lCNZZ+B6GC38VNBZBDidSS/+mSvh6s+srgC8pyKMvDtt+de3c9fU76ZPfuM8ud4Kv0fyP/LqfepMT/3oZxSqpZaTa1DaQYLY8TFsHYbWYsPoRhRWfL5eSSQbhUGgGC3YLbVMk6PitTFNGpAsNrC6D1VNBKgBHMejaiuRWEWGgsSDBTJjqWIl8kJLlsaLJ2tXDr6xGfT85bM2Q06a46x2HTgvdnV8z5YDy/27J4zt6x2VtkzjoYpkq36kaBr4eQSg7tyiVweWubXZugtadl58ydapfbORfKsDTuZ0OBgx4cfdjCf5tbWNITnL120fdOi1RV1C3uKGzNdwYLcMvZ3BxoPyTOCD1XvXTp7U10gWCVmTV9b3r2z0SkGWovb2hp9I89O8a2smlyaO8muMU+dRmtzp60IzAoFpjLr1n388boLyf0dRvxhsHZ0qbWqDkwqvvpkj4l0fY6EIXRi5sQSrAvsVYwXRy4qJ2EVtD1AN7a0HWth9ymvL1xc3WTUKK/TAHA/bXDVtVWfOMfuGxGZv4Ln/jVr9jc3j1yMv0tndmyt9Vq88Y9gH1wtLX3KWjot5++jWHgAoZZkQ14wGQ20Fli71UmKJAy4xKMSTGbVdybW7FDDAut9XpD5AzWrYO7zQ8qffqF8+Ynd/clrHcdyxGy3a/3+mfNnzC/cBsveTjnTvXf1o6vzOlZw7WtqtdmPK/Errz/6NNtD72zmNOZfbmYdTGHfoofqI79Oc+R2n1lrnL6pOm0Up7kwxhTW12Amm7WYkXR2qYrF2AmgmbAsxZjwy1xpg/m1Je2vrp8v/nz2xpmlBg4E9hrMU341wVpTOh/OfmGvAnra8q6uctr60ZQHV3Q+WMQJykMj8ZsWn2QBOmmHMB+m5pDIpTFonYigiaKAhGEiAHF7EliVnQkjoLVIMPtJpBKHYd3A8GYH9jJzrWwmHx5Qjp7vDAX0suGRym1vtm/9W1/HyR8vczfMs6Sk8DSv855/5dlX9oQq52hT8syyp2rx5Id17IAyAM3wIjQPMOHzytEB64q6D5zT91yNbnx3V/nqnd017S9Y0605k3izoXLpsxde2n38yoOV9s1LcjwzNjbdX6asnBVaBj/6/DwKwPkpcqbDG7BnsXoSqWnUAmottYF6jMSdVyYZh3zVXCjwTiwwHH6sGuRiEHQGzuRX6whZkp123oy1BWE2mEfJ/tvIRtM4ZM5bDXiMsPMaAKOTyc5uL57rqyyc5y5JE5pm1i2S2iUX0CcaQ6lC6Zog7JqSqZmYlosl2K6pwNA84zRnQW6SaALYZQGW5lhCtU/W34N6o+bKfZ8cf3/Cl/+iTX3wBzpOY4mRkeNf3rptycGSshQWgGbYt5jFc2e0+DglIrwl6DVWQ7BuwaJ3Xk1J4VL5urnLl/Wf+gHU/hZoZdKNym6lG+I34FaNeZKcSpJIo2IeCVvpdsDGfKvzJnAwmeD37Ow65ZWwSowpgwX5T69s/rB55dP5BcpgDKFV8p7q2sn/1uc93bVzT/w6UrCqDTWvfCq/oCD/qZXNoUj8BL5Kp6GU017frfNXkAtiiyf/SOCEeLqnd8R/Ql9GlCRfctS6k5chvIBuQ1zCCjoCHL2DHNHIXxMJ3kQeO8lbsUXONeSfA5EjcG6/E+KdhN4bP04vBhdi883+BFBzQbxFbvZzQeY9LNBZc0FNfn5NwfDn6rCTnTw6R8o+gfpf5hCom33cRuiTlss3KHmZjD+BPN+5gXuA2ziS/Q73mLxUkpbKN/eqwz5uK0X9F3h2d1V4nGNgZGBgAOJd776+iue3+crAzc4AAje5Bfcg0xz9YHEOBiYQBQA8FQlFAHicY2BkYGBnAAGOPgaG//85+hkYGVCBMgBGGwNYAAAAeJxjYGBgYB8EmKOPgQEAQ04BfgAAAAAAAA4AaAB+AMwA4AECAUIBbAGYAcICGAJYArQC4AMwA7AD3gQwBJYE3AUkBWYFigYgBmYGtAbqB1gIEghYCG4IhAi2COh4nGNgZGBgUGYoZWBnAAEmIOYCQgaG/2A+AwAYCQG2AHicXZBNaoNAGIZfE5PQCKFQ2lUps2oXBfOzzAESyDKBQJdGR2NQR3QSSE/QE/QEPUUPUHqsvsrXjTMw83zPvPMNCuAWP3DQDAejdm1GjzwS7pMmwi75XngAD4/CQ/oX4TFe4Qt7uMMbOzjuDc0EmXCP/C7cJ38Iu+RP4QEe8CU8pP8WHmOPX2EPz87TPo202ey2OjlnQSXV/6arOjWFmvszMWtd6CqwOlKHq6ovycLaWMWVydXKFFZnmVFlZU46tP7R2nI5ncbi/dDkfDtFBA2DDXbYkhKc+V0Bqs5Zt9JM1HQGBRTm/EezTmZNKtpcAMs9Yu6AK9caF76zoLWIWcfMGOSkVduvSWechqZsz040Ib2PY3urxBJTzriT95lipz+TN1fmAAAAeJxtkMl2wjAMRfOAhABlKm2h80C3+ajgCKKDY6cegP59TYBzukAL+z1Zsq8ctaJTTKPrsUQLbXQQI0EXKXroY4AbDDHCGBNMcYsZ7nCPB8yxwCOe8IwXvOIN7/jAJ76wxHfUqWX+OzgumWAjJMV17i0Ndlr6irLKO+qftdT7i6y4uFSUvCknay+lFYZIZaQcmfH/xIFdYn98bqhra1aKTM/6lWMnyaYirx1rFUQZFBkb2zJUtoXeJCeg0WnLtHeSFc3OtrnozNwqi0TkSpBMDB1nSde5oJXW23hTS2/T0LilglXX7dmFVxLnq5U0vYATHFk3zX3BOisoQHNDFDeZnqKDy9hRNawN7Vh727hFzcJ5c8TILrKZfH7tIPxAFP0BpLeJPA==) format("woff");font-weight:400;font-style:normal}.video-js .vjs-big-play-button .vjs-icon-placeholder:before,.video-js .vjs-play-control .vjs-icon-placeholder,.vjs-icon-play{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-big-play-button .vjs-icon-placeholder:before,.video-js .vjs-play-control .vjs-icon-placeholder:before,.vjs-icon-play:before{content:"\\f101"}.vjs-icon-play-circle{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-play-circle:before{content:"\\f102"}.video-js .vjs-play-control.vjs-playing .vjs-icon-placeholder,.vjs-icon-pause{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-play-control.vjs-playing .vjs-icon-placeholder:before,.vjs-icon-pause:before{content:"\\f103"}.video-js .vjs-mute-control.vjs-vol-0 .vjs-icon-placeholder,.vjs-icon-volume-mute{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-mute-control.vjs-vol-0 .vjs-icon-placeholder:before,.vjs-icon-volume-mute:before{content:"\\f104"}.video-js .vjs-mute-control.vjs-vol-1 .vjs-icon-placeholder,.vjs-icon-volume-low{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-mute-control.vjs-vol-1 .vjs-icon-placeholder:before,.vjs-icon-volume-low:before{content:"\\f105"}.video-js .vjs-mute-control.vjs-vol-2 .vjs-icon-placeholder,.vjs-icon-volume-mid{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-mute-control.vjs-vol-2 .vjs-icon-placeholder:before,.vjs-icon-volume-mid:before{content:"\\f106"}.video-js .vjs-mute-control .vjs-icon-placeholder,.vjs-icon-volume-high{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-mute-control .vjs-icon-placeholder:before,.vjs-icon-volume-high:before{content:"\\f107"}.video-js .vjs-fullscreen-control .vjs-icon-placeholder,.vjs-icon-fullscreen-enter{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-fullscreen-control .vjs-icon-placeholder:before,.vjs-icon-fullscreen-enter:before{content:"\\f108"}.video-js.vjs-fullscreen .vjs-fullscreen-control .vjs-icon-placeholder,.vjs-icon-fullscreen-exit{font-family:VideoJS;font-weight:400;font-style:normal}.video-js.vjs-fullscreen .vjs-fullscreen-control .vjs-icon-placeholder:before,.vjs-icon-fullscreen-exit:before{content:"\\f109"}.vjs-icon-square{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-square:before{content:"\\f10a"}.vjs-icon-spinner{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-spinner:before{content:"\\f10b"}.video-js .vjs-subs-caps-button .vjs-icon-placeholder,.video-js .vjs-subtitles-button .vjs-icon-placeholder,.video-js.video-js:lang(en-AU) .vjs-subs-caps-button .vjs-icon-placeholder,.video-js.video-js:lang(en-GB) .vjs-subs-caps-button .vjs-icon-placeholder,.video-js.video-js:lang(en-IE) .vjs-subs-caps-button .vjs-icon-placeholder,.video-js.video-js:lang(en-NZ) .vjs-subs-caps-button .vjs-icon-placeholder,.vjs-icon-subtitles{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-subs-caps-button .vjs-icon-placeholder:before,.video-js .vjs-subtitles-button .vjs-icon-placeholder:before,.video-js.video-js:lang(en-AU) .vjs-subs-caps-button .vjs-icon-placeholder:before,.video-js.video-js:lang(en-GB) .vjs-subs-caps-button .vjs-icon-placeholder:before,.video-js.video-js:lang(en-IE) .vjs-subs-caps-button .vjs-icon-placeholder:before,.video-js.video-js:lang(en-NZ) .vjs-subs-caps-button .vjs-icon-placeholder:before,.vjs-icon-subtitles:before{content:"\\f10c"}.video-js .vjs-captions-button .vjs-icon-placeholder,.video-js:lang(en) .vjs-subs-caps-button .vjs-icon-placeholder,.video-js:lang(fr-CA) .vjs-subs-caps-button .vjs-icon-placeholder,.vjs-icon-captions{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-captions-button .vjs-icon-placeholder:before,.video-js:lang(en) .vjs-subs-caps-button .vjs-icon-placeholder:before,.video-js:lang(fr-CA) .vjs-subs-caps-button .vjs-icon-placeholder:before,.vjs-icon-captions:before{content:"\\f10d"}.video-js .vjs-chapters-button .vjs-icon-placeholder,.vjs-icon-chapters{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-chapters-button .vjs-icon-placeholder:before,.vjs-icon-chapters:before{content:"\\f10e"}.vjs-icon-share{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-share:before{content:"\\f10f"}.vjs-icon-cog{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-cog:before{content:"\\f110"}.video-js .vjs-play-progress,.video-js .vjs-volume-level,.vjs-icon-circle,.vjs-seek-to-live-control .vjs-icon-placeholder{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-play-progress:before,.video-js .vjs-volume-level:before,.vjs-icon-circle:before,.vjs-seek-to-live-control .vjs-icon-placeholder:before{content:"\\f111"}.vjs-icon-circle-outline{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-circle-outline:before{content:"\\f112"}.vjs-icon-circle-inner-circle{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-circle-inner-circle:before{content:"\\f113"}.vjs-icon-hd{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-hd:before{content:"\\f114"}.video-js .vjs-control.vjs-close-button .vjs-icon-placeholder,.vjs-icon-cancel{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-control.vjs-close-button .vjs-icon-placeholder:before,.vjs-icon-cancel:before{content:"\\f115"}.video-js .vjs-play-control.vjs-ended .vjs-icon-placeholder,.vjs-icon-replay{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-play-control.vjs-ended .vjs-icon-placeholder:before,.vjs-icon-replay:before{content:"\\f116"}.vjs-icon-facebook{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-facebook:before{content:"\\f117"}.vjs-icon-gplus{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-gplus:before{content:"\\f118"}.vjs-icon-linkedin{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-linkedin:before{content:"\\f119"}.vjs-icon-twitter{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-twitter:before{content:"\\f11a"}.vjs-icon-tumblr{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-tumblr:before{content:"\\f11b"}.vjs-icon-pinterest{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-pinterest:before{content:"\\f11c"}.video-js .vjs-descriptions-button .vjs-icon-placeholder,.vjs-icon-audio-description{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-descriptions-button .vjs-icon-placeholder:before,.vjs-icon-audio-description:before{content:"\\f11d"}.video-js .vjs-audio-button .vjs-icon-placeholder,.vjs-icon-audio{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-audio-button .vjs-icon-placeholder:before,.vjs-icon-audio:before{content:"\\f11e"}.vjs-icon-next-item{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-next-item:before{content:"\\f11f"}.vjs-icon-previous-item{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-previous-item:before{content:"\\f120"}.video-js .vjs-picture-in-picture-control .vjs-icon-placeholder,.vjs-icon-picture-in-picture-enter{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-picture-in-picture-control .vjs-icon-placeholder:before,.vjs-icon-picture-in-picture-enter:before{content:"\\f121"}.video-js.vjs-picture-in-picture .vjs-picture-in-picture-control .vjs-icon-placeholder,.vjs-icon-picture-in-picture-exit{font-family:VideoJS;font-weight:400;font-style:normal}.video-js.vjs-picture-in-picture .vjs-picture-in-picture-control .vjs-icon-placeholder:before,.vjs-icon-picture-in-picture-exit:before{content:"\\f122"}.video-js{display:block;vertical-align:top;box-sizing:border-box;color:#fff;background-color:#000;position:relative;padding:0;font-size:10px;line-height:1;font-weight:400;font-style:normal;font-family:Arial,Helvetica,sans-serif;word-break:initial}.video-js:-moz-full-screen{position:absolute}.video-js:-webkit-full-screen{width:100%!important;height:100%!important}.video-js[tabindex="-1"]{outline:0}.video-js *,.video-js :after,.video-js :before{box-sizing:inherit}.video-js ul{font-family:inherit;font-size:inherit;line-height:inherit;list-style-position:outside;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.video-js.vjs-1-1,.video-js.vjs-16-9,.video-js.vjs-4-3,.video-js.vjs-9-16,.video-js.vjs-fluid{width:100%;max-width:100%;height:0}.video-js.vjs-16-9{padding-top:56.25%}.video-js.vjs-4-3{padding-top:75%}.video-js.vjs-9-16{padding-top:177.7777777778%}.video-js.vjs-1-1{padding-top:100%}.video-js.vjs-fill{width:100%;height:100%}.video-js .vjs-tech{position:absolute;top:0;left:0;width:100%;height:100%}body.vjs-full-window{padding:0;margin:0;height:100%}.vjs-full-window .video-js.vjs-fullscreen{position:fixed;overflow:hidden;z-index:1000;left:0;top:0;bottom:0;right:0}.video-js.vjs-fullscreen:not(.vjs-ios-native-fs){width:100%!important;height:100%!important;padding-top:0!important}.video-js.vjs-fullscreen.vjs-user-inactive{cursor:none}.vjs-hidden{display:none!important}.vjs-disabled{opacity:.5;cursor:default}.video-js .vjs-offscreen{height:1px;left:-9999px;position:absolute;top:0;width:1px}.vjs-lock-showing{display:block!important;opacity:1!important;visibility:visible!important}.vjs-no-js{padding:20px;color:#fff;background-color:#000;font-size:18px;font-family:Arial,Helvetica,sans-serif;text-align:center;width:300px;height:150px;margin:0 auto}.vjs-no-js a,.vjs-no-js a:visited{color:#66a8cc}.video-js .vjs-big-play-button{font-size:3em;line-height:1.5em;height:1.63332em;width:3em;display:block;position:absolute;top:10px;left:10px;padding:0;cursor:pointer;opacity:1;border:.06666em solid #fff;background-color:#2b333f;background-color:rgba(43,51,63,.7);border-radius:.3em;transition:all .4s}.vjs-big-play-centered .vjs-big-play-button{top:50%;left:50%;margin-top:-.81666em;margin-left:-1.5em}.video-js .vjs-big-play-button:focus,.video-js:hover .vjs-big-play-button{border-color:#fff;background-color:#73859f;background-color:rgba(115,133,159,.5);transition:all 0s}.vjs-controls-disabled .vjs-big-play-button,.vjs-error .vjs-big-play-button,.vjs-has-started .vjs-big-play-button,.vjs-using-native-controls .vjs-big-play-button{display:none}.vjs-has-started.vjs-paused.vjs-show-big-play-button-on-pause .vjs-big-play-button{display:block}.video-js button{background:0 0;border:none;color:inherit;display:inline-block;font-size:inherit;line-height:inherit;text-transform:none;text-decoration:none;transition:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.vjs-control .vjs-button{width:100%;height:100%}.video-js .vjs-control.vjs-close-button{cursor:pointer;height:3em;position:absolute;right:0;top:.5em;z-index:2}.video-js .vjs-modal-dialog{background:rgba(0,0,0,.8);background:linear-gradient(180deg,rgba(0,0,0,.8),rgba(255,255,255,0));overflow:auto}.video-js .vjs-modal-dialog>*{box-sizing:border-box}.vjs-modal-dialog .vjs-modal-dialog-content{font-size:1.2em;line-height:1.5;padding:20px 24px;z-index:1}.vjs-menu-button{cursor:pointer}.vjs-menu-button.vjs-disabled{cursor:default}.vjs-workinghover .vjs-menu-button.vjs-disabled:hover .vjs-menu{display:none}.vjs-menu .vjs-menu-content{display:block;padding:0;margin:0;font-family:Arial,Helvetica,sans-serif;overflow:auto}.vjs-menu .vjs-menu-content>*{box-sizing:border-box}.vjs-scrubbing .vjs-control.vjs-menu-button:hover .vjs-menu{display:none}.vjs-menu li{list-style:none;margin:0;padding:.2em 0;line-height:1.4em;font-size:1.2em;text-align:center;text-transform:lowercase}.js-focus-visible .vjs-menu li.vjs-menu-item:hover,.vjs-menu li.vjs-menu-item:focus,.vjs-menu li.vjs-menu-item:hover{background-color:#73859f;background-color:rgba(115,133,159,.5)}.js-focus-visible .vjs-menu li.vjs-selected:hover,.vjs-menu li.vjs-selected,.vjs-menu li.vjs-selected:focus,.vjs-menu li.vjs-selected:hover{background-color:#fff;color:#2b333f}.js-focus-visible .vjs-menu :not(.vjs-selected):focus:not(.focus-visible),.video-js .vjs-menu :not(.vjs-selected):focus:not(:focus-visible){background:0 0}.vjs-menu li.vjs-menu-title{text-align:center;text-transform:uppercase;font-size:1em;line-height:2em;padding:0;margin:0 0 .3em 0;font-weight:700;cursor:default}.vjs-menu-button-popup .vjs-menu{display:none;position:absolute;bottom:0;width:10em;left:-3em;height:0;margin-bottom:1.5em;border-top-color:rgba(43,51,63,.7)}.vjs-menu-button-popup .vjs-menu .vjs-menu-content{background-color:#2b333f;background-color:rgba(43,51,63,.7);position:absolute;width:100%;bottom:1.5em;max-height:15em}.vjs-layout-tiny .vjs-menu-button-popup .vjs-menu .vjs-menu-content,.vjs-layout-x-small .vjs-menu-button-popup .vjs-menu .vjs-menu-content{max-height:5em}.vjs-layout-small .vjs-menu-button-popup .vjs-menu .vjs-menu-content{max-height:10em}.vjs-layout-medium .vjs-menu-button-popup .vjs-menu .vjs-menu-content{max-height:14em}.vjs-layout-huge .vjs-menu-button-popup .vjs-menu .vjs-menu-content,.vjs-layout-large .vjs-menu-button-popup .vjs-menu .vjs-menu-content,.vjs-layout-x-large .vjs-menu-button-popup .vjs-menu .vjs-menu-content{max-height:25em}.vjs-menu-button-popup .vjs-menu.vjs-lock-showing,.vjs-workinghover .vjs-menu-button-popup.vjs-hover .vjs-menu{display:block}.video-js .vjs-menu-button-inline{transition:all .4s;overflow:hidden}.video-js .vjs-menu-button-inline:before{width:2.222222222em}.video-js .vjs-menu-button-inline.vjs-slider-active,.video-js .vjs-menu-button-inline:focus,.video-js .vjs-menu-button-inline:hover,.video-js.vjs-no-flex .vjs-menu-button-inline{width:12em}.vjs-menu-button-inline .vjs-menu{opacity:0;height:100%;width:auto;position:absolute;left:4em;top:0;padding:0;margin:0;transition:all .4s}.vjs-menu-button-inline.vjs-slider-active .vjs-menu,.vjs-menu-button-inline:focus .vjs-menu,.vjs-menu-button-inline:hover .vjs-menu{display:block;opacity:1}.vjs-no-flex .vjs-menu-button-inline .vjs-menu{display:block;opacity:1;position:relative;width:auto}.vjs-no-flex .vjs-menu-button-inline.vjs-slider-active .vjs-menu,.vjs-no-flex .vjs-menu-button-inline:focus .vjs-menu,.vjs-no-flex .vjs-menu-button-inline:hover .vjs-menu{width:auto}.vjs-menu-button-inline .vjs-menu-content{width:auto;height:100%;margin:0;overflow:hidden}.video-js .vjs-control-bar{display:none;width:100%;position:absolute;bottom:0;left:0;right:0;height:3em;background-color:#2b333f;background-color:rgba(43,51,63,.7)}.vjs-has-started .vjs-control-bar{display:flex;visibility:visible;opacity:1;transition:visibility .1s,opacity .1s}.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar{visibility:visible;opacity:0;pointer-events:none;transition:visibility 1s,opacity 1s}.vjs-controls-disabled .vjs-control-bar,.vjs-error .vjs-control-bar,.vjs-using-native-controls .vjs-control-bar{display:none!important}.vjs-audio.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar{opacity:1;visibility:visible}.vjs-has-started.vjs-no-flex .vjs-control-bar{display:table}.video-js .vjs-control{position:relative;text-align:center;margin:0;padding:0;height:100%;width:4em;flex:none}.vjs-button>.vjs-icon-placeholder:before{font-size:1.8em;line-height:1.67}.vjs-button>.vjs-icon-placeholder{display:block}.video-js .vjs-control:focus,.video-js .vjs-control:focus:before,.video-js .vjs-control:hover:before{text-shadow:0 0 1em #fff}.video-js .vjs-control-text{border:0;clip:rect(0 0 0 0);height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.vjs-no-flex .vjs-control{display:table-cell;vertical-align:middle}.video-js .vjs-custom-control-spacer{display:none}.video-js .vjs-progress-control{cursor:pointer;flex:auto;display:flex;align-items:center;min-width:4em;touch-action:none}.video-js .vjs-progress-control.disabled{cursor:default}.vjs-live .vjs-progress-control{display:none}.vjs-liveui .vjs-progress-control{display:flex;align-items:center}.vjs-no-flex .vjs-progress-control{width:auto}.video-js .vjs-progress-holder{flex:auto;transition:all .2s;height:.3em}.video-js .vjs-progress-control .vjs-progress-holder{margin:0 10px}.video-js .vjs-progress-control:hover .vjs-progress-holder{font-size:1.6666666667em}.video-js .vjs-progress-control:hover .vjs-progress-holder.disabled{font-size:1em}.video-js .vjs-progress-holder .vjs-load-progress,.video-js .vjs-progress-holder .vjs-load-progress div,.video-js .vjs-progress-holder .vjs-play-progress{position:absolute;display:block;height:100%;margin:0;padding:0;width:0}.video-js .vjs-play-progress{background-color:#fff}.video-js .vjs-play-progress:before{font-size:.9em;position:absolute;right:-.5em;top:-.3333333333em;z-index:1}.video-js .vjs-load-progress{background:rgba(115,133,159,.5)}.video-js .vjs-load-progress div{background:rgba(115,133,159,.75)}.video-js .vjs-time-tooltip{background-color:#fff;background-color:rgba(255,255,255,.8);border-radius:.3em;color:#000;float:right;font-family:Arial,Helvetica,sans-serif;font-size:1em;padding:6px 8px 8px 8px;pointer-events:none;position:absolute;top:-3.4em;visibility:hidden;z-index:1}.video-js .vjs-progress-holder:focus .vjs-time-tooltip{display:none}.video-js .vjs-progress-control:hover .vjs-progress-holder:focus .vjs-time-tooltip,.video-js .vjs-progress-control:hover .vjs-time-tooltip{display:block;font-size:.6em;visibility:visible}.video-js .vjs-progress-control.disabled:hover .vjs-time-tooltip{font-size:1em}.video-js .vjs-progress-control .vjs-mouse-display{display:none;position:absolute;width:1px;height:100%;background-color:#000;z-index:1}.vjs-no-flex .vjs-progress-control .vjs-mouse-display{z-index:0}.video-js .vjs-progress-control:hover .vjs-mouse-display{display:block}.video-js.vjs-user-inactive .vjs-progress-control .vjs-mouse-display{visibility:hidden;opacity:0;transition:visibility 1s,opacity 1s}.video-js.vjs-user-inactive.vjs-no-flex .vjs-progress-control .vjs-mouse-display{display:none}.vjs-mouse-display .vjs-time-tooltip{color:#fff;background-color:#000;background-color:rgba(0,0,0,.8)}.video-js .vjs-slider{position:relative;cursor:pointer;padding:0;margin:0 .45em 0 .45em;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:#73859f;background-color:rgba(115,133,159,.5)}.video-js .vjs-slider.disabled{cursor:default}.video-js .vjs-slider:focus{text-shadow:0 0 1em #fff;box-shadow:0 0 1em #fff}.video-js .vjs-mute-control{cursor:pointer;flex:none}.video-js .vjs-volume-control{cursor:pointer;margin-right:1em;display:flex}.video-js .vjs-volume-control.vjs-volume-horizontal{width:5em}.video-js .vjs-volume-panel .vjs-volume-control{visibility:visible;opacity:0;width:1px;height:1px;margin-left:-1px}.video-js .vjs-volume-panel{transition:width 1s}.video-js .vjs-volume-panel .vjs-volume-control.vjs-slider-active,.video-js .vjs-volume-panel .vjs-volume-control:active,.video-js .vjs-volume-panel.vjs-hover .vjs-mute-control~.vjs-volume-control,.video-js .vjs-volume-panel.vjs-hover .vjs-volume-control,.video-js .vjs-volume-panel:active .vjs-volume-control,.video-js .vjs-volume-panel:focus .vjs-volume-control{visibility:visible;opacity:1;position:relative;transition:visibility .1s,opacity .1s,height .1s,width .1s,left 0s,top 0s}.video-js .vjs-volume-panel .vjs-volume-control.vjs-slider-active.vjs-volume-horizontal,.video-js .vjs-volume-panel .vjs-volume-control:active.vjs-volume-horizontal,.video-js .vjs-volume-panel.vjs-hover .vjs-mute-control~.vjs-volume-control.vjs-volume-horizontal,.video-js .vjs-volume-panel.vjs-hover .vjs-volume-control.vjs-volume-horizontal,.video-js .vjs-volume-panel:active .vjs-volume-control.vjs-volume-horizontal,.video-js .vjs-volume-panel:focus .vjs-volume-control.vjs-volume-horizontal{width:5em;height:3em;margin-right:0}.video-js .vjs-volume-panel .vjs-volume-control.vjs-slider-active.vjs-volume-vertical,.video-js .vjs-volume-panel .vjs-volume-control:active.vjs-volume-vertical,.video-js .vjs-volume-panel.vjs-hover .vjs-mute-control~.vjs-volume-control.vjs-volume-vertical,.video-js .vjs-volume-panel.vjs-hover .vjs-volume-control.vjs-volume-vertical,.video-js .vjs-volume-panel:active .vjs-volume-control.vjs-volume-vertical,.video-js .vjs-volume-panel:focus .vjs-volume-control.vjs-volume-vertical{left:-3.5em;transition:left 0s}.video-js .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-hover,.video-js .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-slider-active,.video-js .vjs-volume-panel.vjs-volume-panel-horizontal:active{width:10em;transition:width .1s}.video-js .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-mute-toggle-only{width:4em}.video-js .vjs-volume-panel .vjs-volume-control.vjs-volume-vertical{height:8em;width:3em;left:-3000em;transition:visibility 1s,opacity 1s,height 1s 1s,width 1s 1s,left 1s 1s,top 1s 1s}.video-js .vjs-volume-panel .vjs-volume-control.vjs-volume-horizontal{transition:visibility 1s,opacity 1s,height 1s 1s,width 1s,left 1s 1s,top 1s 1s}.video-js.vjs-no-flex .vjs-volume-panel .vjs-volume-control.vjs-volume-horizontal{width:5em;height:3em;visibility:visible;opacity:1;position:relative;transition:none}.video-js.vjs-no-flex .vjs-volume-control.vjs-volume-vertical,.video-js.vjs-no-flex .vjs-volume-panel .vjs-volume-control.vjs-volume-vertical{position:absolute;bottom:3em;left:.5em}.video-js .vjs-volume-panel{display:flex}.video-js .vjs-volume-bar{margin:1.35em .45em}.vjs-volume-bar.vjs-slider-horizontal{width:5em;height:.3em}.vjs-volume-bar.vjs-slider-vertical{width:.3em;height:5em;margin:1.35em auto}.video-js .vjs-volume-level{position:absolute;bottom:0;left:0;background-color:#fff}.video-js .vjs-volume-level:before{position:absolute;font-size:.9em;z-index:1}.vjs-slider-vertical .vjs-volume-level{width:.3em}.vjs-slider-vertical .vjs-volume-level:before{top:-.5em;left:-.3em;z-index:1}.vjs-slider-horizontal .vjs-volume-level{height:.3em}.vjs-slider-horizontal .vjs-volume-level:before{top:-.3em;right:-.5em}.video-js .vjs-volume-panel.vjs-volume-panel-vertical{width:4em}.vjs-volume-bar.vjs-slider-vertical .vjs-volume-level{height:100%}.vjs-volume-bar.vjs-slider-horizontal .vjs-volume-level{width:100%}.video-js .vjs-volume-vertical{width:3em;height:8em;bottom:8em;background-color:#2b333f;background-color:rgba(43,51,63,.7)}.video-js .vjs-volume-horizontal .vjs-menu{left:-2em}.video-js .vjs-volume-tooltip{background-color:#fff;background-color:rgba(255,255,255,.8);border-radius:.3em;color:#000;float:right;font-family:Arial,Helvetica,sans-serif;font-size:1em;padding:6px 8px 8px 8px;pointer-events:none;position:absolute;top:-3.4em;visibility:hidden;z-index:1}.video-js .vjs-volume-control:hover .vjs-progress-holder:focus .vjs-volume-tooltip,.video-js .vjs-volume-control:hover .vjs-volume-tooltip{display:block;font-size:1em;visibility:visible}.video-js .vjs-volume-vertical:hover .vjs-progress-holder:focus .vjs-volume-tooltip,.video-js .vjs-volume-vertical:hover .vjs-volume-tooltip{left:1em;top:-12px}.video-js .vjs-volume-control.disabled:hover .vjs-volume-tooltip{font-size:1em}.video-js .vjs-volume-control .vjs-mouse-display{display:none;position:absolute;width:100%;height:1px;background-color:#000;z-index:1}.video-js .vjs-volume-horizontal .vjs-mouse-display{width:1px;height:100%}.vjs-no-flex .vjs-volume-control .vjs-mouse-display{z-index:0}.video-js .vjs-volume-control:hover .vjs-mouse-display{display:block}.video-js.vjs-user-inactive .vjs-volume-control .vjs-mouse-display{visibility:hidden;opacity:0;transition:visibility 1s,opacity 1s}.video-js.vjs-user-inactive.vjs-no-flex .vjs-volume-control .vjs-mouse-display{display:none}.vjs-mouse-display .vjs-volume-tooltip{color:#fff;background-color:#000;background-color:rgba(0,0,0,.8)}.vjs-poster{display:inline-block;vertical-align:middle;background-repeat:no-repeat;background-position:50% 50%;background-size:contain;background-color:#000;cursor:pointer;margin:0;padding:0;position:absolute;top:0;right:0;bottom:0;left:0;height:100%}.vjs-has-started .vjs-poster{display:none}.vjs-audio.vjs-has-started .vjs-poster{display:block}.vjs-using-native-controls .vjs-poster{display:none}.video-js .vjs-live-control{display:flex;align-items:flex-start;flex:auto;font-size:1em;line-height:3em}.vjs-no-flex .vjs-live-control{display:table-cell;width:auto;text-align:left}.video-js.vjs-liveui .vjs-live-control,.video-js:not(.vjs-live) .vjs-live-control{display:none}.video-js .vjs-seek-to-live-control{align-items:center;cursor:pointer;flex:none;display:inline-flex;height:100%;padding-left:.5em;padding-right:.5em;font-size:1em;line-height:3em;width:auto;min-width:4em}.vjs-no-flex .vjs-seek-to-live-control{display:table-cell;width:auto;text-align:left}.video-js.vjs-live:not(.vjs-liveui) .vjs-seek-to-live-control,.video-js:not(.vjs-live) .vjs-seek-to-live-control{display:none}.vjs-seek-to-live-control.vjs-control.vjs-at-live-edge{cursor:auto}.vjs-seek-to-live-control .vjs-icon-placeholder{margin-right:.5em;color:#888}.vjs-seek-to-live-control.vjs-control.vjs-at-live-edge .vjs-icon-placeholder{color:red}.video-js .vjs-time-control{flex:none;font-size:1em;line-height:3em;min-width:2em;width:auto;padding-left:1em;padding-right:1em}.vjs-live .vjs-time-control{display:none}.video-js .vjs-current-time,.vjs-no-flex .vjs-current-time{display:none}.video-js .vjs-duration,.vjs-no-flex .vjs-duration{display:none}.vjs-time-divider{display:none;line-height:3em}.vjs-live .vjs-time-divider{display:none}.video-js .vjs-play-control{cursor:pointer}.video-js .vjs-play-control .vjs-icon-placeholder{flex:none}.vjs-text-track-display{position:absolute;bottom:3em;left:0;right:0;top:0;pointer-events:none}.video-js.vjs-user-inactive.vjs-playing .vjs-text-track-display{bottom:1em}.video-js .vjs-text-track{font-size:1.4em;text-align:center;margin-bottom:.1em}.vjs-subtitles{color:#fff}.vjs-captions{color:#fc6}.vjs-tt-cue{display:block}video::-webkit-media-text-track-display{transform:translateY(-3em)}.video-js.vjs-user-inactive.vjs-playing video::-webkit-media-text-track-display{transform:translateY(-1.5em)}.video-js .vjs-picture-in-picture-control{cursor:pointer;flex:none}.video-js .vjs-fullscreen-control{cursor:pointer;flex:none}.vjs-playback-rate .vjs-playback-rate-value,.vjs-playback-rate>.vjs-menu-button{position:absolute;top:0;left:0;width:100%;height:100%}.vjs-playback-rate .vjs-playback-rate-value{pointer-events:none;font-size:1.5em;line-height:2;text-align:center}.vjs-playback-rate .vjs-menu{width:4em;left:0}.vjs-error .vjs-error-display .vjs-modal-dialog-content{font-size:1.4em;text-align:center}.vjs-error .vjs-error-display:before{color:#fff;content:"X";font-family:Arial,Helvetica,sans-serif;font-size:4em;left:0;line-height:1;margin-top:-.5em;position:absolute;text-shadow:.05em .05em .1em #000;text-align:center;top:50%;vertical-align:middle;width:100%}.vjs-loading-spinner{display:none;position:absolute;top:50%;left:50%;margin:-25px 0 0 -25px;opacity:.85;text-align:left;border:6px solid rgba(43,51,63,.7);box-sizing:border-box;background-clip:padding-box;width:50px;height:50px;border-radius:25px;visibility:hidden}.vjs-seeking .vjs-loading-spinner,.vjs-waiting .vjs-loading-spinner{display:block;-webkit-animation:vjs-spinner-show 0s linear .3s forwards;animation:vjs-spinner-show 0s linear .3s forwards}.vjs-loading-spinner:after,.vjs-loading-spinner:before{content:"";position:absolute;margin:-6px;box-sizing:inherit;width:inherit;height:inherit;border-radius:inherit;opacity:1;border:inherit;border-color:transparent;border-top-color:#fff}.vjs-seeking .vjs-loading-spinner:after,.vjs-seeking .vjs-loading-spinner:before,.vjs-waiting .vjs-loading-spinner:after,.vjs-waiting .vjs-loading-spinner:before{-webkit-animation:vjs-spinner-spin 1.1s cubic-bezier(.6,.2,0,.8) infinite,vjs-spinner-fade 1.1s linear infinite;animation:vjs-spinner-spin 1.1s cubic-bezier(.6,.2,0,.8) infinite,vjs-spinner-fade 1.1s linear infinite}.vjs-seeking .vjs-loading-spinner:before,.vjs-waiting .vjs-loading-spinner:before{border-top-color:#fff}.vjs-seeking .vjs-loading-spinner:after,.vjs-waiting .vjs-loading-spinner:after{border-top-color:#fff;-webkit-animation-delay:.44s;animation-delay:.44s}@keyframes vjs-spinner-show{to{visibility:visible}}@-webkit-keyframes vjs-spinner-show{to{visibility:visible}}@keyframes vjs-spinner-spin{100%{transform:rotate(360deg)}}@-webkit-keyframes vjs-spinner-spin{100%{-webkit-transform:rotate(360deg)}}@keyframes vjs-spinner-fade{0%{border-top-color:#73859f}20%{border-top-color:#73859f}35%{border-top-color:#fff}60%{border-top-color:#73859f}100%{border-top-color:#73859f}}@-webkit-keyframes vjs-spinner-fade{0%{border-top-color:#73859f}20%{border-top-color:#73859f}35%{border-top-color:#fff}60%{border-top-color:#73859f}100%{border-top-color:#73859f}}.vjs-chapters-button .vjs-menu ul{width:24em}.video-js .vjs-subs-caps-button+.vjs-menu .vjs-captions-menu-item .vjs-menu-item-text .vjs-icon-placeholder{vertical-align:middle;display:inline-block;margin-bottom:-.1em}.video-js .vjs-subs-caps-button+.vjs-menu .vjs-captions-menu-item .vjs-menu-item-text .vjs-icon-placeholder:before{font-family:VideoJS;content:"";font-size:1.5em;line-height:inherit}.video-js .vjs-audio-button+.vjs-menu .vjs-main-desc-menu-item .vjs-menu-item-text .vjs-icon-placeholder{vertical-align:middle;display:inline-block;margin-bottom:-.1em}.video-js .vjs-audio-button+.vjs-menu .vjs-main-desc-menu-item .vjs-menu-item-text .vjs-icon-placeholder:before{font-family:VideoJS;content:" ";font-size:1.5em;line-height:inherit}.video-js.vjs-layout-small .vjs-current-time,.video-js.vjs-layout-small .vjs-duration,.video-js.vjs-layout-small .vjs-playback-rate,.video-js.vjs-layout-small .vjs-remaining-time,.video-js.vjs-layout-small .vjs-time-divider,.video-js.vjs-layout-small .vjs-volume-control,.video-js.vjs-layout-tiny .vjs-current-time,.video-js.vjs-layout-tiny .vjs-duration,.video-js.vjs-layout-tiny .vjs-playback-rate,.video-js.vjs-layout-tiny .vjs-remaining-time,.video-js.vjs-layout-tiny .vjs-time-divider,.video-js.vjs-layout-tiny .vjs-volume-control,.video-js.vjs-layout-x-small .vjs-current-time,.video-js.vjs-layout-x-small .vjs-duration,.video-js.vjs-layout-x-small .vjs-playback-rate,.video-js.vjs-layout-x-small .vjs-remaining-time,.video-js.vjs-layout-x-small .vjs-time-divider,.video-js.vjs-layout-x-small .vjs-volume-control{display:none}.video-js.vjs-layout-small .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-hover,.video-js.vjs-layout-small .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-slider-active,.video-js.vjs-layout-small .vjs-volume-panel.vjs-volume-panel-horizontal:active,.video-js.vjs-layout-small .vjs-volume-panel.vjs-volume-panel-horizontal:hover,.video-js.vjs-layout-tiny .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-hover,.video-js.vjs-layout-tiny .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-slider-active,.video-js.vjs-layout-tiny .vjs-volume-panel.vjs-volume-panel-horizontal:active,.video-js.vjs-layout-tiny .vjs-volume-panel.vjs-volume-panel-horizontal:hover,.video-js.vjs-layout-x-small .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-hover,.video-js.vjs-layout-x-small .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-slider-active,.video-js.vjs-layout-x-small .vjs-volume-panel.vjs-volume-panel-horizontal:active,.video-js.vjs-layout-x-small .vjs-volume-panel.vjs-volume-panel-horizontal:hover{width:auto;width:initial}.video-js.vjs-layout-tiny .vjs-progress-control,.video-js.vjs-layout-x-small .vjs-progress-control{display:none}.video-js.vjs-layout-x-small .vjs-custom-control-spacer{flex:auto;display:block}.video-js.vjs-layout-x-small.vjs-no-flex .vjs-custom-control-spacer{width:auto}.vjs-modal-dialog.vjs-text-track-settings{background-color:#2b333f;background-color:rgba(43,51,63,.75);color:#fff;height:70%}.vjs-text-track-settings .vjs-modal-dialog-content{display:table}.vjs-text-track-settings .vjs-track-settings-colors,.vjs-text-track-settings .vjs-track-settings-controls,.vjs-text-track-settings .vjs-track-settings-font{display:table-cell}.vjs-text-track-settings .vjs-track-settings-controls{text-align:right;vertical-align:bottom}@supports (display:grid){.vjs-text-track-settings .vjs-modal-dialog-content{display:grid;grid-template-columns:1fr 1fr;grid-template-rows:1fr;padding:20px 24px 0 24px}.vjs-track-settings-controls .vjs-default-button{margin-bottom:20px}.vjs-text-track-settings .vjs-track-settings-controls{grid-column:1/-1}.vjs-layout-small .vjs-text-track-settings .vjs-modal-dialog-content,.vjs-layout-tiny .vjs-text-track-settings .vjs-modal-dialog-content,.vjs-layout-x-small .vjs-text-track-settings .vjs-modal-dialog-content{grid-template-columns:1fr}}.vjs-track-setting>select{margin-right:1em;margin-bottom:.5em}.vjs-text-track-settings fieldset{margin:5px;padding:3px;border:none}.vjs-text-track-settings fieldset span{display:inline-block}.vjs-text-track-settings fieldset span>select{max-width:7.3em}.vjs-text-track-settings legend{color:#fff;margin:0 0 5px 0}.vjs-text-track-settings .vjs-label{position:absolute;clip:rect(1px 1px 1px 1px);clip:rect(1px,1px,1px,1px);display:block;margin:0 0 5px 0;padding:0;border:0;height:1px;width:1px;overflow:hidden}.vjs-track-settings-controls button:active,.vjs-track-settings-controls button:focus{outline-style:solid;outline-width:medium;background-image:linear-gradient(0deg,#fff 88%,#73859f 100%)}.vjs-track-settings-controls button:hover{color:rgba(43,51,63,.75)}.vjs-track-settings-controls button{background-color:#fff;background-image:linear-gradient(-180deg,#fff 88%,#73859f 100%);color:#2b333f;cursor:pointer;border-radius:2px}.vjs-track-settings-controls .vjs-default-button{margin-right:1em}@media print{.video-js>:not(.vjs-tech):not(.vjs-poster){visibility:hidden}}.vjs-resize-manager{position:absolute;top:0;left:0;width:100%;height:100%;border:none;z-index:-1000}.js-focus-visible .video-js :focus:not(.focus-visible){outline:0}.video-js :focus:not(:focus-visible){outline:0}`;
styleInject(css_248z);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var video = {exports: {}};

/**
 * @license
 * Video.js 7.18.1 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
(function (module, exports) {
(function (global, factory) {
  module.exports = factory() ;
}(commonjsGlobal, (function () {  var version$5 = "7.18.1";
  var hooks_ = {};
  var hooks = function hooks(type, fn) {
    hooks_[type] = hooks_[type] || [];
    if (fn) {
      hooks_[type] = hooks_[type].concat(fn);
    }
    return hooks_[type];
  };
  var hook = function hook(type, fn) {
    hooks(type, fn);
  };
  var removeHook = function removeHook(type, fn) {
    var index = hooks(type).indexOf(fn);
    if (index <= -1) {
      return false;
    }
    hooks_[type] = hooks_[type].slice();
    hooks_[type].splice(index, 1);
    return true;
  };
  var hookOnce = function hookOnce(type, fn) {
    hooks(type, [].concat(fn).map(function (original) {
      var wrapper = function wrapper() {
        removeHook(type, wrapper);
        return original.apply(void 0, arguments);
      };
      return wrapper;
    }));
  };
  var FullscreenApi = {
    prefixed: true
  };
  var apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror', 'fullscreen'],
  ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror', '-webkit-full-screen'],
  ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror', '-moz-full-screen'],
  ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError', '-ms-fullscreen']];
  var specApi = apiMap[0];
  var browserApi;
  for (var i = 0; i < apiMap.length; i++) {
    if (apiMap[i][1] in document) {
      browserApi = apiMap[i];
      break;
    }
  }
  if (browserApi) {
    for (var _i = 0; _i < browserApi.length; _i++) {
      FullscreenApi[specApi[_i]] = browserApi[_i];
    }
    FullscreenApi.prefixed = browserApi[0] !== specApi[0];
  }
  var history = [];
  var LogByTypeFactory = function LogByTypeFactory(name, log) {
    return function (type, level, args) {
      var lvl = log.levels[level];
      var lvlRegExp = new RegExp("^(" + lvl + ")$");
      if (type !== 'log') {
        args.unshift(type.toUpperCase() + ':');
      }
      args.unshift(name + ':');
      if (history) {
        history.push([].concat(args));
        var splice = history.length - 1000;
        history.splice(0, splice > 0 ? splice : 0);
      }
      if (!window.console) {
        return;
      }
      var fn = window.console[type];
      if (!fn && type === 'debug') {
        fn = window.console.info || window.console.log;
      }
      if (!fn || !lvl || !lvlRegExp.test(type)) {
        return;
      }
      fn[Array.isArray(args) ? 'apply' : 'call'](window.console, args);
    };
  };
  function createLogger$1(name) {
    var level = 'info';
    var logByType;
    var log = function log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      logByType('log', level, args);
    };
    logByType = LogByTypeFactory(name, log);
    log.createLogger = function (subname) {
      return createLogger$1(name + ': ' + subname);
    };
    log.levels = {
      all: 'debug|log|warn|error',
      off: '',
      debug: 'debug|log|warn|error',
      info: 'log|warn|error',
      warn: 'warn|error',
      error: 'error',
      DEFAULT: level
    };
    log.level = function (lvl) {
      if (typeof lvl === 'string') {
        if (!log.levels.hasOwnProperty(lvl)) {
          throw new Error("\"" + lvl + "\" in not a valid log level");
        }
        level = lvl;
      }
      return level;
    };
    log.history = function () {
      return history ? [].concat(history) : [];
    };
    log.history.filter = function (fname) {
      return (history || []).filter(function (historyItem) {
        return new RegExp(".*" + fname + ".*").test(historyItem[0]);
      });
    };
    log.history.clear = function () {
      if (history) {
        history.length = 0;
      }
    };
    log.history.disable = function () {
      if (history !== null) {
        history.length = 0;
        history = null;
      }
    };
    log.history.enable = function () {
      if (history === null) {
        history = [];
      }
    };
    log.error = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return logByType('error', level, args);
    };
    log.warn = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return logByType('warn', level, args);
    };
    log.debug = function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return logByType('debug', level, args);
    };
    return log;
  }
  var log$1 = createLogger$1('VIDEOJS');
  var createLogger = log$1.createLogger;
  var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};
  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }
  var _extends_1 = createCommonjsModule(function (module) {
    function _extends() {
      module.exports = _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    module.exports = _extends;
  });
  var toString$1 = Object.prototype.toString;
  var keys = function keys(object) {
    return isObject$1(object) ? Object.keys(object) : [];
  };
  function each(object, fn) {
    keys(object).forEach(function (key) {
      return fn(object[key], key);
    });
  }
  function reduce(object, fn, initial) {
    if (initial === void 0) {
      initial = 0;
    }
    return keys(object).reduce(function (accum, key) {
      return fn(accum, object[key], key);
    }, initial);
  }
  function assign(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }
    if (Object.assign) {
      return _extends_1.apply(void 0, [target].concat(sources));
    }
    sources.forEach(function (source) {
      if (!source) {
        return;
      }
      each(source, function (value, key) {
        target[key] = value;
      });
    });
    return target;
  }
  function isObject$1(value) {
    return !!value && typeof value === 'object';
  }
  function isPlain(value) {
    return isObject$1(value) && toString$1.call(value) === '[object Object]' && value.constructor === Object;
  }
  function computedStyle(el, prop) {
    if (!el || !prop) {
      return '';
    }
    if (typeof window.getComputedStyle === 'function') {
      var computedStyleValue;
      try {
        computedStyleValue = window.getComputedStyle(el);
      } catch (e) {
        return '';
      }
      return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : '';
    }
    return '';
  }
  var USER_AGENT = window.navigator && window.navigator.userAgent || '';
  var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
  var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;
  var IS_IPOD = /iPod/i.test(USER_AGENT);
  var IOS_VERSION = function () {
    var match = USER_AGENT.match(/OS (\d+)_/i);
    if (match && match[1]) {
      return match[1];
    }
    return null;
  }();
  var IS_ANDROID = /Android/i.test(USER_AGENT);
  var ANDROID_VERSION = function () {
    var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
    if (!match) {
      return null;
    }
    var major = match[1] && parseFloat(match[1]);
    var minor = match[2] && parseFloat(match[2]);
    if (major && minor) {
      return parseFloat(match[1] + '.' + match[2]);
    } else if (major) {
      return major;
    }
    return null;
  }();
  var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;
  var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
  var IS_EDGE = /Edg/i.test(USER_AGENT);
  var IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT));
  var CHROME_VERSION = function () {
    var match = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
    if (match && match[2]) {
      return parseFloat(match[2]);
    }
    return null;
  }();
  var IE_VERSION = function () {
    var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
    var version = result && parseFloat(result[1]);
    if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
      version = 11.0;
    }
    return version;
  }();
  var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
  var IS_WINDOWS = /Windows/i.test(USER_AGENT);
  var TOUCH_ENABLED = Boolean(isReal() && ('ontouchstart' in window || window.navigator.maxTouchPoints || window.DocumentTouch && window.document instanceof window.DocumentTouch));
  var IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);
  var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
  var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
  var IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;
  var browser = Object.freeze({
    __proto__: null,
    IS_IPOD: IS_IPOD,
    IOS_VERSION: IOS_VERSION,
    IS_ANDROID: IS_ANDROID,
    ANDROID_VERSION: ANDROID_VERSION,
    IS_NATIVE_ANDROID: IS_NATIVE_ANDROID,
    IS_FIREFOX: IS_FIREFOX,
    IS_EDGE: IS_EDGE,
    IS_CHROME: IS_CHROME,
    CHROME_VERSION: CHROME_VERSION,
    IE_VERSION: IE_VERSION,
    IS_SAFARI: IS_SAFARI,
    IS_WINDOWS: IS_WINDOWS,
    TOUCH_ENABLED: TOUCH_ENABLED,
    IS_IPAD: IS_IPAD,
    IS_IPHONE: IS_IPHONE,
    IS_IOS: IS_IOS,
    IS_ANY_SAFARI: IS_ANY_SAFARI
  });
  function isNonBlankString(str) {
    return typeof str === 'string' && Boolean(str.trim());
  }
  function throwIfWhitespace(str) {
    if (str.indexOf(' ') >= 0) {
      throw new Error('class has illegal whitespace characters');
    }
  }
  function classRegExp(className) {
    return new RegExp('(^|\\s)' + className + '($|\\s)');
  }
  function isReal() {
    return document === window.document;
  }
  function isEl(value) {
    return isObject$1(value) && value.nodeType === 1;
  }
  function isInFrame() {
    try {
      return window.parent !== window.self;
    } catch (x) {
      return true;
    }
  }
  function createQuerier(method) {
    return function (selector, context) {
      if (!isNonBlankString(selector)) {
        return document[method](null);
      }
      if (isNonBlankString(context)) {
        context = document.querySelector(context);
      }
      var ctx = isEl(context) ? context : document;
      return ctx[method] && ctx[method](selector);
    };
  }
  function createEl(tagName, properties, attributes, content) {
    if (tagName === void 0) {
      tagName = 'div';
    }
    if (properties === void 0) {
      properties = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    var el = document.createElement(tagName);
    Object.getOwnPropertyNames(properties).forEach(function (propName) {
      var val = properties[propName];
      if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {
        log$1.warn('Setting attributes in the second argument of createEl()\n' + 'has been deprecated. Use the third argument instead.\n' + ("createEl(type, properties, attributes). Attempting to set " + propName + " to " + val + "."));
        el.setAttribute(propName, val);
      } else if (propName === 'textContent') {
        textContent(el, val);
      } else if (el[propName] !== val || propName === 'tabIndex') {
        el[propName] = val;
      }
    });
    Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
      el.setAttribute(attrName, attributes[attrName]);
    });
    if (content) {
      appendContent(el, content);
    }
    return el;
  }
  function textContent(el, text) {
    if (typeof el.textContent === 'undefined') {
      el.innerText = text;
    } else {
      el.textContent = text;
    }
    return el;
  }
  function prependTo(child, parent) {
    if (parent.firstChild) {
      parent.insertBefore(child, parent.firstChild);
    } else {
      parent.appendChild(child);
    }
  }
  function hasClass(element, classToCheck) {
    throwIfWhitespace(classToCheck);
    if (element.classList) {
      return element.classList.contains(classToCheck);
    }
    return classRegExp(classToCheck).test(element.className);
  }
  function addClass(element, classToAdd) {
    if (element.classList) {
      element.classList.add(classToAdd);
    } else if (!hasClass(element, classToAdd)) {
      element.className = (element.className + ' ' + classToAdd).trim();
    }
    return element;
  }
  function removeClass(element, classToRemove) {
    if (!element) {
      log$1.warn("removeClass was called with an element that doesn't exist");
      return null;
    }
    if (element.classList) {
      element.classList.remove(classToRemove);
    } else {
      throwIfWhitespace(classToRemove);
      element.className = element.className.split(/\s+/).filter(function (c) {
        return c !== classToRemove;
      }).join(' ');
    }
    return element;
  }
  function toggleClass(element, classToToggle, predicate) {
    var has = hasClass(element, classToToggle);
    if (typeof predicate === 'function') {
      predicate = predicate(element, classToToggle);
    }
    if (typeof predicate !== 'boolean') {
      predicate = !has;
    }
    if (predicate === has) {
      return;
    }
    if (predicate) {
      addClass(element, classToToggle);
    } else {
      removeClass(element, classToToggle);
    }
    return element;
  }
  function setAttributes(el, attributes) {
    Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
      var attrValue = attributes[attrName];
      if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
        el.removeAttribute(attrName);
      } else {
        el.setAttribute(attrName, attrValue === true ? '' : attrValue);
      }
    });
  }
  function getAttributes(tag) {
    var obj = {};
    var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';
    if (tag && tag.attributes && tag.attributes.length > 0) {
      var attrs = tag.attributes;
      for (var i = attrs.length - 1; i >= 0; i--) {
        var attrName = attrs[i].name;
        var attrVal = attrs[i].value;
        if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
          attrVal = attrVal !== null ? true : false;
        }
        obj[attrName] = attrVal;
      }
    }
    return obj;
  }
  function getAttribute(el, attribute) {
    return el.getAttribute(attribute);
  }
  function setAttribute(el, attribute, value) {
    el.setAttribute(attribute, value);
  }
  function removeAttribute(el, attribute) {
    el.removeAttribute(attribute);
  }
  function blockTextSelection() {
    document.body.focus();
    document.onselectstart = function () {
      return false;
    };
  }
  function unblockTextSelection() {
    document.onselectstart = function () {
      return true;
    };
  }
  function getBoundingClientRect(el) {
    if (el && el.getBoundingClientRect && el.parentNode) {
      var rect = el.getBoundingClientRect();
      var result = {};
      ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(function (k) {
        if (rect[k] !== undefined) {
          result[k] = rect[k];
        }
      });
      if (!result.height) {
        result.height = parseFloat(computedStyle(el, 'height'));
      }
      if (!result.width) {
        result.width = parseFloat(computedStyle(el, 'width'));
      }
      return result;
    }
  }
  function findPosition(el) {
    if (!el || el && !el.offsetParent) {
      return {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      };
    }
    var width = el.offsetWidth;
    var height = el.offsetHeight;
    var left = 0;
    var top = 0;
    while (el.offsetParent && el !== document[FullscreenApi.fullscreenElement]) {
      left += el.offsetLeft;
      top += el.offsetTop;
      el = el.offsetParent;
    }
    return {
      left: left,
      top: top,
      width: width,
      height: height
    };
  }
  function getPointerPosition(el, event) {
    var translated = {
      x: 0,
      y: 0
    };
    if (IS_IOS) {
      var item = el;
      while (item && item.nodeName.toLowerCase() !== 'html') {
        var transform = computedStyle(item, 'transform');
        if (/^matrix/.test(transform)) {
          var values = transform.slice(7, -1).split(/,\s/).map(Number);
          translated.x += values[4];
          translated.y += values[5];
        } else if (/^matrix3d/.test(transform)) {
          var _values = transform.slice(9, -1).split(/,\s/).map(Number);
          translated.x += _values[12];
          translated.y += _values[13];
        }
        item = item.parentNode;
      }
    }
    var position = {};
    var boxTarget = findPosition(event.target);
    var box = findPosition(el);
    var boxW = box.width;
    var boxH = box.height;
    var offsetY = event.offsetY - (box.top - boxTarget.top);
    var offsetX = event.offsetX - (box.left - boxTarget.left);
    if (event.changedTouches) {
      offsetX = event.changedTouches[0].pageX - box.left;
      offsetY = event.changedTouches[0].pageY + box.top;
      if (IS_IOS) {
        offsetX -= translated.x;
        offsetY -= translated.y;
      }
    }
    position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));
    position.x = Math.max(0, Math.min(1, offsetX / boxW));
    return position;
  }
  function isTextNode(value) {
    return isObject$1(value) && value.nodeType === 3;
  }
  function emptyEl(el) {
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
    return el;
  }
  function normalizeContent(content) {
    if (typeof content === 'function') {
      content = content();
    }
    return (Array.isArray(content) ? content : [content]).map(function (value) {
      if (typeof value === 'function') {
        value = value();
      }
      if (isEl(value) || isTextNode(value)) {
        return value;
      }
      if (typeof value === 'string' && /\S/.test(value)) {
        return document.createTextNode(value);
      }
    }).filter(function (value) {
      return value;
    });
  }
  function appendContent(el, content) {
    normalizeContent(content).forEach(function (node) {
      return el.appendChild(node);
    });
    return el;
  }
  function insertContent(el, content) {
    return appendContent(emptyEl(el), content);
  }
  function isSingleLeftClick(event) {
    if (event.button === undefined && event.buttons === undefined) {
      return true;
    }
    if (event.button === 0 && event.buttons === undefined) {
      return true;
    }
    if (event.type === 'mouseup' && event.button === 0 && event.buttons === 0) {
      return true;
    }
    if (event.button !== 0 || event.buttons !== 1) {
      return false;
    }
    return true;
  }
  var $ = createQuerier('querySelector');
  var $$ = createQuerier('querySelectorAll');
  var Dom = Object.freeze({
    __proto__: null,
    isReal: isReal,
    isEl: isEl,
    isInFrame: isInFrame,
    createEl: createEl,
    textContent: textContent,
    prependTo: prependTo,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    toggleClass: toggleClass,
    setAttributes: setAttributes,
    getAttributes: getAttributes,
    getAttribute: getAttribute,
    setAttribute: setAttribute,
    removeAttribute: removeAttribute,
    blockTextSelection: blockTextSelection,
    unblockTextSelection: unblockTextSelection,
    getBoundingClientRect: getBoundingClientRect,
    findPosition: findPosition,
    getPointerPosition: getPointerPosition,
    isTextNode: isTextNode,
    emptyEl: emptyEl,
    normalizeContent: normalizeContent,
    appendContent: appendContent,
    insertContent: insertContent,
    isSingleLeftClick: isSingleLeftClick,
    $: $,
    $$: $$
  });
  var _windowLoaded = false;
  var videojs$1;
  var autoSetup = function autoSetup() {
    if (videojs$1.options.autoSetup === false) {
      return;
    }
    var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
    var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
    var divs = Array.prototype.slice.call(document.getElementsByTagName('video-js'));
    var mediaEls = vids.concat(audios, divs);
    if (mediaEls && mediaEls.length > 0) {
      for (var i = 0, e = mediaEls.length; i < e; i++) {
        var mediaEl = mediaEls[i];
        if (mediaEl && mediaEl.getAttribute) {
          if (mediaEl.player === undefined) {
            var options = mediaEl.getAttribute('data-setup');
            if (options !== null) {
              videojs$1(mediaEl);
            }
          }
        } else {
          autoSetupTimeout(1);
          break;
        }
      }
    } else if (!_windowLoaded) {
      autoSetupTimeout(1);
    }
  };
  function autoSetupTimeout(wait, vjs) {
    if (!isReal()) {
      return;
    }
    if (vjs) {
      videojs$1 = vjs;
    }
    window.setTimeout(autoSetup, wait);
  }
  function setWindowLoaded() {
    _windowLoaded = true;
    window.removeEventListener('load', setWindowLoaded);
  }
  if (isReal()) {
    if (document.readyState === 'complete') {
      setWindowLoaded();
    } else {
      window.addEventListener('load', setWindowLoaded);
    }
  }
  var createStyleElement = function createStyleElement(className) {
    var style = document.createElement('style');
    style.className = className;
    return style;
  };
  var setTextContent = function setTextContent(el, content) {
    if (el.styleSheet) {
      el.styleSheet.cssText = content;
    } else {
      el.textContent = content;
    }
  };
  var _initialGuid = 3;
  var _guid = _initialGuid;
  function newGUID() {
    return _guid++;
  }
  var FakeWeakMap;
  if (!window.WeakMap) {
    FakeWeakMap = function () {
      function FakeWeakMap() {
        this.vdata = 'vdata' + Math.floor(window.performance && window.performance.now() || Date.now());
        this.data = {};
      }
      var _proto = FakeWeakMap.prototype;
      _proto.set = function set(key, value) {
        var access = key[this.vdata] || newGUID();
        if (!key[this.vdata]) {
          key[this.vdata] = access;
        }
        this.data[access] = value;
        return this;
      };
      _proto.get = function get(key) {
        var access = key[this.vdata];
        if (access) {
          return this.data[access];
        }
        log$1('We have no data for this element', key);
        return undefined;
      };
      _proto.has = function has(key) {
        var access = key[this.vdata];
        return access in this.data;
      };
      _proto["delete"] = function _delete(key) {
        var access = key[this.vdata];
        if (access) {
          delete this.data[access];
          delete key[this.vdata];
        }
      };
      return FakeWeakMap;
    }();
  }
  var DomData = window.WeakMap ? new WeakMap() : new FakeWeakMap();
  function _cleanUpEvents(elem, type) {
    if (!DomData.has(elem)) {
      return;
    }
    var data = DomData.get(elem);
    if (data.handlers[type].length === 0) {
      delete data.handlers[type];
      if (elem.removeEventListener) {
        elem.removeEventListener(type, data.dispatcher, false);
      } else if (elem.detachEvent) {
        elem.detachEvent('on' + type, data.dispatcher);
      }
    }
    if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
      delete data.handlers;
      delete data.dispatcher;
      delete data.disabled;
    }
    if (Object.getOwnPropertyNames(data).length === 0) {
      DomData["delete"](elem);
    }
  }
  function _handleMultipleEvents(fn, elem, types, callback) {
    types.forEach(function (type) {
      fn(elem, type, callback);
    });
  }
  function fixEvent(event) {
    if (event.fixed_) {
      return event;
    }
    function returnTrue() {
      return true;
    }
    function returnFalse() {
      return false;
    }
    if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {
      var old = event || window.event;
      event = {};
      for (var key in old) {
        if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {
          if (!(key === 'returnValue' && old.preventDefault)) {
            event[key] = old[key];
          }
        }
      }
      if (!event.target) {
        event.target = event.srcElement || document;
      }
      if (!event.relatedTarget) {
        event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
      }
      event.preventDefault = function () {
        if (old.preventDefault) {
          old.preventDefault();
        }
        event.returnValue = false;
        old.returnValue = false;
        event.defaultPrevented = true;
      };
      event.defaultPrevented = false;
      event.stopPropagation = function () {
        if (old.stopPropagation) {
          old.stopPropagation();
        }
        event.cancelBubble = true;
        old.cancelBubble = true;
        event.isPropagationStopped = returnTrue;
      };
      event.isPropagationStopped = returnFalse;
      event.stopImmediatePropagation = function () {
        if (old.stopImmediatePropagation) {
          old.stopImmediatePropagation();
        }
        event.isImmediatePropagationStopped = returnTrue;
        event.stopPropagation();
      };
      event.isImmediatePropagationStopped = returnFalse;
      if (event.clientX !== null && event.clientX !== undefined) {
        var doc = document.documentElement;
        var body = document.body;
        event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
      }
      event.which = event.charCode || event.keyCode;
      if (event.button !== null && event.button !== undefined) {
        event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
      }
    }
    event.fixed_ = true;
    return event;
  }
  var _supportsPassive;
  var supportsPassive = function supportsPassive() {
    if (typeof _supportsPassive !== 'boolean') {
      _supportsPassive = false;
      try {
        var opts = Object.defineProperty({}, 'passive', {
          get: function get() {
            _supportsPassive = true;
          }
        });
        window.addEventListener('test', null, opts);
        window.removeEventListener('test', null, opts);
      } catch (e) {
      }
    }
    return _supportsPassive;
  };
  var passiveEvents = ['touchstart', 'touchmove'];
  function on(elem, type, fn) {
    if (Array.isArray(type)) {
      return _handleMultipleEvents(on, elem, type, fn);
    }
    if (!DomData.has(elem)) {
      DomData.set(elem, {});
    }
    var data = DomData.get(elem);
    if (!data.handlers) {
      data.handlers = {};
    }
    if (!data.handlers[type]) {
      data.handlers[type] = [];
    }
    if (!fn.guid) {
      fn.guid = newGUID();
    }
    data.handlers[type].push(fn);
    if (!data.dispatcher) {
      data.disabled = false;
      data.dispatcher = function (event, hash) {
        if (data.disabled) {
          return;
        }
        event = fixEvent(event);
        var handlers = data.handlers[event.type];
        if (handlers) {
          var handlersCopy = handlers.slice(0);
          for (var m = 0, n = handlersCopy.length; m < n; m++) {
            if (event.isImmediatePropagationStopped()) {
              break;
            } else {
              try {
                handlersCopy[m].call(elem, event, hash);
              } catch (e) {
                log$1.error(e);
              }
            }
          }
        }
      };
    }
    if (data.handlers[type].length === 1) {
      if (elem.addEventListener) {
        var options = false;
        if (supportsPassive() && passiveEvents.indexOf(type) > -1) {
          options = {
            passive: true
          };
        }
        elem.addEventListener(type, data.dispatcher, options);
      } else if (elem.attachEvent) {
        elem.attachEvent('on' + type, data.dispatcher);
      }
    }
  }
  function off(elem, type, fn) {
    if (!DomData.has(elem)) {
      return;
    }
    var data = DomData.get(elem);
    if (!data.handlers) {
      return;
    }
    if (Array.isArray(type)) {
      return _handleMultipleEvents(off, elem, type, fn);
    }
    var removeType = function removeType(el, t) {
      data.handlers[t] = [];
      _cleanUpEvents(el, t);
    };
    if (type === undefined) {
      for (var t in data.handlers) {
        if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {
          removeType(elem, t);
        }
      }
      return;
    }
    var handlers = data.handlers[type];
    if (!handlers) {
      return;
    }
    if (!fn) {
      removeType(elem, type);
      return;
    }
    if (fn.guid) {
      for (var n = 0; n < handlers.length; n++) {
        if (handlers[n].guid === fn.guid) {
          handlers.splice(n--, 1);
        }
      }
    }
    _cleanUpEvents(elem, type);
  }
  function trigger(elem, event, hash) {
    var elemData = DomData.has(elem) ? DomData.get(elem) : {};
    var parent = elem.parentNode || elem.ownerDocument;
    if (typeof event === 'string') {
      event = {
        type: event,
        target: elem
      };
    } else if (!event.target) {
      event.target = elem;
    }
    event = fixEvent(event);
    if (elemData.dispatcher) {
      elemData.dispatcher.call(elem, event, hash);
    }
    if (parent && !event.isPropagationStopped() && event.bubbles === true) {
      trigger.call(null, parent, event, hash);
    } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {
      if (!DomData.has(event.target)) {
        DomData.set(event.target, {});
      }
      var targetData = DomData.get(event.target);
      if (event.target[event.type]) {
        targetData.disabled = true;
        if (typeof event.target[event.type] === 'function') {
          event.target[event.type]();
        }
        targetData.disabled = false;
      }
    }
    return !event.defaultPrevented;
  }
  function one(elem, type, fn) {
    if (Array.isArray(type)) {
      return _handleMultipleEvents(one, elem, type, fn);
    }
    var func = function func() {
      off(elem, type, func);
      fn.apply(this, arguments);
    };
    func.guid = fn.guid = fn.guid || newGUID();
    on(elem, type, func);
  }
  function any(elem, type, fn) {
    var func = function func() {
      off(elem, type, func);
      fn.apply(this, arguments);
    };
    func.guid = fn.guid = fn.guid || newGUID();
    on(elem, type, func);
  }
  var Events = Object.freeze({
    __proto__: null,
    fixEvent: fixEvent,
    on: on,
    off: off,
    trigger: trigger,
    one: one,
    any: any
  });
  var UPDATE_REFRESH_INTERVAL = 30;
  var bind = function bind(context, fn, uid) {
    if (!fn.guid) {
      fn.guid = newGUID();
    }
    var bound = fn.bind(context);
    bound.guid = uid ? uid + '_' + fn.guid : fn.guid;
    return bound;
  };
  var throttle = function throttle(fn, wait) {
    var last = window.performance.now();
    var throttled = function throttled() {
      var now = window.performance.now();
      if (now - last >= wait) {
        fn.apply(void 0, arguments);
        last = now;
      }
    };
    return throttled;
  };
  var debounce = function debounce(func, wait, immediate, context) {
    if (context === void 0) {
      context = window;
    }
    var timeout;
    var cancel = function cancel() {
      context.clearTimeout(timeout);
      timeout = null;
    };
    var debounced = function debounced() {
      var self = this;
      var args = arguments;
      var _later = function later() {
        timeout = null;
        _later = null;
        if (!immediate) {
          func.apply(self, args);
        }
      };
      if (!timeout && immediate) {
        func.apply(self, args);
      }
      context.clearTimeout(timeout);
      timeout = context.setTimeout(_later, wait);
    };
    debounced.cancel = cancel;
    return debounced;
  };
  var EventTarget$2 = function EventTarget() {};
  EventTarget$2.prototype.allowedEvents_ = {};
  EventTarget$2.prototype.on = function (type, fn) {
    var ael = this.addEventListener;
    this.addEventListener = function () {};
    on(this, type, fn);
    this.addEventListener = ael;
  };
  EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;
  EventTarget$2.prototype.off = function (type, fn) {
    off(this, type, fn);
  };
  EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;
  EventTarget$2.prototype.one = function (type, fn) {
    var ael = this.addEventListener;
    this.addEventListener = function () {};
    one(this, type, fn);
    this.addEventListener = ael;
  };
  EventTarget$2.prototype.any = function (type, fn) {
    var ael = this.addEventListener;
    this.addEventListener = function () {};
    any(this, type, fn);
    this.addEventListener = ael;
  };
  EventTarget$2.prototype.trigger = function (event) {
    var type = event.type || event;
    if (typeof event === 'string') {
      event = {
        type: type
      };
    }
    event = fixEvent(event);
    if (this.allowedEvents_[type] && this['on' + type]) {
      this['on' + type](event);
    }
    trigger(this, event);
  };
  EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;
  var EVENT_MAP;
  EventTarget$2.prototype.queueTrigger = function (event) {
    var _this = this;
    if (!EVENT_MAP) {
      EVENT_MAP = new Map();
    }
    var type = event.type || event;
    var map = EVENT_MAP.get(this);
    if (!map) {
      map = new Map();
      EVENT_MAP.set(this, map);
    }
    var oldTimeout = map.get(type);
    map["delete"](type);
    window.clearTimeout(oldTimeout);
    var timeout = window.setTimeout(function () {
      if (map.size === 0) {
        map = null;
        EVENT_MAP["delete"](_this);
      }
      _this.trigger(event);
    }, 0);
    map.set(type, timeout);
  };
  var objName = function objName(obj) {
    if (typeof obj.name === 'function') {
      return obj.name();
    }
    if (typeof obj.name === 'string') {
      return obj.name;
    }
    if (obj.name_) {
      return obj.name_;
    }
    if (obj.constructor && obj.constructor.name) {
      return obj.constructor.name;
    }
    return typeof obj;
  };
  var isEvented = function isEvented(object) {
    return object instanceof EventTarget$2 || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(function (k) {
      return typeof object[k] === 'function';
    });
  };
  var addEventedCallback = function addEventedCallback(target, callback) {
    if (isEvented(target)) {
      callback();
    } else {
      if (!target.eventedCallbacks) {
        target.eventedCallbacks = [];
      }
      target.eventedCallbacks.push(callback);
    }
  };
  var isValidEventType = function isValidEventType(type) {
    return (
      typeof type === 'string' && /\S/.test(type) || Array.isArray(type) && !!type.length
    );
  };
  var validateTarget = function validateTarget(target, obj, fnName) {
    if (!target || !target.nodeName && !isEvented(target)) {
      throw new Error("Invalid target for " + objName(obj) + "#" + fnName + "; must be a DOM node or evented object.");
    }
  };
  var validateEventType = function validateEventType(type, obj, fnName) {
    if (!isValidEventType(type)) {
      throw new Error("Invalid event type for " + objName(obj) + "#" + fnName + "; must be a non-empty string or array.");
    }
  };
  var validateListener = function validateListener(listener, obj, fnName) {
    if (typeof listener !== 'function') {
      throw new Error("Invalid listener for " + objName(obj) + "#" + fnName + "; must be a function.");
    }
  };
  var normalizeListenArgs = function normalizeListenArgs(self, args, fnName) {
    var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;
    var target;
    var type;
    var listener;
    if (isTargetingSelf) {
      target = self.eventBusEl_;
      if (args.length >= 3) {
        args.shift();
      }
      type = args[0];
      listener = args[1];
    } else {
      target = args[0];
      type = args[1];
      listener = args[2];
    }
    validateTarget(target, self, fnName);
    validateEventType(type, self, fnName);
    validateListener(listener, self, fnName);
    listener = bind(self, listener);
    return {
      isTargetingSelf: isTargetingSelf,
      target: target,
      type: type,
      listener: listener
    };
  };
  var listen = function listen(target, method, type, listener) {
    validateTarget(target, target, method);
    if (target.nodeName) {
      Events[method](target, type, listener);
    } else {
      target[method](type, listener);
    }
  };
  var EventedMixin = {
    on: function on() {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var _normalizeListenArgs = normalizeListenArgs(this, args, 'on'),
          isTargetingSelf = _normalizeListenArgs.isTargetingSelf,
          target = _normalizeListenArgs.target,
          type = _normalizeListenArgs.type,
          listener = _normalizeListenArgs.listener;
      listen(target, 'on', type, listener);
      if (!isTargetingSelf) {
        var removeListenerOnDispose = function removeListenerOnDispose() {
          return _this.off(target, type, listener);
        };
        removeListenerOnDispose.guid = listener.guid;
        var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose() {
          return _this.off('dispose', removeListenerOnDispose);
        };
        removeRemoverOnTargetDispose.guid = listener.guid;
        listen(this, 'on', 'dispose', removeListenerOnDispose);
        listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);
      }
    },
    one: function one() {
      var _this2 = this;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var _normalizeListenArgs2 = normalizeListenArgs(this, args, 'one'),
          isTargetingSelf = _normalizeListenArgs2.isTargetingSelf,
          target = _normalizeListenArgs2.target,
          type = _normalizeListenArgs2.type,
          listener = _normalizeListenArgs2.listener;
      if (isTargetingSelf) {
        listen(target, 'one', type, listener);
      } else {
        var wrapper = function wrapper() {
          _this2.off(target, type, wrapper);
          for (var _len3 = arguments.length, largs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            largs[_key3] = arguments[_key3];
          }
          listener.apply(null, largs);
        };
        wrapper.guid = listener.guid;
        listen(target, 'one', type, wrapper);
      }
    },
    any: function any() {
      var _this3 = this;
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      var _normalizeListenArgs3 = normalizeListenArgs(this, args, 'any'),
          isTargetingSelf = _normalizeListenArgs3.isTargetingSelf,
          target = _normalizeListenArgs3.target,
          type = _normalizeListenArgs3.type,
          listener = _normalizeListenArgs3.listener;
      if (isTargetingSelf) {
        listen(target, 'any', type, listener);
      } else {
        var wrapper = function wrapper() {
          _this3.off(target, type, wrapper);
          for (var _len5 = arguments.length, largs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            largs[_key5] = arguments[_key5];
          }
          listener.apply(null, largs);
        };
        wrapper.guid = listener.guid;
        listen(target, 'any', type, wrapper);
      }
    },
    off: function off$1(targetOrType, typeOrListener, listener) {
      if (!targetOrType || isValidEventType(targetOrType)) {
        off(this.eventBusEl_, targetOrType, typeOrListener);
      } else {
        var target = targetOrType;
        var type = typeOrListener;
        validateTarget(target, this, 'off');
        validateEventType(type, this, 'off');
        validateListener(listener, this, 'off');
        listener = bind(this, listener);
        this.off('dispose', listener);
        if (target.nodeName) {
          off(target, type, listener);
          off(target, 'dispose', listener);
        } else if (isEvented(target)) {
          target.off(type, listener);
          target.off('dispose', listener);
        }
      }
    },
    trigger: function trigger$1(event, hash) {
      validateTarget(this.eventBusEl_, this, 'trigger');
      var type = event && typeof event !== 'string' ? event.type : event;
      if (!isValidEventType(type)) {
        var error = "Invalid event type for " + objName(this) + "#trigger; " + 'must be a non-empty string or object with a type key that has a non-empty value.';
        if (event) {
          (this.log || log$1).error(error);
        } else {
          throw new Error(error);
        }
      }
      return trigger(this.eventBusEl_, event, hash);
    }
  };
  function evented(target, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options,
        eventBusKey = _options.eventBusKey;
    if (eventBusKey) {
      if (!target[eventBusKey].nodeName) {
        throw new Error("The eventBusKey \"" + eventBusKey + "\" does not refer to an element.");
      }
      target.eventBusEl_ = target[eventBusKey];
    } else {
      target.eventBusEl_ = createEl('span', {
        className: 'vjs-event-bus'
      });
    }
    assign(target, EventedMixin);
    if (target.eventedCallbacks) {
      target.eventedCallbacks.forEach(function (callback) {
        callback();
      });
    }
    target.on('dispose', function () {
      target.off();
      [target, target.el_, target.eventBusEl_].forEach(function (val) {
        if (val && DomData.has(val)) {
          DomData["delete"](val);
        }
      });
      window.setTimeout(function () {
        target.eventBusEl_ = null;
      }, 0);
    });
    return target;
  }
  var StatefulMixin = {
    state: {},
    setState: function setState(stateUpdates) {
      var _this = this;
      if (typeof stateUpdates === 'function') {
        stateUpdates = stateUpdates();
      }
      var changes;
      each(stateUpdates, function (value, key) {
        if (_this.state[key] !== value) {
          changes = changes || {};
          changes[key] = {
            from: _this.state[key],
            to: value
          };
        }
        _this.state[key] = value;
      });
      if (changes && isEvented(this)) {
        this.trigger({
          changes: changes,
          type: 'statechanged'
        });
      }
      return changes;
    }
  };
  function stateful(target, defaultState) {
    assign(target, StatefulMixin);
    target.state = assign({}, target.state, defaultState);
    if (typeof target.handleStateChanged === 'function' && isEvented(target)) {
      target.on('statechanged', target.handleStateChanged);
    }
    return target;
  }
  var toLowerCase = function toLowerCase(string) {
    if (typeof string !== 'string') {
      return string;
    }
    return string.replace(/./, function (w) {
      return w.toLowerCase();
    });
  };
  var toTitleCase$1 = function toTitleCase(string) {
    if (typeof string !== 'string') {
      return string;
    }
    return string.replace(/./, function (w) {
      return w.toUpperCase();
    });
  };
  var titleCaseEquals = function titleCaseEquals(str1, str2) {
    return toTitleCase$1(str1) === toTitleCase$1(str2);
  };
  function mergeOptions$3() {
    var result = {};
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    sources.forEach(function (source) {
      if (!source) {
        return;
      }
      each(source, function (value, key) {
        if (!isPlain(value)) {
          result[key] = value;
          return;
        }
        if (!isPlain(result[key])) {
          result[key] = {};
        }
        result[key] = mergeOptions$3(result[key], value);
      });
    });
    return result;
  }
  var MapSham = function () {
    function MapSham() {
      this.map_ = {};
    }
    var _proto = MapSham.prototype;
    _proto.has = function has(key) {
      return key in this.map_;
    };
    _proto["delete"] = function _delete(key) {
      var has = this.has(key);
      delete this.map_[key];
      return has;
    };
    _proto.set = function set(key, value) {
      this.map_[key] = value;
      return this;
    };
    _proto.forEach = function forEach(callback, thisArg) {
      for (var key in this.map_) {
        callback.call(thisArg, this.map_[key], key, this);
      }
    };
    return MapSham;
  }();
  var Map$1 = window.Map ? window.Map : MapSham;
  var SetSham = function () {
    function SetSham() {
      this.set_ = {};
    }
    var _proto = SetSham.prototype;
    _proto.has = function has(key) {
      return key in this.set_;
    };
    _proto["delete"] = function _delete(key) {
      var has = this.has(key);
      delete this.set_[key];
      return has;
    };
    _proto.add = function add(key) {
      this.set_[key] = 1;
      return this;
    };
    _proto.forEach = function forEach(callback, thisArg) {
      for (var key in this.set_) {
        callback.call(thisArg, key, key, this);
      }
    };
    return SetSham;
  }();
  var Set = window.Set ? window.Set : SetSham;
  var keycode = createCommonjsModule(function (module, exports) {
    function keyCode(searchInput) {
      if (searchInput && 'object' === typeof searchInput) {
        var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
        if (hasKeyCode) searchInput = hasKeyCode;
      }
      if ('number' === typeof searchInput) return names[searchInput];
      var search = String(searchInput);
      var foundNamedKey = codes[search.toLowerCase()];
      if (foundNamedKey) return foundNamedKey;
      var foundNamedKey = aliases[search.toLowerCase()];
      if (foundNamedKey) return foundNamedKey;
      if (search.length === 1) return search.charCodeAt(0);
      return undefined;
    }
    keyCode.isEventKey = function isEventKey(event, nameOrCode) {
      if (event && 'object' === typeof event) {
        var keyCode = event.which || event.keyCode || event.charCode;
        if (keyCode === null || keyCode === undefined) {
          return false;
        }
        if (typeof nameOrCode === 'string') {
          var foundNamedKey = codes[nameOrCode.toLowerCase()];
          if (foundNamedKey) {
            return foundNamedKey === keyCode;
          }
          var foundNamedKey = aliases[nameOrCode.toLowerCase()];
          if (foundNamedKey) {
            return foundNamedKey === keyCode;
          }
        } else if (typeof nameOrCode === 'number') {
          return nameOrCode === keyCode;
        }
        return false;
      }
    };
    exports = module.exports = keyCode;
    var codes = exports.code = exports.codes = {
      'backspace': 8,
      'tab': 9,
      'enter': 13,
      'shift': 16,
      'ctrl': 17,
      'alt': 18,
      'pause/break': 19,
      'caps lock': 20,
      'esc': 27,
      'space': 32,
      'page up': 33,
      'page down': 34,
      'end': 35,
      'home': 36,
      'left': 37,
      'up': 38,
      'right': 39,
      'down': 40,
      'insert': 45,
      'delete': 46,
      'command': 91,
      'left command': 91,
      'right command': 93,
      'numpad *': 106,
      'numpad +': 107,
      'numpad -': 109,
      'numpad .': 110,
      'numpad /': 111,
      'num lock': 144,
      'scroll lock': 145,
      'my computer': 182,
      'my calculator': 183,
      ';': 186,
      '=': 187,
      ',': 188,
      '-': 189,
      '.': 190,
      '/': 191,
      '`': 192,
      '[': 219,
      '\\': 220,
      ']': 221,
      "'": 222
    };
    var aliases = exports.aliases = {
      'windows': 91,
      '': 16,
      '': 18,
      '': 17,
      '': 91,
      'ctl': 17,
      'control': 17,
      'option': 18,
      'pause': 19,
      'break': 19,
      'caps': 20,
      'return': 13,
      'escape': 27,
      'spc': 32,
      'spacebar': 32,
      'pgup': 33,
      'pgdn': 34,
      'ins': 45,
      'del': 46,
      'cmd': 91
    };
    /*!
     * Programatically add the following
     */
    for (i = 97; i < 123; i++) {
      codes[String.fromCharCode(i)] = i - 32;
    }
    for (var i = 48; i < 58; i++) {
      codes[i - 48] = i;
    }
    for (i = 1; i < 13; i++) {
      codes['f' + i] = i + 111;
    }
    for (i = 0; i < 10; i++) {
      codes['numpad ' + i] = i + 96;
    }
    var names = exports.names = exports.title = {};
    for (i in codes) {
      names[codes[i]] = i;
    }
    for (var alias in aliases) {
      codes[alias] = aliases[alias];
    }
  });
  keycode.code;
  keycode.codes;
  keycode.aliases;
  keycode.names;
  keycode.title;
  var Component$1 = function () {
    function Component(player, options, ready) {
      if (!player && this.play) {
        this.player_ = player = this;
      } else {
        this.player_ = player;
      }
      this.isDisposed_ = false;
      this.parentComponent_ = null;
      this.options_ = mergeOptions$3({}, this.options_);
      options = this.options_ = mergeOptions$3(this.options_, options);
      this.id_ = options.id || options.el && options.el.id;
      if (!this.id_) {
        var id = player && player.id && player.id() || 'no_player';
        this.id_ = id + "_component_" + newGUID();
      }
      this.name_ = options.name || null;
      if (options.el) {
        this.el_ = options.el;
      } else if (options.createEl !== false) {
        this.el_ = this.createEl();
      }
      if (options.evented !== false) {
        evented(this, {
          eventBusKey: this.el_ ? 'el_' : null
        });
        this.handleLanguagechange = this.handleLanguagechange.bind(this);
        this.on(this.player_, 'languagechange', this.handleLanguagechange);
      }
      stateful(this, this.constructor.defaultState);
      this.children_ = [];
      this.childIndex_ = {};
      this.childNameIndex_ = {};
      this.setTimeoutIds_ = new Set();
      this.setIntervalIds_ = new Set();
      this.rafIds_ = new Set();
      this.namedRafs_ = new Map$1();
      this.clearingTimersOnDispose_ = false;
      if (options.initChildren !== false) {
        this.initChildren();
      }
      this.ready(ready);
      if (options.reportTouchActivity !== false) {
        this.enableTouchActivity();
      }
    }
    var _proto = Component.prototype;
    _proto.dispose = function dispose() {
      if (this.isDisposed_) {
        return;
      }
      if (this.readyQueue_) {
        this.readyQueue_.length = 0;
      }
      this.trigger({
        type: 'dispose',
        bubbles: false
      });
      this.isDisposed_ = true;
      if (this.children_) {
        for (var i = this.children_.length - 1; i >= 0; i--) {
          if (this.children_[i].dispose) {
            this.children_[i].dispose();
          }
        }
      }
      this.children_ = null;
      this.childIndex_ = null;
      this.childNameIndex_ = null;
      this.parentComponent_ = null;
      if (this.el_) {
        if (this.el_.parentNode) {
          this.el_.parentNode.removeChild(this.el_);
        }
        this.el_ = null;
      }
      this.player_ = null;
    }
    ;
    _proto.isDisposed = function isDisposed() {
      return Boolean(this.isDisposed_);
    }
    ;
    _proto.player = function player() {
      return this.player_;
    }
    ;
    _proto.options = function options(obj) {
      if (!obj) {
        return this.options_;
      }
      this.options_ = mergeOptions$3(this.options_, obj);
      return this.options_;
    }
    ;
    _proto.el = function el() {
      return this.el_;
    }
    ;
    _proto.createEl = function createEl$1(tagName, properties, attributes) {
      return createEl(tagName, properties, attributes);
    }
    ;
    _proto.localize = function localize(string, tokens, defaultValue) {
      if (defaultValue === void 0) {
        defaultValue = string;
      }
      var code = this.player_.language && this.player_.language();
      var languages = this.player_.languages && this.player_.languages();
      var language = languages && languages[code];
      var primaryCode = code && code.split('-')[0];
      var primaryLang = languages && languages[primaryCode];
      var localizedString = defaultValue;
      if (language && language[string]) {
        localizedString = language[string];
      } else if (primaryLang && primaryLang[string]) {
        localizedString = primaryLang[string];
      }
      if (tokens) {
        localizedString = localizedString.replace(/\{(\d+)\}/g, function (match, index) {
          var value = tokens[index - 1];
          var ret = value;
          if (typeof value === 'undefined') {
            ret = match;
          }
          return ret;
        });
      }
      return localizedString;
    }
    ;
    _proto.handleLanguagechange = function handleLanguagechange() {}
    ;
    _proto.contentEl = function contentEl() {
      return this.contentEl_ || this.el_;
    }
    ;
    _proto.id = function id() {
      return this.id_;
    }
    ;
    _proto.name = function name() {
      return this.name_;
    }
    ;
    _proto.children = function children() {
      return this.children_;
    }
    ;
    _proto.getChildById = function getChildById(id) {
      return this.childIndex_[id];
    }
    ;
    _proto.getChild = function getChild(name) {
      if (!name) {
        return;
      }
      return this.childNameIndex_[name];
    }
    ;
    _proto.getDescendant = function getDescendant() {
      for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {
        names[_key] = arguments[_key];
      }
      names = names.reduce(function (acc, n) {
        return acc.concat(n);
      }, []);
      var currentChild = this;
      for (var i = 0; i < names.length; i++) {
        currentChild = currentChild.getChild(names[i]);
        if (!currentChild || !currentChild.getChild) {
          return;
        }
      }
      return currentChild;
    }
    ;
    _proto.addChild = function addChild(child, options, index) {
      if (options === void 0) {
        options = {};
      }
      if (index === void 0) {
        index = this.children_.length;
      }
      var component;
      var componentName;
      if (typeof child === 'string') {
        componentName = toTitleCase$1(child);
        var componentClassName = options.componentClass || componentName;
        options.name = componentName;
        var ComponentClass = Component.getComponent(componentClassName);
        if (!ComponentClass) {
          throw new Error("Component " + componentClassName + " does not exist");
        }
        if (typeof ComponentClass !== 'function') {
          return null;
        }
        component = new ComponentClass(this.player_ || this, options);
      } else {
        component = child;
      }
      if (component.parentComponent_) {
        component.parentComponent_.removeChild(component);
      }
      this.children_.splice(index, 0, component);
      component.parentComponent_ = this;
      if (typeof component.id === 'function') {
        this.childIndex_[component.id()] = component;
      }
      componentName = componentName || component.name && toTitleCase$1(component.name());
      if (componentName) {
        this.childNameIndex_[componentName] = component;
        this.childNameIndex_[toLowerCase(componentName)] = component;
      }
      if (typeof component.el === 'function' && component.el()) {
        var refNode = null;
        if (this.children_[index + 1]) {
          if (this.children_[index + 1].el_) {
            refNode = this.children_[index + 1].el_;
          } else if (isEl(this.children_[index + 1])) {
            refNode = this.children_[index + 1];
          }
        }
        this.contentEl().insertBefore(component.el(), refNode);
      }
      return component;
    }
    ;
    _proto.removeChild = function removeChild(component) {
      if (typeof component === 'string') {
        component = this.getChild(component);
      }
      if (!component || !this.children_) {
        return;
      }
      var childFound = false;
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i] === component) {
          childFound = true;
          this.children_.splice(i, 1);
          break;
        }
      }
      if (!childFound) {
        return;
      }
      component.parentComponent_ = null;
      this.childIndex_[component.id()] = null;
      this.childNameIndex_[toTitleCase$1(component.name())] = null;
      this.childNameIndex_[toLowerCase(component.name())] = null;
      var compEl = component.el();
      if (compEl && compEl.parentNode === this.contentEl()) {
        this.contentEl().removeChild(component.el());
      }
    }
    ;
    _proto.initChildren = function initChildren() {
      var _this = this;
      var children = this.options_.children;
      if (children) {
        var parentOptions = this.options_;
        var handleAdd = function handleAdd(child) {
          var name = child.name;
          var opts = child.opts;
          if (parentOptions[name] !== undefined) {
            opts = parentOptions[name];
          }
          if (opts === false) {
            return;
          }
          if (opts === true) {
            opts = {};
          }
          opts.playerOptions = _this.options_.playerOptions;
          var newChild = _this.addChild(name, opts);
          if (newChild) {
            _this[name] = newChild;
          }
        };
        var workingChildren;
        var Tech = Component.getComponent('Tech');
        if (Array.isArray(children)) {
          workingChildren = children;
        } else {
          workingChildren = Object.keys(children);
        }
        workingChildren
        .concat(Object.keys(this.options_).filter(function (child) {
          return !workingChildren.some(function (wchild) {
            if (typeof wchild === 'string') {
              return child === wchild;
            }
            return child === wchild.name;
          });
        })).map(function (child) {
          var name;
          var opts;
          if (typeof child === 'string') {
            name = child;
            opts = children[name] || _this.options_[name] || {};
          } else {
            name = child.name;
            opts = child;
          }
          return {
            name: name,
            opts: opts
          };
        }).filter(function (child) {
          var c = Component.getComponent(child.opts.componentClass || toTitleCase$1(child.name));
          return c && !Tech.isTech(c);
        }).forEach(handleAdd);
      }
    }
    ;
    _proto.buildCSSClass = function buildCSSClass() {
      return '';
    }
    ;
    _proto.ready = function ready(fn, sync) {
      if (sync === void 0) {
        sync = false;
      }
      if (!fn) {
        return;
      }
      if (!this.isReady_) {
        this.readyQueue_ = this.readyQueue_ || [];
        this.readyQueue_.push(fn);
        return;
      }
      if (sync) {
        fn.call(this);
      } else {
        this.setTimeout(fn, 1);
      }
    }
    ;
    _proto.triggerReady = function triggerReady() {
      this.isReady_ = true;
      this.setTimeout(function () {
        var readyQueue = this.readyQueue_;
        this.readyQueue_ = [];
        if (readyQueue && readyQueue.length > 0) {
          readyQueue.forEach(function (fn) {
            fn.call(this);
          }, this);
        }
        this.trigger('ready');
      }, 1);
    }
    ;
    _proto.$ = function $$1(selector, context) {
      return $(selector, context || this.contentEl());
    }
    ;
    _proto.$$ = function $$$1(selector, context) {
      return $$(selector, context || this.contentEl());
    }
    ;
    _proto.hasClass = function hasClass$1(classToCheck) {
      return hasClass(this.el_, classToCheck);
    }
    ;
    _proto.addClass = function addClass$1(classToAdd) {
      addClass(this.el_, classToAdd);
    }
    ;
    _proto.removeClass = function removeClass$1(classToRemove) {
      removeClass(this.el_, classToRemove);
    }
    ;
    _proto.toggleClass = function toggleClass$1(classToToggle, predicate) {
      toggleClass(this.el_, classToToggle, predicate);
    }
    ;
    _proto.show = function show() {
      this.removeClass('vjs-hidden');
    }
    ;
    _proto.hide = function hide() {
      this.addClass('vjs-hidden');
    }
    ;
    _proto.lockShowing = function lockShowing() {
      this.addClass('vjs-lock-showing');
    }
    ;
    _proto.unlockShowing = function unlockShowing() {
      this.removeClass('vjs-lock-showing');
    }
    ;
    _proto.getAttribute = function getAttribute$1(attribute) {
      return getAttribute(this.el_, attribute);
    }
    ;
    _proto.setAttribute = function setAttribute$1(attribute, value) {
      setAttribute(this.el_, attribute, value);
    }
    ;
    _proto.removeAttribute = function removeAttribute$1(attribute) {
      removeAttribute(this.el_, attribute);
    }
    ;
    _proto.width = function width(num, skipListeners) {
      return this.dimension('width', num, skipListeners);
    }
    ;
    _proto.height = function height(num, skipListeners) {
      return this.dimension('height', num, skipListeners);
    }
    ;
    _proto.dimensions = function dimensions(width, height) {
      this.width(width, true);
      this.height(height);
    }
    ;
    _proto.dimension = function dimension(widthOrHeight, num, skipListeners) {
      if (num !== undefined) {
        if (num === null || num !== num) {
          num = 0;
        }
        if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
          this.el_.style[widthOrHeight] = num;
        } else if (num === 'auto') {
          this.el_.style[widthOrHeight] = '';
        } else {
          this.el_.style[widthOrHeight] = num + 'px';
        }
        if (!skipListeners) {
          this.trigger('componentresize');
        }
        return;
      }
      if (!this.el_) {
        return 0;
      }
      var val = this.el_.style[widthOrHeight];
      var pxIndex = val.indexOf('px');
      if (pxIndex !== -1) {
        return parseInt(val.slice(0, pxIndex), 10);
      }
      return parseInt(this.el_['offset' + toTitleCase$1(widthOrHeight)], 10);
    }
    ;
    _proto.currentDimension = function currentDimension(widthOrHeight) {
      var computedWidthOrHeight = 0;
      if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {
        throw new Error('currentDimension only accepts width or height value');
      }
      computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);
      computedWidthOrHeight = parseFloat(computedWidthOrHeight);
      if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {
        var rule = "offset" + toTitleCase$1(widthOrHeight);
        computedWidthOrHeight = this.el_[rule];
      }
      return computedWidthOrHeight;
    }
    ;
    _proto.currentDimensions = function currentDimensions() {
      return {
        width: this.currentDimension('width'),
        height: this.currentDimension('height')
      };
    }
    ;
    _proto.currentWidth = function currentWidth() {
      return this.currentDimension('width');
    }
    ;
    _proto.currentHeight = function currentHeight() {
      return this.currentDimension('height');
    }
    ;
    _proto.focus = function focus() {
      this.el_.focus();
    }
    ;
    _proto.blur = function blur() {
      this.el_.blur();
    }
    ;
    _proto.handleKeyDown = function handleKeyDown(event) {
      if (this.player_) {
        if (!keycode.isEventKey(event, 'Tab')) {
          event.stopPropagation();
        }
        this.player_.handleKeyDown(event);
      }
    }
    ;
    _proto.handleKeyPress = function handleKeyPress(event) {
      this.handleKeyDown(event);
    }
    ;
    _proto.emitTapEvents = function emitTapEvents() {
      var touchStart = 0;
      var firstTouch = null;
      var tapMovementThreshold = 10;
      var touchTimeThreshold = 200;
      var couldBeTap;
      this.on('touchstart', function (event) {
        if (event.touches.length === 1) {
          firstTouch = {
            pageX: event.touches[0].pageX,
            pageY: event.touches[0].pageY
          };
          touchStart = window.performance.now();
          couldBeTap = true;
        }
      });
      this.on('touchmove', function (event) {
        if (event.touches.length > 1) {
          couldBeTap = false;
        } else if (firstTouch) {
          var xdiff = event.touches[0].pageX - firstTouch.pageX;
          var ydiff = event.touches[0].pageY - firstTouch.pageY;
          var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
          if (touchDistance > tapMovementThreshold) {
            couldBeTap = false;
          }
        }
      });
      var noTap = function noTap() {
        couldBeTap = false;
      };
      this.on('touchleave', noTap);
      this.on('touchcancel', noTap);
      this.on('touchend', function (event) {
        firstTouch = null;
        if (couldBeTap === true) {
          var touchTime = window.performance.now() - touchStart;
          if (touchTime < touchTimeThreshold) {
            event.preventDefault();
            this.trigger('tap');
          }
        }
      });
    }
    ;
    _proto.enableTouchActivity = function enableTouchActivity() {
      if (!this.player() || !this.player().reportUserActivity) {
        return;
      }
      var report = bind(this.player(), this.player().reportUserActivity);
      var touchHolding;
      this.on('touchstart', function () {
        report();
        this.clearInterval(touchHolding);
        touchHolding = this.setInterval(report, 250);
      });
      var touchEnd = function touchEnd(event) {
        report();
        this.clearInterval(touchHolding);
      };
      this.on('touchmove', report);
      this.on('touchend', touchEnd);
      this.on('touchcancel', touchEnd);
    }
    ;
    _proto.setTimeout = function setTimeout(fn, timeout) {
      var _this2 = this;
      var timeoutId;
      fn = bind(this, fn);
      this.clearTimersOnDispose_();
      timeoutId = window.setTimeout(function () {
        if (_this2.setTimeoutIds_.has(timeoutId)) {
          _this2.setTimeoutIds_["delete"](timeoutId);
        }
        fn();
      }, timeout);
      this.setTimeoutIds_.add(timeoutId);
      return timeoutId;
    }
    ;
    _proto.clearTimeout = function clearTimeout(timeoutId) {
      if (this.setTimeoutIds_.has(timeoutId)) {
        this.setTimeoutIds_["delete"](timeoutId);
        window.clearTimeout(timeoutId);
      }
      return timeoutId;
    }
    ;
    _proto.setInterval = function setInterval(fn, interval) {
      fn = bind(this, fn);
      this.clearTimersOnDispose_();
      var intervalId = window.setInterval(fn, interval);
      this.setIntervalIds_.add(intervalId);
      return intervalId;
    }
    ;
    _proto.clearInterval = function clearInterval(intervalId) {
      if (this.setIntervalIds_.has(intervalId)) {
        this.setIntervalIds_["delete"](intervalId);
        window.clearInterval(intervalId);
      }
      return intervalId;
    }
    ;
    _proto.requestAnimationFrame = function requestAnimationFrame(fn) {
      var _this3 = this;
      if (!this.supportsRaf_) {
        return this.setTimeout(fn, 1000 / 60);
      }
      this.clearTimersOnDispose_();
      var id;
      fn = bind(this, fn);
      id = window.requestAnimationFrame(function () {
        if (_this3.rafIds_.has(id)) {
          _this3.rafIds_["delete"](id);
        }
        fn();
      });
      this.rafIds_.add(id);
      return id;
    }
    ;
    _proto.requestNamedAnimationFrame = function requestNamedAnimationFrame(name, fn) {
      var _this4 = this;
      if (this.namedRafs_.has(name)) {
        return;
      }
      this.clearTimersOnDispose_();
      fn = bind(this, fn);
      var id = this.requestAnimationFrame(function () {
        fn();
        if (_this4.namedRafs_.has(name)) {
          _this4.namedRafs_["delete"](name);
        }
      });
      this.namedRafs_.set(name, id);
      return name;
    }
    ;
    _proto.cancelNamedAnimationFrame = function cancelNamedAnimationFrame(name) {
      if (!this.namedRafs_.has(name)) {
        return;
      }
      this.cancelAnimationFrame(this.namedRafs_.get(name));
      this.namedRafs_["delete"](name);
    }
    ;
    _proto.cancelAnimationFrame = function cancelAnimationFrame(id) {
      if (!this.supportsRaf_) {
        return this.clearTimeout(id);
      }
      if (this.rafIds_.has(id)) {
        this.rafIds_["delete"](id);
        window.cancelAnimationFrame(id);
      }
      return id;
    }
    ;
    _proto.clearTimersOnDispose_ = function clearTimersOnDispose_() {
      var _this5 = this;
      if (this.clearingTimersOnDispose_) {
        return;
      }
      this.clearingTimersOnDispose_ = true;
      this.one('dispose', function () {
        [['namedRafs_', 'cancelNamedAnimationFrame'], ['rafIds_', 'cancelAnimationFrame'], ['setTimeoutIds_', 'clearTimeout'], ['setIntervalIds_', 'clearInterval']].forEach(function (_ref) {
          var idName = _ref[0],
              cancelName = _ref[1];
          _this5[idName].forEach(function (val, key) {
            return _this5[cancelName](key);
          });
        });
        _this5.clearingTimersOnDispose_ = false;
      });
    }
    ;
    Component.registerComponent = function registerComponent(name, ComponentToRegister) {
      if (typeof name !== 'string' || !name) {
        throw new Error("Illegal component name, \"" + name + "\"; must be a non-empty string.");
      }
      var Tech = Component.getComponent('Tech');
      var isTech = Tech && Tech.isTech(ComponentToRegister);
      var isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);
      if (isTech || !isComp) {
        var reason;
        if (isTech) {
          reason = 'techs must be registered using Tech.registerTech()';
        } else {
          reason = 'must be a Component subclass';
        }
        throw new Error("Illegal component, \"" + name + "\"; " + reason + ".");
      }
      name = toTitleCase$1(name);
      if (!Component.components_) {
        Component.components_ = {};
      }
      var Player = Component.getComponent('Player');
      if (name === 'Player' && Player && Player.players) {
        var players = Player.players;
        var playerNames = Object.keys(players);
        if (players && playerNames.length > 0 && playerNames.map(function (pname) {
          return players[pname];
        }).every(Boolean)) {
          throw new Error('Can not register Player component after player has been created.');
        }
      }
      Component.components_[name] = ComponentToRegister;
      Component.components_[toLowerCase(name)] = ComponentToRegister;
      return ComponentToRegister;
    }
    ;
    Component.getComponent = function getComponent(name) {
      if (!name || !Component.components_) {
        return;
      }
      return Component.components_[name];
    };
    return Component;
  }();
  Component$1.prototype.supportsRaf_ = typeof window.requestAnimationFrame === 'function' && typeof window.cancelAnimationFrame === 'function';
  Component$1.registerComponent('Component', Component$1);
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  var assertThisInitialized = _assertThisInitialized;
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var inheritsLoose = _inheritsLoose;
  function rangeCheck(fnName, index, maxIndex) {
    if (typeof index !== 'number' || index < 0 || index > maxIndex) {
      throw new Error("Failed to execute '" + fnName + "' on 'TimeRanges': The index provided (" + index + ") is non-numeric or out of bounds (0-" + maxIndex + ").");
    }
  }
  function getRange(fnName, valueIndex, ranges, rangeIndex) {
    rangeCheck(fnName, rangeIndex, ranges.length - 1);
    return ranges[rangeIndex][valueIndex];
  }
  function createTimeRangesObj(ranges) {
    var timeRangesObj;
    if (ranges === undefined || ranges.length === 0) {
      timeRangesObj = {
        length: 0,
        start: function start() {
          throw new Error('This TimeRanges object is empty');
        },
        end: function end() {
          throw new Error('This TimeRanges object is empty');
        }
      };
    } else {
      timeRangesObj = {
        length: ranges.length,
        start: getRange.bind(null, 'start', 0, ranges),
        end: getRange.bind(null, 'end', 1, ranges)
      };
    }
    if (window.Symbol && window.Symbol.iterator) {
      timeRangesObj[window.Symbol.iterator] = function () {
        return (ranges || []).values();
      };
    }
    return timeRangesObj;
  }
  function createTimeRanges(start, end) {
    if (Array.isArray(start)) {
      return createTimeRangesObj(start);
    } else if (start === undefined || end === undefined) {
      return createTimeRangesObj();
    }
    return createTimeRangesObj([[start, end]]);
  }
  function bufferedPercent(buffered, duration) {
    var bufferedDuration = 0;
    var start;
    var end;
    if (!duration) {
      return 0;
    }
    if (!buffered || !buffered.length) {
      buffered = createTimeRanges(0, 0);
    }
    for (var i = 0; i < buffered.length; i++) {
      start = buffered.start(i);
      end = buffered.end(i);
      if (end > duration) {
        end = duration;
      }
      bufferedDuration += end - start;
    }
    return bufferedDuration / duration;
  }
  function MediaError(value) {
    if (value instanceof MediaError) {
      return value;
    }
    if (typeof value === 'number') {
      this.code = value;
    } else if (typeof value === 'string') {
      this.message = value;
    } else if (isObject$1(value)) {
      if (typeof value.code === 'number') {
        this.code = value.code;
      }
      assign(this, value);
    }
    if (!this.message) {
      this.message = MediaError.defaultMessages[this.code] || '';
    }
  }
  MediaError.prototype.code = 0;
  MediaError.prototype.message = '';
  MediaError.prototype.status = null;
  MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];
  MediaError.defaultMessages = {
    1: 'You aborted the media playback',
    2: 'A network error caused the media download to fail part-way.',
    3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',
    4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',
    5: 'The media is encrypted and we do not have the keys to decrypt it.'
  };
  for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
    MediaError[MediaError.errorTypes[errNum]] = errNum;
    MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
  }
  var tuple = SafeParseTuple;
  function SafeParseTuple(obj, reviver) {
    var json;
    var error = null;
    try {
      json = JSON.parse(obj, reviver);
    } catch (err) {
      error = err;
    }
    return [error, json];
  }
  function isPromise(value) {
    return value !== undefined && value !== null && typeof value.then === 'function';
  }
  function silencePromise(value) {
    if (isPromise(value)) {
      value.then(null, function (e) {});
    }
  }
  var trackToJson_ = function trackToJson_(track) {
    var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {
      if (track[prop]) {
        acc[prop] = track[prop];
      }
      return acc;
    }, {
      cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {
        return {
          startTime: cue.startTime,
          endTime: cue.endTime,
          text: cue.text,
          id: cue.id
        };
      })
    });
    return ret;
  };
  var textTracksToJson = function textTracksToJson(tech) {
    var trackEls = tech.$$('track');
    var trackObjs = Array.prototype.map.call(trackEls, function (t) {
      return t.track;
    });
    var tracks = Array.prototype.map.call(trackEls, function (trackEl) {
      var json = trackToJson_(trackEl.track);
      if (trackEl.src) {
        json.src = trackEl.src;
      }
      return json;
    });
    return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {
      return trackObjs.indexOf(track) === -1;
    }).map(trackToJson_));
  };
  var jsonToTextTracks = function jsonToTextTracks(json, tech) {
    json.forEach(function (track) {
      var addedTrack = tech.addRemoteTextTrack(track).track;
      if (!track.src && track.cues) {
        track.cues.forEach(function (cue) {
          return addedTrack.addCue(cue);
        });
      }
    });
    return tech.textTracks();
  };
  var textTrackConverter = {
    textTracksToJson: textTracksToJson,
    jsonToTextTracks: jsonToTextTracks,
    trackToJson_: trackToJson_
  };
  var MODAL_CLASS_NAME = 'vjs-modal-dialog';
  var ModalDialog = function (_Component) {
    inheritsLoose(ModalDialog, _Component);
    function ModalDialog(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.handleKeyDown_ = function (e) {
        return _this.handleKeyDown(e);
      };
      _this.close_ = function (e) {
        return _this.close(e);
      };
      _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;
      _this.closeable(!_this.options_.uncloseable);
      _this.content(_this.options_.content);
      _this.contentEl_ = createEl('div', {
        className: MODAL_CLASS_NAME + "-content"
      }, {
        role: 'document'
      });
      _this.descEl_ = createEl('p', {
        className: MODAL_CLASS_NAME + "-description vjs-control-text",
        id: _this.el().getAttribute('aria-describedby')
      });
      textContent(_this.descEl_, _this.description());
      _this.el_.appendChild(_this.descEl_);
      _this.el_.appendChild(_this.contentEl_);
      return _this;
    }
    var _proto = ModalDialog.prototype;
    _proto.createEl = function createEl() {
      return _Component.prototype.createEl.call(this, 'div', {
        className: this.buildCSSClass(),
        tabIndex: -1
      }, {
        'aria-describedby': this.id() + "_description",
        'aria-hidden': 'true',
        'aria-label': this.label(),
        'role': 'dialog'
      });
    };
    _proto.dispose = function dispose() {
      this.contentEl_ = null;
      this.descEl_ = null;
      this.previouslyActiveEl_ = null;
      _Component.prototype.dispose.call(this);
    }
    ;
    _proto.buildCSSClass = function buildCSSClass() {
      return MODAL_CLASS_NAME + " vjs-hidden " + _Component.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.label = function label() {
      return this.localize(this.options_.label || 'Modal Window');
    }
    ;
    _proto.description = function description() {
      var desc = this.options_.description || this.localize('This is a modal window.');
      if (this.closeable()) {
        desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');
      }
      return desc;
    }
    ;
    _proto.open = function open() {
      if (!this.opened_) {
        var player = this.player();
        this.trigger('beforemodalopen');
        this.opened_ = true;
        if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
          this.fill();
        }
        this.wasPlaying_ = !player.paused();
        if (this.options_.pauseOnOpen && this.wasPlaying_) {
          player.pause();
        }
        this.on('keydown', this.handleKeyDown_);
        this.hadControls_ = player.controls();
        player.controls(false);
        this.show();
        this.conditionalFocus_();
        this.el().setAttribute('aria-hidden', 'false');
        this.trigger('modalopen');
        this.hasBeenOpened_ = true;
      }
    }
    ;
    _proto.opened = function opened(value) {
      if (typeof value === 'boolean') {
        this[value ? 'open' : 'close']();
      }
      return this.opened_;
    }
    ;
    _proto.close = function close() {
      if (!this.opened_) {
        return;
      }
      var player = this.player();
      this.trigger('beforemodalclose');
      this.opened_ = false;
      if (this.wasPlaying_ && this.options_.pauseOnOpen) {
        player.play();
      }
      this.off('keydown', this.handleKeyDown_);
      if (this.hadControls_) {
        player.controls(true);
      }
      this.hide();
      this.el().setAttribute('aria-hidden', 'true');
      this.trigger('modalclose');
      this.conditionalBlur_();
      if (this.options_.temporary) {
        this.dispose();
      }
    }
    ;
    _proto.closeable = function closeable(value) {
      if (typeof value === 'boolean') {
        var closeable = this.closeable_ = !!value;
        var close = this.getChild('closeButton');
        if (closeable && !close) {
          var temp = this.contentEl_;
          this.contentEl_ = this.el_;
          close = this.addChild('closeButton', {
            controlText: 'Close Modal Dialog'
          });
          this.contentEl_ = temp;
          this.on(close, 'close', this.close_);
        }
        if (!closeable && close) {
          this.off(close, 'close', this.close_);
          this.removeChild(close);
          close.dispose();
        }
      }
      return this.closeable_;
    }
    ;
    _proto.fill = function fill() {
      this.fillWith(this.content());
    }
    ;
    _proto.fillWith = function fillWith(content) {
      var contentEl = this.contentEl();
      var parentEl = contentEl.parentNode;
      var nextSiblingEl = contentEl.nextSibling;
      this.trigger('beforemodalfill');
      this.hasBeenFilled_ = true;
      parentEl.removeChild(contentEl);
      this.empty();
      insertContent(contentEl, content);
      this.trigger('modalfill');
      if (nextSiblingEl) {
        parentEl.insertBefore(contentEl, nextSiblingEl);
      } else {
        parentEl.appendChild(contentEl);
      }
      var closeButton = this.getChild('closeButton');
      if (closeButton) {
        parentEl.appendChild(closeButton.el_);
      }
    }
    ;
    _proto.empty = function empty() {
      this.trigger('beforemodalempty');
      emptyEl(this.contentEl());
      this.trigger('modalempty');
    }
    ;
    _proto.content = function content(value) {
      if (typeof value !== 'undefined') {
        this.content_ = value;
      }
      return this.content_;
    }
    ;
    _proto.conditionalFocus_ = function conditionalFocus_() {
      var activeEl = document.activeElement;
      var playerEl = this.player_.el_;
      this.previouslyActiveEl_ = null;
      if (playerEl.contains(activeEl) || playerEl === activeEl) {
        this.previouslyActiveEl_ = activeEl;
        this.focus();
      }
    }
    ;
    _proto.conditionalBlur_ = function conditionalBlur_() {
      if (this.previouslyActiveEl_) {
        this.previouslyActiveEl_.focus();
        this.previouslyActiveEl_ = null;
      }
    }
    ;
    _proto.handleKeyDown = function handleKeyDown(event) {
      event.stopPropagation();
      if (keycode.isEventKey(event, 'Escape') && this.closeable()) {
        event.preventDefault();
        this.close();
        return;
      }
      if (!keycode.isEventKey(event, 'Tab')) {
        return;
      }
      var focusableEls = this.focusableEls_();
      var activeEl = this.el_.querySelector(':focus');
      var focusIndex;
      for (var i = 0; i < focusableEls.length; i++) {
        if (activeEl === focusableEls[i]) {
          focusIndex = i;
          break;
        }
      }
      if (document.activeElement === this.el_) {
        focusIndex = 0;
      }
      if (event.shiftKey && focusIndex === 0) {
        focusableEls[focusableEls.length - 1].focus();
        event.preventDefault();
      } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
        focusableEls[0].focus();
        event.preventDefault();
      }
    }
    ;
    _proto.focusableEls_ = function focusableEls_() {
      var allChildren = this.el_.querySelectorAll('*');
      return Array.prototype.filter.call(allChildren, function (child) {
        return (child instanceof window.HTMLAnchorElement || child instanceof window.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window.HTMLInputElement || child instanceof window.HTMLSelectElement || child instanceof window.HTMLTextAreaElement || child instanceof window.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window.HTMLIFrameElement || child instanceof window.HTMLObjectElement || child instanceof window.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');
      });
    };
    return ModalDialog;
  }(Component$1);
  ModalDialog.prototype.options_ = {
    pauseOnOpen: true,
    temporary: true
  };
  Component$1.registerComponent('ModalDialog', ModalDialog);
  var TrackList = function (_EventTarget) {
    inheritsLoose(TrackList, _EventTarget);
    function TrackList(tracks) {
      var _this;
      if (tracks === void 0) {
        tracks = [];
      }
      _this = _EventTarget.call(this) || this;
      _this.tracks_ = [];
      Object.defineProperty(assertThisInitialized(_this), 'length', {
        get: function get() {
          return this.tracks_.length;
        }
      });
      for (var i = 0; i < tracks.length; i++) {
        _this.addTrack(tracks[i]);
      }
      return _this;
    }
    var _proto = TrackList.prototype;
    _proto.addTrack = function addTrack(track) {
      var _this2 = this;
      var index = this.tracks_.length;
      if (!('' + index in this)) {
        Object.defineProperty(this, index, {
          get: function get() {
            return this.tracks_[index];
          }
        });
      }
      if (this.tracks_.indexOf(track) === -1) {
        this.tracks_.push(track);
        this.trigger({
          track: track,
          type: 'addtrack',
          target: this
        });
      }
      track.labelchange_ = function () {
        _this2.trigger({
          track: track,
          type: 'labelchange',
          target: _this2
        });
      };
      if (isEvented(track)) {
        track.addEventListener('labelchange', track.labelchange_);
      }
    }
    ;
    _proto.removeTrack = function removeTrack(rtrack) {
      var track;
      for (var i = 0, l = this.length; i < l; i++) {
        if (this[i] === rtrack) {
          track = this[i];
          if (track.off) {
            track.off();
          }
          this.tracks_.splice(i, 1);
          break;
        }
      }
      if (!track) {
        return;
      }
      this.trigger({
        track: track,
        type: 'removetrack',
        target: this
      });
    }
    ;
    _proto.getTrackById = function getTrackById(id) {
      var result = null;
      for (var i = 0, l = this.length; i < l; i++) {
        var track = this[i];
        if (track.id === id) {
          result = track;
          break;
        }
      }
      return result;
    };
    return TrackList;
  }(EventTarget$2);
  TrackList.prototype.allowedEvents_ = {
    change: 'change',
    addtrack: 'addtrack',
    removetrack: 'removetrack',
    labelchange: 'labelchange'
  };
  for (var event in TrackList.prototype.allowedEvents_) {
    TrackList.prototype['on' + event] = null;
  }
  var disableOthers$1 = function disableOthers(list, track) {
    for (var i = 0; i < list.length; i++) {
      if (!Object.keys(list[i]).length || track.id === list[i].id) {
        continue;
      }
      list[i].enabled = false;
    }
  };
  var AudioTrackList = function (_TrackList) {
    inheritsLoose(AudioTrackList, _TrackList);
    function AudioTrackList(tracks) {
      var _this;
      if (tracks === void 0) {
        tracks = [];
      }
      for (var i = tracks.length - 1; i >= 0; i--) {
        if (tracks[i].enabled) {
          disableOthers$1(tracks, tracks[i]);
          break;
        }
      }
      _this = _TrackList.call(this, tracks) || this;
      _this.changing_ = false;
      return _this;
    }
    var _proto = AudioTrackList.prototype;
    _proto.addTrack = function addTrack(track) {
      var _this2 = this;
      if (track.enabled) {
        disableOthers$1(this, track);
      }
      _TrackList.prototype.addTrack.call(this, track);
      if (!track.addEventListener) {
        return;
      }
      track.enabledChange_ = function () {
        if (_this2.changing_) {
          return;
        }
        _this2.changing_ = true;
        disableOthers$1(_this2, track);
        _this2.changing_ = false;
        _this2.trigger('change');
      };
      track.addEventListener('enabledchange', track.enabledChange_);
    };
    _proto.removeTrack = function removeTrack(rtrack) {
      _TrackList.prototype.removeTrack.call(this, rtrack);
      if (rtrack.removeEventListener && rtrack.enabledChange_) {
        rtrack.removeEventListener('enabledchange', rtrack.enabledChange_);
        rtrack.enabledChange_ = null;
      }
    };
    return AudioTrackList;
  }(TrackList);
  var disableOthers = function disableOthers(list, track) {
    for (var i = 0; i < list.length; i++) {
      if (!Object.keys(list[i]).length || track.id === list[i].id) {
        continue;
      }
      list[i].selected = false;
    }
  };
  var VideoTrackList = function (_TrackList) {
    inheritsLoose(VideoTrackList, _TrackList);
    function VideoTrackList(tracks) {
      var _this;
      if (tracks === void 0) {
        tracks = [];
      }
      for (var i = tracks.length - 1; i >= 0; i--) {
        if (tracks[i].selected) {
          disableOthers(tracks, tracks[i]);
          break;
        }
      }
      _this = _TrackList.call(this, tracks) || this;
      _this.changing_ = false;
      Object.defineProperty(assertThisInitialized(_this), 'selectedIndex', {
        get: function get() {
          for (var _i = 0; _i < this.length; _i++) {
            if (this[_i].selected) {
              return _i;
            }
          }
          return -1;
        },
        set: function set() {}
      });
      return _this;
    }
    var _proto = VideoTrackList.prototype;
    _proto.addTrack = function addTrack(track) {
      var _this2 = this;
      if (track.selected) {
        disableOthers(this, track);
      }
      _TrackList.prototype.addTrack.call(this, track);
      if (!track.addEventListener) {
        return;
      }
      track.selectedChange_ = function () {
        if (_this2.changing_) {
          return;
        }
        _this2.changing_ = true;
        disableOthers(_this2, track);
        _this2.changing_ = false;
        _this2.trigger('change');
      };
      track.addEventListener('selectedchange', track.selectedChange_);
    };
    _proto.removeTrack = function removeTrack(rtrack) {
      _TrackList.prototype.removeTrack.call(this, rtrack);
      if (rtrack.removeEventListener && rtrack.selectedChange_) {
        rtrack.removeEventListener('selectedchange', rtrack.selectedChange_);
        rtrack.selectedChange_ = null;
      }
    };
    return VideoTrackList;
  }(TrackList);
  var TextTrackList = function (_TrackList) {
    inheritsLoose(TextTrackList, _TrackList);
    function TextTrackList() {
      return _TrackList.apply(this, arguments) || this;
    }
    var _proto = TextTrackList.prototype;
    _proto.addTrack = function addTrack(track) {
      var _this = this;
      _TrackList.prototype.addTrack.call(this, track);
      if (!this.queueChange_) {
        this.queueChange_ = function () {
          return _this.queueTrigger('change');
        };
      }
      if (!this.triggerSelectedlanguagechange) {
        this.triggerSelectedlanguagechange_ = function () {
          return _this.trigger('selectedlanguagechange');
        };
      }
      track.addEventListener('modechange', this.queueChange_);
      var nonLanguageTextTrackKind = ['metadata', 'chapters'];
      if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
        track.addEventListener('modechange', this.triggerSelectedlanguagechange_);
      }
    };
    _proto.removeTrack = function removeTrack(rtrack) {
      _TrackList.prototype.removeTrack.call(this, rtrack);
      if (rtrack.removeEventListener) {
        if (this.queueChange_) {
          rtrack.removeEventListener('modechange', this.queueChange_);
        }
        if (this.selectedlanguagechange_) {
          rtrack.removeEventListener('modechange', this.triggerSelectedlanguagechange_);
        }
      }
    };
    return TextTrackList;
  }(TrackList);
  var HtmlTrackElementList = function () {
    function HtmlTrackElementList(trackElements) {
      if (trackElements === void 0) {
        trackElements = [];
      }
      this.trackElements_ = [];
      Object.defineProperty(this, 'length', {
        get: function get() {
          return this.trackElements_.length;
        }
      });
      for (var i = 0, length = trackElements.length; i < length; i++) {
        this.addTrackElement_(trackElements[i]);
      }
    }
    var _proto = HtmlTrackElementList.prototype;
    _proto.addTrackElement_ = function addTrackElement_(trackElement) {
      var index = this.trackElements_.length;
      if (!('' + index in this)) {
        Object.defineProperty(this, index, {
          get: function get() {
            return this.trackElements_[index];
          }
        });
      }
      if (this.trackElements_.indexOf(trackElement) === -1) {
        this.trackElements_.push(trackElement);
      }
    }
    ;
    _proto.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {
      var trackElement_;
      for (var i = 0, length = this.trackElements_.length; i < length; i++) {
        if (track === this.trackElements_[i].track) {
          trackElement_ = this.trackElements_[i];
          break;
        }
      }
      return trackElement_;
    }
    ;
    _proto.removeTrackElement_ = function removeTrackElement_(trackElement) {
      for (var i = 0, length = this.trackElements_.length; i < length; i++) {
        if (trackElement === this.trackElements_[i]) {
          if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === 'function') {
            this.trackElements_[i].track.off();
          }
          if (typeof this.trackElements_[i].off === 'function') {
            this.trackElements_[i].off();
          }
          this.trackElements_.splice(i, 1);
          break;
        }
      }
    };
    return HtmlTrackElementList;
  }();
  var TextTrackCueList = function () {
    function TextTrackCueList(cues) {
      TextTrackCueList.prototype.setCues_.call(this, cues);
      Object.defineProperty(this, 'length', {
        get: function get() {
          return this.length_;
        }
      });
    }
    var _proto = TextTrackCueList.prototype;
    _proto.setCues_ = function setCues_(cues) {
      var oldLength = this.length || 0;
      var i = 0;
      var l = cues.length;
      this.cues_ = cues;
      this.length_ = cues.length;
      var defineProp = function defineProp(index) {
        if (!('' + index in this)) {
          Object.defineProperty(this, '' + index, {
            get: function get() {
              return this.cues_[index];
            }
          });
        }
      };
      if (oldLength < l) {
        i = oldLength;
        for (; i < l; i++) {
          defineProp.call(this, i);
        }
      }
    }
    ;
    _proto.getCueById = function getCueById(id) {
      var result = null;
      for (var i = 0, l = this.length; i < l; i++) {
        var cue = this[i];
        if (cue.id === id) {
          result = cue;
          break;
        }
      }
      return result;
    };
    return TextTrackCueList;
  }();
  var VideoTrackKind = {
    alternative: 'alternative',
    captions: 'captions',
    main: 'main',
    sign: 'sign',
    subtitles: 'subtitles',
    commentary: 'commentary'
  };
  var AudioTrackKind = {
    'alternative': 'alternative',
    'descriptions': 'descriptions',
    'main': 'main',
    'main-desc': 'main-desc',
    'translation': 'translation',
    'commentary': 'commentary'
  };
  var TextTrackKind = {
    subtitles: 'subtitles',
    captions: 'captions',
    descriptions: 'descriptions',
    chapters: 'chapters',
    metadata: 'metadata'
  };
  var TextTrackMode = {
    disabled: 'disabled',
    hidden: 'hidden',
    showing: 'showing'
  };
  var Track = function (_EventTarget) {
    inheritsLoose(Track, _EventTarget);
    function Track(options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      _this = _EventTarget.call(this) || this;
      var trackProps = {
        id: options.id || 'vjs_track_' + newGUID(),
        kind: options.kind || '',
        language: options.language || ''
      };
      var label = options.label || '';
      var _loop = function _loop(key) {
        Object.defineProperty(assertThisInitialized(_this), key, {
          get: function get() {
            return trackProps[key];
          },
          set: function set() {}
        });
      };
      for (var key in trackProps) {
        _loop(key);
      }
      Object.defineProperty(assertThisInitialized(_this), 'label', {
        get: function get() {
          return label;
        },
        set: function set(newLabel) {
          if (newLabel !== label) {
            label = newLabel;
            this.trigger('labelchange');
          }
        }
      });
      return _this;
    }
    return Track;
  }(EventTarget$2);
  var parseUrl = function parseUrl(url) {
    var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];
    var a = document.createElement('a');
    a.href = url;
    var details = {};
    for (var i = 0; i < props.length; i++) {
      details[props[i]] = a[props[i]];
    }
    if (details.protocol === 'http:') {
      details.host = details.host.replace(/:80$/, '');
    }
    if (details.protocol === 'https:') {
      details.host = details.host.replace(/:443$/, '');
    }
    if (!details.protocol) {
      details.protocol = window.location.protocol;
    }
    if (!details.host) {
      details.host = window.location.host;
    }
    return details;
  };
  var getAbsoluteURL = function getAbsoluteURL(url) {
    if (!url.match(/^https?:\/\//)) {
      var a = document.createElement('a');
      a.href = url;
      url = a.href;
    }
    return url;
  };
  var getFileExtension = function getFileExtension(path) {
    if (typeof path === 'string') {
      var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
      var pathParts = splitPathRe.exec(path);
      if (pathParts) {
        return pathParts.pop().toLowerCase();
      }
    }
    return '';
  };
  var isCrossOrigin = function isCrossOrigin(url, winLoc) {
    if (winLoc === void 0) {
      winLoc = window.location;
    }
    var urlInfo = parseUrl(url);
    var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;
    var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;
    return crossOrigin;
  };
  var Url = Object.freeze({
    __proto__: null,
    parseUrl: parseUrl,
    getAbsoluteURL: getAbsoluteURL,
    getFileExtension: getFileExtension,
    isCrossOrigin: isCrossOrigin
  });
  var win;
  if (typeof window !== "undefined") {
    win = window;
  } else if (typeof commonjsGlobal$1 !== "undefined") {
    win = commonjsGlobal$1;
  } else if (typeof self !== "undefined") {
    win = self;
  } else {
    win = {};
  }
  var window_1 = win;
  var isFunction_1 = isFunction;
  var toString = Object.prototype.toString;
  function isFunction(fn) {
    if (!fn) {
      return false;
    }
    var string = toString.call(fn);
    return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && (
    fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
  }
  var httpResponseHandler = function httpResponseHandler(callback, decodeResponseBody) {
    if (decodeResponseBody === void 0) {
      decodeResponseBody = false;
    }
    return function (err, response, responseBody) {
      if (err) {
        callback(err);
        return;
      }
      if (response.statusCode >= 400 && response.statusCode <= 599) {
        var cause = responseBody;
        if (decodeResponseBody) {
          if (window_1.TextDecoder) {
            var charset = getCharset(response.headers && response.headers['content-type']);
            try {
              cause = new TextDecoder(charset).decode(responseBody);
            } catch (e) {}
          } else {
            cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));
          }
        }
        callback({
          cause: cause
        });
        return;
      }
      callback(null, responseBody);
    };
  };
  function getCharset(contentTypeHeader) {
    if (contentTypeHeader === void 0) {
      contentTypeHeader = '';
    }
    return contentTypeHeader.toLowerCase().split(';').reduce(function (charset, contentType) {
      var _contentType$split = contentType.split('='),
          type = _contentType$split[0],
          value = _contentType$split[1];
      if (type.trim() === 'charset') {
        return value.trim();
      }
      return charset;
    }, 'utf-8');
  }
  var httpHandler = httpResponseHandler;
  createXHR.httpHandler = httpHandler;
  /**
   * @license
   * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
   * Copyright (c) 2014 David Bjrklund
   * Available under the MIT license
   * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
   */
  var parseHeaders = function parseHeaders(headers) {
    var result = {};
    if (!headers) {
      return result;
    }
    headers.trim().split('\n').forEach(function (row) {
      var index = row.indexOf(':');
      var key = row.slice(0, index).trim().toLowerCase();
      var value = row.slice(index + 1).trim();
      if (typeof result[key] === 'undefined') {
        result[key] = value;
      } else if (Array.isArray(result[key])) {
        result[key].push(value);
      } else {
        result[key] = [result[key], value];
      }
    });
    return result;
  };
  var lib = createXHR;
  var default_1 = createXHR;
  createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop$1;
  createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window_1.XDomainRequest;
  forEachArray(["get", "put", "post", "patch", "head", "delete"], function (method) {
    createXHR[method === "delete" ? "del" : method] = function (uri, options, callback) {
      options = initParams(uri, options, callback);
      options.method = method.toUpperCase();
      return _createXHR(options);
    };
  });
  function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
      iterator(array[i]);
    }
  }
  function isEmpty(obj) {
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) return false;
    }
    return true;
  }
  function initParams(uri, options, callback) {
    var params = uri;
    if (isFunction_1(options)) {
      callback = options;
      if (typeof uri === "string") {
        params = {
          uri: uri
        };
      }
    } else {
      params = _extends_1({}, options, {
        uri: uri
      });
    }
    params.callback = callback;
    return params;
  }
  function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback);
    return _createXHR(options);
  }
  function _createXHR(options) {
    if (typeof options.callback === "undefined") {
      throw new Error("callback argument missing");
    }
    var called = false;
    var callback = function cbOnce(err, response, body) {
      if (!called) {
        called = true;
        options.callback(err, response, body);
      }
    };
    function readystatechange() {
      if (xhr.readyState === 4) {
        setTimeout(loadFunc, 0);
      }
    }
    function getBody() {
      var body = undefined;
      if (xhr.response) {
        body = xhr.response;
      } else {
        body = xhr.responseText || getXml(xhr);
      }
      if (isJson) {
        try {
          body = JSON.parse(body);
        } catch (e) {}
      }
      return body;
    }
    function errorFunc(evt) {
      clearTimeout(timeoutTimer);
      if (!(evt instanceof Error)) {
        evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
      }
      evt.statusCode = 0;
      return callback(evt, failureResponse);
    }
    function loadFunc() {
      if (aborted) return;
      var status;
      clearTimeout(timeoutTimer);
      if (options.useXDR && xhr.status === undefined) {
        status = 200;
      } else {
        status = xhr.status === 1223 ? 204 : xhr.status;
      }
      var response = failureResponse;
      var err = null;
      if (status !== 0) {
        response = {
          body: getBody(),
          statusCode: status,
          method: method,
          headers: {},
          url: uri,
          rawRequest: xhr
        };
        if (xhr.getAllResponseHeaders) {
          response.headers = parseHeaders(xhr.getAllResponseHeaders());
        }
      } else {
        err = new Error("Internal XMLHttpRequest Error");
      }
      return callback(err, response, response.body);
    }
    var xhr = options.xhr || null;
    if (!xhr) {
      if (options.cors || options.useXDR) {
        xhr = new createXHR.XDomainRequest();
      } else {
        xhr = new createXHR.XMLHttpRequest();
      }
    }
    var key;
    var aborted;
    var uri = xhr.url = options.uri || options.url;
    var method = xhr.method = options.method || "GET";
    var body = options.body || options.data;
    var headers = xhr.headers = options.headers || {};
    var sync = !!options.sync;
    var isJson = false;
    var timeoutTimer;
    var failureResponse = {
      body: undefined,
      headers: {},
      statusCode: 0,
      method: method,
      url: uri,
      rawRequest: xhr
    };
    if ("json" in options && options.json !== false) {
      isJson = true;
      headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
      if (method !== "GET" && method !== "HEAD") {
        headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
        body = JSON.stringify(options.json === true ? body : options.json);
      }
    }
    xhr.onreadystatechange = readystatechange;
    xhr.onload = loadFunc;
    xhr.onerror = errorFunc;
    xhr.onprogress = function () {
    };
    xhr.onabort = function () {
      aborted = true;
    };
    xhr.ontimeout = errorFunc;
    xhr.open(method, uri, !sync, options.username, options.password);
    if (!sync) {
      xhr.withCredentials = !!options.withCredentials;
    }
    if (!sync && options.timeout > 0) {
      timeoutTimer = setTimeout(function () {
        if (aborted) return;
        aborted = true;
        xhr.abort("timeout");
        var e = new Error("XMLHttpRequest timeout");
        e.code = "ETIMEDOUT";
        errorFunc(e);
      }, options.timeout);
    }
    if (xhr.setRequestHeader) {
      for (key in headers) {
        if (headers.hasOwnProperty(key)) {
          xhr.setRequestHeader(key, headers[key]);
        }
      }
    } else if (options.headers && !isEmpty(options.headers)) {
      throw new Error("Headers cannot be set on an XDomainRequest object");
    }
    if ("responseType" in options) {
      xhr.responseType = options.responseType;
    }
    if ("beforeSend" in options && typeof options.beforeSend === "function") {
      options.beforeSend(xhr);
    }
    xhr.send(body || null);
    return xhr;
  }
  function getXml(xhr) {
    try {
      if (xhr.responseType === "document") {
        return xhr.responseXML;
      }
      var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
      if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML;
      }
    } catch (e) {}
    return null;
  }
  function noop$1() {}
  lib["default"] = default_1;
  var parseCues = function parseCues(srcContent, track) {
    var parser = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder());
    var errors = [];
    parser.oncue = function (cue) {
      track.addCue(cue);
    };
    parser.onparsingerror = function (error) {
      errors.push(error);
    };
    parser.onflush = function () {
      track.trigger({
        type: 'loadeddata',
        target: track
      });
    };
    parser.parse(srcContent);
    if (errors.length > 0) {
      if (window.console && window.console.groupCollapsed) {
        window.console.groupCollapsed("Text Track parsing errors for " + track.src);
      }
      errors.forEach(function (error) {
        return log$1.error(error);
      });
      if (window.console && window.console.groupEnd) {
        window.console.groupEnd();
      }
    }
    parser.flush();
  };
  var loadTrack = function loadTrack(src, track) {
    var opts = {
      uri: src
    };
    var crossOrigin = isCrossOrigin(src);
    if (crossOrigin) {
      opts.cors = crossOrigin;
    }
    var withCredentials = track.tech_.crossOrigin() === 'use-credentials';
    if (withCredentials) {
      opts.withCredentials = withCredentials;
    }
    lib(opts, bind(this, function (err, response, responseBody) {
      if (err) {
        return log$1.error(err, response);
      }
      track.loaded_ = true;
      if (typeof window.WebVTT !== 'function') {
        if (track.tech_) {
          track.tech_.any(['vttjsloaded', 'vttjserror'], function (event) {
            if (event.type === 'vttjserror') {
              log$1.error("vttjs failed to load, stopping trying to process " + track.src);
              return;
            }
            return parseCues(responseBody, track);
          });
        }
      } else {
        parseCues(responseBody, track);
      }
    }));
  };
  var TextTrack = function (_Track) {
    inheritsLoose(TextTrack, _Track);
    function TextTrack(options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      if (!options.tech) {
        throw new Error('A tech was not provided.');
      }
      var settings = mergeOptions$3(options, {
        kind: TextTrackKind[options.kind] || 'subtitles',
        language: options.language || options.srclang || ''
      });
      var mode = TextTrackMode[settings.mode] || 'disabled';
      var default_ = settings["default"];
      if (settings.kind === 'metadata' || settings.kind === 'chapters') {
        mode = 'hidden';
      }
      _this = _Track.call(this, settings) || this;
      _this.tech_ = settings.tech;
      _this.cues_ = [];
      _this.activeCues_ = [];
      _this.preload_ = _this.tech_.preloadTextTracks !== false;
      var cues = new TextTrackCueList(_this.cues_);
      var activeCues = new TextTrackCueList(_this.activeCues_);
      var changed = false;
      var timeupdateHandler = bind(assertThisInitialized(_this), function () {
        if (!this.tech_.isReady_ || this.tech_.isDisposed()) {
          return;
        }
        this.activeCues = this.activeCues;
        if (changed) {
          this.trigger('cuechange');
          changed = false;
        }
      });
      var disposeHandler = function disposeHandler() {
        _this.tech_.off('timeupdate', timeupdateHandler);
      };
      _this.tech_.one('dispose', disposeHandler);
      if (mode !== 'disabled') {
        _this.tech_.on('timeupdate', timeupdateHandler);
      }
      Object.defineProperties(assertThisInitialized(_this), {
        "default": {
          get: function get() {
            return default_;
          },
          set: function set() {}
        },
        mode: {
          get: function get() {
            return mode;
          },
          set: function set(newMode) {
            if (!TextTrackMode[newMode]) {
              return;
            }
            if (mode === newMode) {
              return;
            }
            mode = newMode;
            if (!this.preload_ && mode !== 'disabled' && this.cues.length === 0) {
              loadTrack(this.src, this);
            }
            this.tech_.off('timeupdate', timeupdateHandler);
            if (mode !== 'disabled') {
              this.tech_.on('timeupdate', timeupdateHandler);
            }
            this.trigger('modechange');
          }
        },
        cues: {
          get: function get() {
            if (!this.loaded_) {
              return null;
            }
            return cues;
          },
          set: function set() {}
        },
        activeCues: {
          get: function get() {
            if (!this.loaded_) {
              return null;
            }
            if (this.cues.length === 0) {
              return activeCues;
            }
            var ct = this.tech_.currentTime();
            var active = [];
            for (var i = 0, l = this.cues.length; i < l; i++) {
              var cue = this.cues[i];
              if (cue.startTime <= ct && cue.endTime >= ct) {
                active.push(cue);
              } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
                active.push(cue);
              }
            }
            changed = false;
            if (active.length !== this.activeCues_.length) {
              changed = true;
            } else {
              for (var _i = 0; _i < active.length; _i++) {
                if (this.activeCues_.indexOf(active[_i]) === -1) {
                  changed = true;
                }
              }
            }
            this.activeCues_ = active;
            activeCues.setCues_(this.activeCues_);
            return activeCues;
          },
          set: function set() {}
        }
      });
      if (settings.src) {
        _this.src = settings.src;
        if (!_this.preload_) {
          _this.loaded_ = true;
        }
        if (_this.preload_ || settings.kind !== 'subtitles' && settings.kind !== 'captions') {
          loadTrack(_this.src, assertThisInitialized(_this));
        }
      } else {
        _this.loaded_ = true;
      }
      return _this;
    }
    var _proto = TextTrack.prototype;
    _proto.addCue = function addCue(originalCue) {
      var cue = originalCue;
      if (window.vttjs && !(originalCue instanceof window.vttjs.VTTCue)) {
        cue = new window.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);
        for (var prop in originalCue) {
          if (!(prop in cue)) {
            cue[prop] = originalCue[prop];
          }
        }
        cue.id = originalCue.id;
        cue.originalCue_ = originalCue;
      }
      var tracks = this.tech_.textTracks();
      for (var i = 0; i < tracks.length; i++) {
        if (tracks[i] !== this) {
          tracks[i].removeCue(cue);
        }
      }
      this.cues_.push(cue);
      this.cues.setCues_(this.cues_);
    }
    ;
    _proto.removeCue = function removeCue(_removeCue) {
      var i = this.cues_.length;
      while (i--) {
        var cue = this.cues_[i];
        if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
          this.cues_.splice(i, 1);
          this.cues.setCues_(this.cues_);
          break;
        }
      }
    };
    return TextTrack;
  }(Track);
  TextTrack.prototype.allowedEvents_ = {
    cuechange: 'cuechange'
  };
  var AudioTrack = function (_Track) {
    inheritsLoose(AudioTrack, _Track);
    function AudioTrack(options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      var settings = mergeOptions$3(options, {
        kind: AudioTrackKind[options.kind] || ''
      });
      _this = _Track.call(this, settings) || this;
      var enabled = false;
      Object.defineProperty(assertThisInitialized(_this), 'enabled', {
        get: function get() {
          return enabled;
        },
        set: function set(newEnabled) {
          if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {
            return;
          }
          enabled = newEnabled;
          this.trigger('enabledchange');
        }
      });
      if (settings.enabled) {
        _this.enabled = settings.enabled;
      }
      _this.loaded_ = true;
      return _this;
    }
    return AudioTrack;
  }(Track);
  var VideoTrack = function (_Track) {
    inheritsLoose(VideoTrack, _Track);
    function VideoTrack(options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      var settings = mergeOptions$3(options, {
        kind: VideoTrackKind[options.kind] || ''
      });
      _this = _Track.call(this, settings) || this;
      var selected = false;
      Object.defineProperty(assertThisInitialized(_this), 'selected', {
        get: function get() {
          return selected;
        },
        set: function set(newSelected) {
          if (typeof newSelected !== 'boolean' || newSelected === selected) {
            return;
          }
          selected = newSelected;
          this.trigger('selectedchange');
        }
      });
      if (settings.selected) {
        _this.selected = settings.selected;
      }
      return _this;
    }
    return VideoTrack;
  }(Track);
  var NONE = 0;
  var LOADING = 1;
  var LOADED = 2;
  var ERROR = 3;
  var HTMLTrackElement = function (_EventTarget) {
    inheritsLoose(HTMLTrackElement, _EventTarget);
    function HTMLTrackElement(options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      _this = _EventTarget.call(this) || this;
      var readyState;
      var track = new TextTrack(options);
      _this.kind = track.kind;
      _this.src = track.src;
      _this.srclang = track.language;
      _this.label = track.label;
      _this["default"] = track["default"];
      Object.defineProperties(assertThisInitialized(_this), {
        readyState: {
          get: function get() {
            return readyState;
          }
        },
        track: {
          get: function get() {
            return track;
          }
        }
      });
      readyState = NONE;
      track.addEventListener('loadeddata', function () {
        readyState = LOADED;
        _this.trigger({
          type: 'load',
          target: assertThisInitialized(_this)
        });
      });
      return _this;
    }
    return HTMLTrackElement;
  }(EventTarget$2);
  HTMLTrackElement.prototype.allowedEvents_ = {
    load: 'load'
  };
  HTMLTrackElement.NONE = NONE;
  HTMLTrackElement.LOADING = LOADING;
  HTMLTrackElement.LOADED = LOADED;
  HTMLTrackElement.ERROR = ERROR;
  var NORMAL = {
    audio: {
      ListClass: AudioTrackList,
      TrackClass: AudioTrack,
      capitalName: 'Audio'
    },
    video: {
      ListClass: VideoTrackList,
      TrackClass: VideoTrack,
      capitalName: 'Video'
    },
    text: {
      ListClass: TextTrackList,
      TrackClass: TextTrack,
      capitalName: 'Text'
    }
  };
  Object.keys(NORMAL).forEach(function (type) {
    NORMAL[type].getterName = type + "Tracks";
    NORMAL[type].privateName = type + "Tracks_";
  });
  var REMOTE = {
    remoteText: {
      ListClass: TextTrackList,
      TrackClass: TextTrack,
      capitalName: 'RemoteText',
      getterName: 'remoteTextTracks',
      privateName: 'remoteTextTracks_'
    },
    remoteTextEl: {
      ListClass: HtmlTrackElementList,
      TrackClass: HTMLTrackElement,
      capitalName: 'RemoteTextTrackEls',
      getterName: 'remoteTextTrackEls',
      privateName: 'remoteTextTrackEls_'
    }
  };
  var ALL = _extends_1({}, NORMAL, REMOTE);
  REMOTE.names = Object.keys(REMOTE);
  NORMAL.names = Object.keys(NORMAL);
  ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);
  var minDoc = {};
  var topLevel = typeof commonjsGlobal$1 !== 'undefined' ? commonjsGlobal$1 : typeof window !== 'undefined' ? window : {};
  var doccy;
  if (typeof document !== 'undefined') {
    doccy = document;
  } else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];
    if (!doccy) {
      doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
  }
  var document_1 = doccy;
  var _objCreate = Object.create || function () {
    function F() {}
    return function (o) {
      if (arguments.length !== 1) {
        throw new Error('Object.create shim only accepts one parameter.');
      }
      F.prototype = o;
      return new F();
    };
  }();
  function ParsingError(errorData, message) {
    this.name = "ParsingError";
    this.code = errorData.code;
    this.message = message || errorData.message;
  }
  ParsingError.prototype = _objCreate(Error.prototype);
  ParsingError.prototype.constructor = ParsingError;
  ParsingError.Errors = {
    BadSignature: {
      code: 0,
      message: "Malformed WebVTT signature."
    },
    BadTimeStamp: {
      code: 1,
      message: "Malformed time stamp."
    }
  };
  function parseTimeStamp(input) {
    function computeSeconds(h, m, s, f) {
      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
    }
    var m = input.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
    if (!m) {
      return null;
    }
    if (m[3]) {
      return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
    } else if (m[1] > 59) {
      return computeSeconds(m[1], m[2], 0, m[4]);
    } else {
      return computeSeconds(0, m[1], m[2], m[4]);
    }
  }
  function Settings() {
    this.values = _objCreate(null);
  }
  Settings.prototype = {
    set: function set(k, v) {
      if (!this.get(k) && v !== "") {
        this.values[k] = v;
      }
    },
    get: function get(k, dflt, defaultKey) {
      if (defaultKey) {
        return this.has(k) ? this.values[k] : dflt[defaultKey];
      }
      return this.has(k) ? this.values[k] : dflt;
    },
    has: function has(k) {
      return k in this.values;
    },
    alt: function alt(k, v, a) {
      for (var n = 0; n < a.length; ++n) {
        if (v === a[n]) {
          this.set(k, v);
          break;
        }
      }
    },
    integer: function integer(k, v) {
      if (/^-?\d+$/.test(v)) {
        this.set(k, parseInt(v, 10));
      }
    },
    percent: function percent(k, v) {
      if (v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
        v = parseFloat(v);
        if (v >= 0 && v <= 100) {
          this.set(k, v);
          return true;
        }
      }
      return false;
    }
  };
  function parseOptions(input, callback, keyValueDelim, groupDelim) {
    var groups = groupDelim ? input.split(groupDelim) : [input];
    for (var i in groups) {
      if (typeof groups[i] !== "string") {
        continue;
      }
      var kv = groups[i].split(keyValueDelim);
      if (kv.length !== 2) {
        continue;
      }
      var k = kv[0];
      var v = kv[1];
      callback(k, v);
    }
  }
  function parseCue(input, cue, regionList) {
    var oInput = input;
    function consumeTimeStamp() {
      var ts = parseTimeStamp(input);
      if (ts === null) {
        throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed timestamp: " + oInput);
      }
      input = input.replace(/^[^\sa-zA-Z-]+/, "");
      return ts;
    }
    function consumeCueSettings(input, cue) {
      var settings = new Settings();
      parseOptions(input, function (k, v) {
        switch (k) {
          case "region":
            for (var i = regionList.length - 1; i >= 0; i--) {
              if (regionList[i].id === v) {
                settings.set(k, regionList[i].region);
                break;
              }
            }
            break;
          case "vertical":
            settings.alt(k, v, ["rl", "lr"]);
            break;
          case "line":
            var vals = v.split(","),
                vals0 = vals[0];
            settings.integer(k, vals0);
            settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
            settings.alt(k, vals0, ["auto"]);
            if (vals.length === 2) {
              settings.alt("lineAlign", vals[1], ["start", "center", "end"]);
            }
            break;
          case "position":
            vals = v.split(",");
            settings.percent(k, vals[0]);
            if (vals.length === 2) {
              settings.alt("positionAlign", vals[1], ["start", "center", "end"]);
            }
            break;
          case "size":
            settings.percent(k, v);
            break;
          case "align":
            settings.alt(k, v, ["start", "center", "end", "left", "right"]);
            break;
        }
      }, /:/, /\s/);
      cue.region = settings.get("region", null);
      cue.vertical = settings.get("vertical", "");
      try {
        cue.line = settings.get("line", "auto");
      } catch (e) {}
      cue.lineAlign = settings.get("lineAlign", "start");
      cue.snapToLines = settings.get("snapToLines", true);
      cue.size = settings.get("size", 100);
      try {
        cue.align = settings.get("align", "center");
      } catch (e) {
        cue.align = settings.get("align", "middle");
      }
      try {
        cue.position = settings.get("position", "auto");
      } catch (e) {
        cue.position = settings.get("position", {
          start: 0,
          left: 0,
          center: 50,
          middle: 50,
          end: 100,
          right: 100
        }, cue.align);
      }
      cue.positionAlign = settings.get("positionAlign", {
        start: "start",
        left: "start",
        center: "center",
        middle: "center",
        end: "end",
        right: "end"
      }, cue.align);
    }
    function skipWhitespace() {
      input = input.replace(/^\s+/, "");
    }
    skipWhitespace();
    cue.startTime = consumeTimeStamp();
    skipWhitespace();
    if (input.substr(0, 3) !== "-->") {
      throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
    }
    input = input.substr(3);
    skipWhitespace();
    cue.endTime = consumeTimeStamp();
    skipWhitespace();
    consumeCueSettings(input, cue);
  }
  var TEXTAREA_ELEMENT = document_1.createElement && document_1.createElement("textarea");
  var TAG_NAME = {
    c: "span",
    i: "i",
    b: "b",
    u: "u",
    ruby: "ruby",
    rt: "rt",
    v: "span",
    lang: "span"
  };
  var DEFAULT_COLOR_CLASS = {
    white: 'rgba(255,255,255,1)',
    lime: 'rgba(0,255,0,1)',
    cyan: 'rgba(0,255,255,1)',
    red: 'rgba(255,0,0,1)',
    yellow: 'rgba(255,255,0,1)',
    magenta: 'rgba(255,0,255,1)',
    blue: 'rgba(0,0,255,1)',
    black: 'rgba(0,0,0,1)'
  };
  var TAG_ANNOTATION = {
    v: "title",
    lang: "lang"
  };
  var NEEDS_PARENT = {
    rt: "ruby"
  };
  function parseContent(window, input) {
    function nextToken() {
      if (!input) {
        return null;
      }
      function consume(result) {
        input = input.substr(result.length);
        return result;
      }
      var m = input.match(/^([^<]*)(<[^>]*>?)?/);
      return consume(m[1] ? m[1] : m[2]);
    }
    function unescape(s) {
      TEXTAREA_ELEMENT.innerHTML = s;
      s = TEXTAREA_ELEMENT.textContent;
      TEXTAREA_ELEMENT.textContent = "";
      return s;
    }
    function shouldAdd(current, element) {
      return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current.localName;
    }
    function createElement(type, annotation) {
      var tagName = TAG_NAME[type];
      if (!tagName) {
        return null;
      }
      var element = window.document.createElement(tagName);
      var name = TAG_ANNOTATION[type];
      if (name && annotation) {
        element[name] = annotation.trim();
      }
      return element;
    }
    var rootDiv = window.document.createElement("div"),
        current = rootDiv,
        t,
        tagStack = [];
    while ((t = nextToken()) !== null) {
      if (t[0] === '<') {
        if (t[1] === "/") {
          if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
            tagStack.pop();
            current = current.parentNode;
          }
          continue;
        }
        var ts = parseTimeStamp(t.substr(1, t.length - 2));
        var node;
        if (ts) {
          node = window.document.createProcessingInstruction("timestamp", ts);
          current.appendChild(node);
          continue;
        }
        var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
        if (!m) {
          continue;
        }
        node = createElement(m[1], m[3]);
        if (!node) {
          continue;
        }
        if (!shouldAdd(current, node)) {
          continue;
        }
        if (m[2]) {
          var classes = m[2].split('.');
          classes.forEach(function (cl) {
            var bgColor = /^bg_/.test(cl);
            var colorName = bgColor ? cl.slice(3) : cl;
            if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {
              var propName = bgColor ? 'background-color' : 'color';
              var propValue = DEFAULT_COLOR_CLASS[colorName];
              node.style[propName] = propValue;
            }
          });
          node.className = classes.join(' ');
        }
        tagStack.push(m[1]);
        current.appendChild(node);
        current = node;
        continue;
      }
      current.appendChild(window.document.createTextNode(unescape(t)));
    }
    return rootDiv;
  }
  var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6], [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d], [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6], [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5], [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815], [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858], [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f], [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c], [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1], [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc], [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808], [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855], [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f], [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13], [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58], [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72], [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f], [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32], [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42], [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f], [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59], [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62], [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77], [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b], [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];
  function isStrongRTLChar(charCode) {
    for (var i = 0; i < strongRTLRanges.length; i++) {
      var currentRange = strongRTLRanges[i];
      if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
        return true;
      }
    }
    return false;
  }
  function determineBidi(cueDiv) {
    var nodeStack = [],
        text = "",
        charCode;
    if (!cueDiv || !cueDiv.childNodes) {
      return "ltr";
    }
    function pushNodes(nodeStack, node) {
      for (var i = node.childNodes.length - 1; i >= 0; i--) {
        nodeStack.push(node.childNodes[i]);
      }
    }
    function nextTextNode(nodeStack) {
      if (!nodeStack || !nodeStack.length) {
        return null;
      }
      var node = nodeStack.pop(),
          text = node.textContent || node.innerText;
      if (text) {
        var m = text.match(/^.*(\n|\r)/);
        if (m) {
          nodeStack.length = 0;
          return m[0];
        }
        return text;
      }
      if (node.tagName === "ruby") {
        return nextTextNode(nodeStack);
      }
      if (node.childNodes) {
        pushNodes(nodeStack, node);
        return nextTextNode(nodeStack);
      }
    }
    pushNodes(nodeStack, cueDiv);
    while (text = nextTextNode(nodeStack)) {
      for (var i = 0; i < text.length; i++) {
        charCode = text.charCodeAt(i);
        if (isStrongRTLChar(charCode)) {
          return "rtl";
        }
      }
    }
    return "ltr";
  }
  function computeLinePos(cue) {
    if (typeof cue.line === "number" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {
      return cue.line;
    }
    if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {
      return -1;
    }
    var track = cue.track,
        trackList = track.textTrackList,
        count = 0;
    for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
      if (trackList[i].mode === "showing") {
        count++;
      }
    }
    return ++count * -1;
  }
  function StyleBox() {}
  StyleBox.prototype.applyStyles = function (styles, div) {
    div = div || this.div;
    for (var prop in styles) {
      if (styles.hasOwnProperty(prop)) {
        div.style[prop] = styles[prop];
      }
    }
  };
  StyleBox.prototype.formatStyle = function (val, unit) {
    return val === 0 ? 0 : val + unit;
  };
  function CueStyleBox(window, cue, styleOptions) {
    StyleBox.call(this);
    this.cue = cue;
    this.cueDiv = parseContent(window, cue.text);
    var styles = {
      color: "rgba(255, 255, 255, 1)",
      backgroundColor: "rgba(0, 0, 0, 0.8)",
      position: "relative",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      display: "inline",
      writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
      unicodeBidi: "plaintext"
    };
    this.applyStyles(styles, this.cueDiv);
    this.div = window.document.createElement("div");
    styles = {
      direction: determineBidi(this.cueDiv),
      writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
      unicodeBidi: "plaintext",
      textAlign: cue.align === "middle" ? "center" : cue.align,
      font: styleOptions.font,
      whiteSpace: "pre-line",
      position: "absolute"
    };
    this.applyStyles(styles);
    this.div.appendChild(this.cueDiv);
    var textPos = 0;
    switch (cue.positionAlign) {
      case "start":
        textPos = cue.position;
        break;
      case "center":
        textPos = cue.position - cue.size / 2;
        break;
      case "end":
        textPos = cue.position - cue.size;
        break;
    }
    if (cue.vertical === "") {
      this.applyStyles({
        left: this.formatStyle(textPos, "%"),
        width: this.formatStyle(cue.size, "%")
      });
    } else {
      this.applyStyles({
        top: this.formatStyle(textPos, "%"),
        height: this.formatStyle(cue.size, "%")
      });
    }
    this.move = function (box) {
      this.applyStyles({
        top: this.formatStyle(box.top, "px"),
        bottom: this.formatStyle(box.bottom, "px"),
        left: this.formatStyle(box.left, "px"),
        right: this.formatStyle(box.right, "px"),
        height: this.formatStyle(box.height, "px"),
        width: this.formatStyle(box.width, "px")
      });
    };
  }
  CueStyleBox.prototype = _objCreate(StyleBox.prototype);
  CueStyleBox.prototype.constructor = CueStyleBox;
  function BoxPosition(obj) {
    var lh, height, width, top;
    if (obj.div) {
      height = obj.div.offsetHeight;
      width = obj.div.offsetWidth;
      top = obj.div.offsetTop;
      var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();
      obj = obj.div.getBoundingClientRect();
      lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;
    }
    this.left = obj.left;
    this.right = obj.right;
    this.top = obj.top || top;
    this.height = obj.height || height;
    this.bottom = obj.bottom || top + (obj.height || height);
    this.width = obj.width || width;
    this.lineHeight = lh !== undefined ? lh : obj.lineHeight;
  }
  BoxPosition.prototype.move = function (axis, toMove) {
    toMove = toMove !== undefined ? toMove : this.lineHeight;
    switch (axis) {
      case "+x":
        this.left += toMove;
        this.right += toMove;
        break;
      case "-x":
        this.left -= toMove;
        this.right -= toMove;
        break;
      case "+y":
        this.top += toMove;
        this.bottom += toMove;
        break;
      case "-y":
        this.top -= toMove;
        this.bottom -= toMove;
        break;
    }
  };
  BoxPosition.prototype.overlaps = function (b2) {
    return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;
  };
  BoxPosition.prototype.overlapsAny = function (boxes) {
    for (var i = 0; i < boxes.length; i++) {
      if (this.overlaps(boxes[i])) {
        return true;
      }
    }
    return false;
  };
  BoxPosition.prototype.within = function (container) {
    return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;
  };
  BoxPosition.prototype.overlapsOppositeAxis = function (container, axis) {
    switch (axis) {
      case "+x":
        return this.left < container.left;
      case "-x":
        return this.right > container.right;
      case "+y":
        return this.top < container.top;
      case "-y":
        return this.bottom > container.bottom;
    }
  };
  BoxPosition.prototype.intersectPercentage = function (b2) {
    var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),
        y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),
        intersectArea = x * y;
    return intersectArea / (this.height * this.width);
  };
  BoxPosition.prototype.toCSSCompatValues = function (reference) {
    return {
      top: this.top - reference.top,
      bottom: reference.bottom - this.bottom,
      left: this.left - reference.left,
      right: reference.right - this.right,
      height: this.height,
      width: this.width
    };
  };
  BoxPosition.getSimpleBoxPosition = function (obj) {
    var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
    var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
    var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;
    obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;
    var ret = {
      left: obj.left,
      right: obj.right,
      top: obj.top || top,
      height: obj.height || height,
      bottom: obj.bottom || top + (obj.height || height),
      width: obj.width || width
    };
    return ret;
  };
  function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {
    function findBestPosition(b, axis) {
      var bestPosition,
          specifiedPosition = new BoxPosition(b),
          percentage = 1;
      for (var i = 0; i < axis.length; i++) {
        while (b.overlapsOppositeAxis(containerBox, axis[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {
          b.move(axis[i]);
        }
        if (b.within(containerBox)) {
          return b;
        }
        var p = b.intersectPercentage(containerBox);
        if (percentage > p) {
          bestPosition = new BoxPosition(b);
          percentage = p;
        }
        b = new BoxPosition(specifiedPosition);
      }
      return bestPosition || specifiedPosition;
    }
    var boxPosition = new BoxPosition(styleBox),
        cue = styleBox.cue,
        linePos = computeLinePos(cue),
        axis = [];
    if (cue.snapToLines) {
      var size;
      switch (cue.vertical) {
        case "":
          axis = ["+y", "-y"];
          size = "height";
          break;
        case "rl":
          axis = ["+x", "-x"];
          size = "width";
          break;
        case "lr":
          axis = ["-x", "+x"];
          size = "width";
          break;
      }
      var step = boxPosition.lineHeight,
          position = step * Math.round(linePos),
          maxPosition = containerBox[size] + step,
          initialAxis = axis[0];
      if (Math.abs(position) > maxPosition) {
        position = position < 0 ? -1 : 1;
        position *= Math.ceil(maxPosition / step) * step;
      }
      if (linePos < 0) {
        position += cue.vertical === "" ? containerBox.height : containerBox.width;
        axis = axis.reverse();
      }
      boxPosition.move(initialAxis, position);
    } else {
      var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;
      switch (cue.lineAlign) {
        case "center":
          linePos -= calculatedPercentage / 2;
          break;
        case "end":
          linePos -= calculatedPercentage;
          break;
      }
      switch (cue.vertical) {
        case "":
          styleBox.applyStyles({
            top: styleBox.formatStyle(linePos, "%")
          });
          break;
        case "rl":
          styleBox.applyStyles({
            left: styleBox.formatStyle(linePos, "%")
          });
          break;
        case "lr":
          styleBox.applyStyles({
            right: styleBox.formatStyle(linePos, "%")
          });
          break;
      }
      axis = ["+y", "-x", "+x", "-y"];
      boxPosition = new BoxPosition(styleBox);
    }
    var bestPosition = findBestPosition(boxPosition, axis);
    styleBox.move(bestPosition.toCSSCompatValues(containerBox));
  }
  function WebVTT$1() {
  }
  WebVTT$1.StringDecoder = function () {
    return {
      decode: function decode(data) {
        if (!data) {
          return "";
        }
        if (typeof data !== "string") {
          throw new Error("Error - expected string data.");
        }
        return decodeURIComponent(encodeURIComponent(data));
      }
    };
  };
  WebVTT$1.convertCueToDOMTree = function (window, cuetext) {
    if (!window || !cuetext) {
      return null;
    }
    return parseContent(window, cuetext);
  };
  var FONT_SIZE_PERCENT = 0.05;
  var FONT_STYLE = "sans-serif";
  var CUE_BACKGROUND_PADDING = "1.5%";
  WebVTT$1.processCues = function (window, cues, overlay) {
    if (!window || !cues || !overlay) {
      return null;
    }
    while (overlay.firstChild) {
      overlay.removeChild(overlay.firstChild);
    }
    var paddedOverlay = window.document.createElement("div");
    paddedOverlay.style.position = "absolute";
    paddedOverlay.style.left = "0";
    paddedOverlay.style.right = "0";
    paddedOverlay.style.top = "0";
    paddedOverlay.style.bottom = "0";
    paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
    overlay.appendChild(paddedOverlay);
    function shouldCompute(cues) {
      for (var i = 0; i < cues.length; i++) {
        if (cues[i].hasBeenReset || !cues[i].displayState) {
          return true;
        }
      }
      return false;
    }
    if (!shouldCompute(cues)) {
      for (var i = 0; i < cues.length; i++) {
        paddedOverlay.appendChild(cues[i].displayState);
      }
      return;
    }
    var boxPositions = [],
        containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),
        fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
    var styleOptions = {
      font: fontSize + "px " + FONT_STYLE
    };
    (function () {
      var styleBox, cue;
      for (var i = 0; i < cues.length; i++) {
        cue = cues[i];
        styleBox = new CueStyleBox(window, cue, styleOptions);
        paddedOverlay.appendChild(styleBox.div);
        moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);
        cue.displayState = styleBox.div;
        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
      }
    })();
  };
  WebVTT$1.Parser = function (window, vttjs, decoder) {
    if (!decoder) {
      decoder = vttjs;
      vttjs = {};
    }
    if (!vttjs) {
      vttjs = {};
    }
    this.window = window;
    this.vttjs = vttjs;
    this.state = "INITIAL";
    this.buffer = "";
    this.decoder = decoder || new TextDecoder("utf8");
    this.regionList = [];
  };
  WebVTT$1.Parser.prototype = {
    reportOrThrowError: function reportOrThrowError(e) {
      if (e instanceof ParsingError) {
        this.onparsingerror && this.onparsingerror(e);
      } else {
        throw e;
      }
    },
    parse: function parse(data) {
      var self = this;
      if (data) {
        self.buffer += self.decoder.decode(data, {
          stream: true
        });
      }
      function collectNextLine() {
        var buffer = self.buffer;
        var pos = 0;
        while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
          ++pos;
        }
        var line = buffer.substr(0, pos);
        if (buffer[pos] === '\r') {
          ++pos;
        }
        if (buffer[pos] === '\n') {
          ++pos;
        }
        self.buffer = buffer.substr(pos);
        return line;
      }
      function parseRegion(input) {
        var settings = new Settings();
        parseOptions(input, function (k, v) {
          switch (k) {
            case "id":
              settings.set(k, v);
              break;
            case "width":
              settings.percent(k, v);
              break;
            case "lines":
              settings.integer(k, v);
              break;
            case "regionanchor":
            case "viewportanchor":
              var xy = v.split(',');
              if (xy.length !== 2) {
                break;
              }
              var anchor = new Settings();
              anchor.percent("x", xy[0]);
              anchor.percent("y", xy[1]);
              if (!anchor.has("x") || !anchor.has("y")) {
                break;
              }
              settings.set(k + "X", anchor.get("x"));
              settings.set(k + "Y", anchor.get("y"));
              break;
            case "scroll":
              settings.alt(k, v, ["up"]);
              break;
          }
        }, /=/, /\s/);
        if (settings.has("id")) {
          var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();
          region.width = settings.get("width", 100);
          region.lines = settings.get("lines", 3);
          region.regionAnchorX = settings.get("regionanchorX", 0);
          region.regionAnchorY = settings.get("regionanchorY", 100);
          region.viewportAnchorX = settings.get("viewportanchorX", 0);
          region.viewportAnchorY = settings.get("viewportanchorY", 100);
          region.scroll = settings.get("scroll", "");
          self.onregion && self.onregion(region);
          self.regionList.push({
            id: settings.get("id"),
            region: region
          });
        }
      }
      function parseTimestampMap(input) {
        var settings = new Settings();
        parseOptions(input, function (k, v) {
          switch (k) {
            case "MPEGT":
              settings.integer(k + 'S', v);
              break;
            case "LOCA":
              settings.set(k + 'L', parseTimeStamp(v));
              break;
          }
        }, /[^\d]:/, /,/);
        self.ontimestampmap && self.ontimestampmap({
          "MPEGTS": settings.get("MPEGTS"),
          "LOCAL": settings.get("LOCAL")
        });
      }
      function parseHeader(input) {
        if (input.match(/X-TIMESTAMP-MAP/)) {
          parseOptions(input, function (k, v) {
            switch (k) {
              case "X-TIMESTAMP-MAP":
                parseTimestampMap(v);
                break;
            }
          }, /=/);
        } else {
          parseOptions(input, function (k, v) {
            switch (k) {
              case "Region":
                parseRegion(v);
                break;
            }
          }, /:/);
        }
      }
      try {
        var line;
        if (self.state === "INITIAL") {
          if (!/\r\n|\n/.test(self.buffer)) {
            return this;
          }
          line = collectNextLine();
          var m = line.match(/^WEBVTT([ \t].*)?$/);
          if (!m || !m[0]) {
            throw new ParsingError(ParsingError.Errors.BadSignature);
          }
          self.state = "HEADER";
        }
        var alreadyCollectedLine = false;
        while (self.buffer) {
          if (!/\r\n|\n/.test(self.buffer)) {
            return this;
          }
          if (!alreadyCollectedLine) {
            line = collectNextLine();
          } else {
            alreadyCollectedLine = false;
          }
          switch (self.state) {
            case "HEADER":
              if (/:/.test(line)) {
                parseHeader(line);
              } else if (!line) {
                self.state = "ID";
              }
              continue;
            case "NOTE":
              if (!line) {
                self.state = "ID";
              }
              continue;
            case "ID":
              if (/^NOTE($|[ \t])/.test(line)) {
                self.state = "NOTE";
                break;
              }
              if (!line) {
                continue;
              }
              self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
              try {
                self.cue.align = "center";
              } catch (e) {
                self.cue.align = "middle";
              }
              self.state = "CUE";
              if (line.indexOf("-->") === -1) {
                self.cue.id = line;
                continue;
              }
            case "CUE":
              try {
                parseCue(line, self.cue, self.regionList);
              } catch (e) {
                self.reportOrThrowError(e);
                self.cue = null;
                self.state = "BADCUE";
                continue;
              }
              self.state = "CUETEXT";
              continue;
            case "CUETEXT":
              var hasSubstring = line.indexOf("-->") !== -1;
              if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                self.oncue && self.oncue(self.cue);
                self.cue = null;
                self.state = "ID";
                continue;
              }
              if (self.cue.text) {
                self.cue.text += "\n";
              }
              self.cue.text += line.replace(/\u2028/g, '\n').replace(/u2029/g, '\n');
              continue;
            case "BADCUE":
              if (!line) {
                self.state = "ID";
              }
              continue;
          }
        }
      } catch (e) {
        self.reportOrThrowError(e);
        if (self.state === "CUETEXT" && self.cue && self.oncue) {
          self.oncue(self.cue);
        }
        self.cue = null;
        self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
      }
      return this;
    },
    flush: function flush() {
      var self = this;
      try {
        self.buffer += self.decoder.decode();
        if (self.cue || self.state === "HEADER") {
          self.buffer += "\n\n";
          self.parse();
        }
        if (self.state === "INITIAL") {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }
      } catch (e) {
        self.reportOrThrowError(e);
      }
      self.onflush && self.onflush();
      return this;
    }
  };
  var vtt = WebVTT$1;
  var autoKeyword = "auto";
  var directionSetting = {
    "": 1,
    "lr": 1,
    "rl": 1
  };
  var alignSetting = {
    "start": 1,
    "center": 1,
    "end": 1,
    "left": 1,
    "right": 1,
    "auto": 1,
    "line-left": 1,
    "line-right": 1
  };
  function findDirectionSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }
  function findAlignSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }
  function VTTCue(startTime, endTime, text) {
    this.hasBeenReset = false;
    var _id = "";
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = "";
    var _snapToLines = true;
    var _line = "auto";
    var _lineAlign = "start";
    var _position = "auto";
    var _positionAlign = "auto";
    var _size = 100;
    var _align = "center";
    Object.defineProperties(this, {
      "id": {
        enumerable: true,
        get: function get() {
          return _id;
        },
        set: function set(value) {
          _id = "" + value;
        }
      },
      "pauseOnExit": {
        enumerable: true,
        get: function get() {
          return _pauseOnExit;
        },
        set: function set(value) {
          _pauseOnExit = !!value;
        }
      },
      "startTime": {
        enumerable: true,
        get: function get() {
          return _startTime;
        },
        set: function set(value) {
          if (typeof value !== "number") {
            throw new TypeError("Start time must be set to a number.");
          }
          _startTime = value;
          this.hasBeenReset = true;
        }
      },
      "endTime": {
        enumerable: true,
        get: function get() {
          return _endTime;
        },
        set: function set(value) {
          if (typeof value !== "number") {
            throw new TypeError("End time must be set to a number.");
          }
          _endTime = value;
          this.hasBeenReset = true;
        }
      },
      "text": {
        enumerable: true,
        get: function get() {
          return _text;
        },
        set: function set(value) {
          _text = "" + value;
          this.hasBeenReset = true;
        }
      },
      "region": {
        enumerable: true,
        get: function get() {
          return _region;
        },
        set: function set(value) {
          _region = value;
          this.hasBeenReset = true;
        }
      },
      "vertical": {
        enumerable: true,
        get: function get() {
          return _vertical;
        },
        set: function set(value) {
          var setting = findDirectionSetting(value);
          if (setting === false) {
            throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
          }
          _vertical = setting;
          this.hasBeenReset = true;
        }
      },
      "snapToLines": {
        enumerable: true,
        get: function get() {
          return _snapToLines;
        },
        set: function set(value) {
          _snapToLines = !!value;
          this.hasBeenReset = true;
        }
      },
      "line": {
        enumerable: true,
        get: function get() {
          return _line;
        },
        set: function set(value) {
          if (typeof value !== "number" && value !== autoKeyword) {
            throw new SyntaxError("Line: an invalid number or illegal string was specified.");
          }
          _line = value;
          this.hasBeenReset = true;
        }
      },
      "lineAlign": {
        enumerable: true,
        get: function get() {
          return _lineAlign;
        },
        set: function set(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            console.warn("lineAlign: an invalid or illegal string was specified.");
          } else {
            _lineAlign = setting;
            this.hasBeenReset = true;
          }
        }
      },
      "position": {
        enumerable: true,
        get: function get() {
          return _position;
        },
        set: function set(value) {
          if (value < 0 || value > 100) {
            throw new Error("Position must be between 0 and 100.");
          }
          _position = value;
          this.hasBeenReset = true;
        }
      },
      "positionAlign": {
        enumerable: true,
        get: function get() {
          return _positionAlign;
        },
        set: function set(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            console.warn("positionAlign: an invalid or illegal string was specified.");
          } else {
            _positionAlign = setting;
            this.hasBeenReset = true;
          }
        }
      },
      "size": {
        enumerable: true,
        get: function get() {
          return _size;
        },
        set: function set(value) {
          if (value < 0 || value > 100) {
            throw new Error("Size must be between 0 and 100.");
          }
          _size = value;
          this.hasBeenReset = true;
        }
      },
      "align": {
        enumerable: true,
        get: function get() {
          return _align;
        },
        set: function set(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
          }
          _align = setting;
          this.hasBeenReset = true;
        }
      }
    });
    this.displayState = undefined;
  }
  VTTCue.prototype.getCueAsHTML = function () {
    return WebVTT.convertCueToDOMTree(window, this.text);
  };
  var vttcue = VTTCue;
  var scrollSetting = {
    "": true,
    "up": true
  };
  function findScrollSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var scroll = scrollSetting[value.toLowerCase()];
    return scroll ? value.toLowerCase() : false;
  }
  function isValidPercentValue(value) {
    return typeof value === "number" && value >= 0 && value <= 100;
  }
  function VTTRegion() {
    var _width = 100;
    var _lines = 3;
    var _regionAnchorX = 0;
    var _regionAnchorY = 100;
    var _viewportAnchorX = 0;
    var _viewportAnchorY = 100;
    var _scroll = "";
    Object.defineProperties(this, {
      "width": {
        enumerable: true,
        get: function get() {
          return _width;
        },
        set: function set(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("Width must be between 0 and 100.");
          }
          _width = value;
        }
      },
      "lines": {
        enumerable: true,
        get: function get() {
          return _lines;
        },
        set: function set(value) {
          if (typeof value !== "number") {
            throw new TypeError("Lines must be set to a number.");
          }
          _lines = value;
        }
      },
      "regionAnchorY": {
        enumerable: true,
        get: function get() {
          return _regionAnchorY;
        },
        set: function set(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("RegionAnchorX must be between 0 and 100.");
          }
          _regionAnchorY = value;
        }
      },
      "regionAnchorX": {
        enumerable: true,
        get: function get() {
          return _regionAnchorX;
        },
        set: function set(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("RegionAnchorY must be between 0 and 100.");
          }
          _regionAnchorX = value;
        }
      },
      "viewportAnchorY": {
        enumerable: true,
        get: function get() {
          return _viewportAnchorY;
        },
        set: function set(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("ViewportAnchorY must be between 0 and 100.");
          }
          _viewportAnchorY = value;
        }
      },
      "viewportAnchorX": {
        enumerable: true,
        get: function get() {
          return _viewportAnchorX;
        },
        set: function set(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("ViewportAnchorX must be between 0 and 100.");
          }
          _viewportAnchorX = value;
        }
      },
      "scroll": {
        enumerable: true,
        get: function get() {
          return _scroll;
        },
        set: function set(value) {
          var setting = findScrollSetting(value);
          if (setting === false) {
            console.warn("Scroll: an invalid or illegal string was specified.");
          } else {
            _scroll = setting;
          }
        }
      }
    });
  }
  var vttregion = VTTRegion;
  var browserIndex = createCommonjsModule(function (module) {
    var vttjs = module.exports = {
      WebVTT: vtt,
      VTTCue: vttcue,
      VTTRegion: vttregion
    };
    window_1.vttjs = vttjs;
    window_1.WebVTT = vttjs.WebVTT;
    var cueShim = vttjs.VTTCue;
    var regionShim = vttjs.VTTRegion;
    var nativeVTTCue = window_1.VTTCue;
    var nativeVTTRegion = window_1.VTTRegion;
    vttjs.shim = function () {
      window_1.VTTCue = cueShim;
      window_1.VTTRegion = regionShim;
    };
    vttjs.restore = function () {
      window_1.VTTCue = nativeVTTCue;
      window_1.VTTRegion = nativeVTTRegion;
    };
    if (!window_1.VTTCue) {
      vttjs.shim();
    }
  });
  browserIndex.WebVTT;
  browserIndex.VTTCue;
  browserIndex.VTTRegion;
  function createTrackHelper(self, kind, label, language, options) {
    if (options === void 0) {
      options = {};
    }
    var tracks = self.textTracks();
    options.kind = kind;
    if (label) {
      options.label = label;
    }
    if (language) {
      options.language = language;
    }
    options.tech = self;
    var track = new ALL.text.TrackClass(options);
    tracks.addTrack(track);
    return track;
  }
  var Tech = function (_Component) {
    inheritsLoose(Tech, _Component);
    function Tech(options, ready) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      if (ready === void 0) {
        ready = function ready() {};
      }
      options.reportTouchActivity = false;
      _this = _Component.call(this, null, options, ready) || this;
      _this.onDurationChange_ = function (e) {
        return _this.onDurationChange(e);
      };
      _this.trackProgress_ = function (e) {
        return _this.trackProgress(e);
      };
      _this.trackCurrentTime_ = function (e) {
        return _this.trackCurrentTime(e);
      };
      _this.stopTrackingCurrentTime_ = function (e) {
        return _this.stopTrackingCurrentTime(e);
      };
      _this.disposeSourceHandler_ = function (e) {
        return _this.disposeSourceHandler(e);
      };
      _this.hasStarted_ = false;
      _this.on('playing', function () {
        this.hasStarted_ = true;
      });
      _this.on('loadstart', function () {
        this.hasStarted_ = false;
      });
      ALL.names.forEach(function (name) {
        var props = ALL[name];
        if (options && options[props.getterName]) {
          _this[props.privateName] = options[props.getterName];
        }
      });
      if (!_this.featuresProgressEvents) {
        _this.manualProgressOn();
      }
      if (!_this.featuresTimeupdateEvents) {
        _this.manualTimeUpdatesOn();
      }
      ['Text', 'Audio', 'Video'].forEach(function (track) {
        if (options["native" + track + "Tracks"] === false) {
          _this["featuresNative" + track + "Tracks"] = false;
        }
      });
      if (options.nativeCaptions === false || options.nativeTextTracks === false) {
        _this.featuresNativeTextTracks = false;
      } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
        _this.featuresNativeTextTracks = true;
      }
      if (!_this.featuresNativeTextTracks) {
        _this.emulateTextTracks();
      }
      _this.preloadTextTracks = options.preloadTextTracks !== false;
      _this.autoRemoteTextTracks_ = new ALL.text.ListClass();
      _this.initTrackListeners();
      if (!options.nativeControlsForTouch) {
        _this.emitTapEvents();
      }
      if (_this.constructor) {
        _this.name_ = _this.constructor.name || 'Unknown Tech';
      }
      return _this;
    }
    var _proto = Tech.prototype;
    _proto.triggerSourceset = function triggerSourceset(src) {
      var _this2 = this;
      if (!this.isReady_) {
        this.one('ready', function () {
          return _this2.setTimeout(function () {
            return _this2.triggerSourceset(src);
          }, 1);
        });
      }
      this.trigger({
        src: src,
        type: 'sourceset'
      });
    }
    ;
    _proto.manualProgressOn = function manualProgressOn() {
      this.on('durationchange', this.onDurationChange_);
      this.manualProgress = true;
      this.one('ready', this.trackProgress_);
    }
    ;
    _proto.manualProgressOff = function manualProgressOff() {
      this.manualProgress = false;
      this.stopTrackingProgress();
      this.off('durationchange', this.onDurationChange_);
    }
    ;
    _proto.trackProgress = function trackProgress(event) {
      this.stopTrackingProgress();
      this.progressInterval = this.setInterval(bind(this, function () {
        var numBufferedPercent = this.bufferedPercent();
        if (this.bufferedPercent_ !== numBufferedPercent) {
          this.trigger('progress');
        }
        this.bufferedPercent_ = numBufferedPercent;
        if (numBufferedPercent === 1) {
          this.stopTrackingProgress();
        }
      }), 500);
    }
    ;
    _proto.onDurationChange = function onDurationChange(event) {
      this.duration_ = this.duration();
    }
    ;
    _proto.buffered = function buffered() {
      return createTimeRanges(0, 0);
    }
    ;
    _proto.bufferedPercent = function bufferedPercent$1() {
      return bufferedPercent(this.buffered(), this.duration_);
    }
    ;
    _proto.stopTrackingProgress = function stopTrackingProgress() {
      this.clearInterval(this.progressInterval);
    }
    ;
    _proto.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
      this.manualTimeUpdates = true;
      this.on('play', this.trackCurrentTime_);
      this.on('pause', this.stopTrackingCurrentTime_);
    }
    ;
    _proto.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
      this.manualTimeUpdates = false;
      this.stopTrackingCurrentTime();
      this.off('play', this.trackCurrentTime_);
      this.off('pause', this.stopTrackingCurrentTime_);
    }
    ;
    _proto.trackCurrentTime = function trackCurrentTime() {
      if (this.currentTimeInterval) {
        this.stopTrackingCurrentTime();
      }
      this.currentTimeInterval = this.setInterval(function () {
        this.trigger({
          type: 'timeupdate',
          target: this,
          manuallyTriggered: true
        });
      }, 250);
    }
    ;
    _proto.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
      this.clearInterval(this.currentTimeInterval);
      this.trigger({
        type: 'timeupdate',
        target: this,
        manuallyTriggered: true
      });
    }
    ;
    _proto.dispose = function dispose() {
      this.clearTracks(NORMAL.names);
      if (this.manualProgress) {
        this.manualProgressOff();
      }
      if (this.manualTimeUpdates) {
        this.manualTimeUpdatesOff();
      }
      _Component.prototype.dispose.call(this);
    }
    ;
    _proto.clearTracks = function clearTracks(types) {
      var _this3 = this;
      types = [].concat(types);
      types.forEach(function (type) {
        var list = _this3[type + "Tracks"]() || [];
        var i = list.length;
        while (i--) {
          var track = list[i];
          if (type === 'text') {
            _this3.removeRemoteTextTrack(track);
          }
          list.removeTrack(track);
        }
      });
    }
    ;
    _proto.cleanupAutoTextTracks = function cleanupAutoTextTracks() {
      var list = this.autoRemoteTextTracks_ || [];
      var i = list.length;
      while (i--) {
        var track = list[i];
        this.removeRemoteTextTrack(track);
      }
    }
    ;
    _proto.reset = function reset() {}
    ;
    _proto.crossOrigin = function crossOrigin() {}
    ;
    _proto.setCrossOrigin = function setCrossOrigin() {}
    ;
    _proto.error = function error(err) {
      if (err !== undefined) {
        this.error_ = new MediaError(err);
        this.trigger('error');
      }
      return this.error_;
    }
    ;
    _proto.played = function played() {
      if (this.hasStarted_) {
        return createTimeRanges(0, 0);
      }
      return createTimeRanges();
    }
    ;
    _proto.play = function play() {}
    ;
    _proto.setScrubbing = function setScrubbing() {}
    ;
    _proto.scrubbing = function scrubbing() {}
    ;
    _proto.setCurrentTime = function setCurrentTime() {
      if (this.manualTimeUpdates) {
        this.trigger({
          type: 'timeupdate',
          target: this,
          manuallyTriggered: true
        });
      }
    }
    ;
    _proto.initTrackListeners = function initTrackListeners() {
      var _this4 = this;
      NORMAL.names.forEach(function (name) {
        var props = NORMAL[name];
        var trackListChanges = function trackListChanges() {
          _this4.trigger(name + "trackchange");
        };
        var tracks = _this4[props.getterName]();
        tracks.addEventListener('removetrack', trackListChanges);
        tracks.addEventListener('addtrack', trackListChanges);
        _this4.on('dispose', function () {
          tracks.removeEventListener('removetrack', trackListChanges);
          tracks.removeEventListener('addtrack', trackListChanges);
        });
      });
    }
    ;
    _proto.addWebVttScript_ = function addWebVttScript_() {
      var _this5 = this;
      if (window.WebVTT) {
        return;
      }
      if (document.body.contains(this.el())) {
        if (!this.options_['vtt.js'] && isPlain(browserIndex) && Object.keys(browserIndex).length > 0) {
          this.trigger('vttjsloaded');
          return;
        }
        var script = document.createElement('script');
        script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js';
        script.onload = function () {
          _this5.trigger('vttjsloaded');
        };
        script.onerror = function () {
          _this5.trigger('vttjserror');
        };
        this.on('dispose', function () {
          script.onload = null;
          script.onerror = null;
        });
        window.WebVTT = true;
        this.el().parentNode.appendChild(script);
      } else {
        this.ready(this.addWebVttScript_);
      }
    }
    ;
    _proto.emulateTextTracks = function emulateTextTracks() {
      var _this6 = this;
      var tracks = this.textTracks();
      var remoteTracks = this.remoteTextTracks();
      var handleAddTrack = function handleAddTrack(e) {
        return tracks.addTrack(e.track);
      };
      var handleRemoveTrack = function handleRemoveTrack(e) {
        return tracks.removeTrack(e.track);
      };
      remoteTracks.on('addtrack', handleAddTrack);
      remoteTracks.on('removetrack', handleRemoveTrack);
      this.addWebVttScript_();
      var updateDisplay = function updateDisplay() {
        return _this6.trigger('texttrackchange');
      };
      var textTracksChanges = function textTracksChanges() {
        updateDisplay();
        for (var i = 0; i < tracks.length; i++) {
          var track = tracks[i];
          track.removeEventListener('cuechange', updateDisplay);
          if (track.mode === 'showing') {
            track.addEventListener('cuechange', updateDisplay);
          }
        }
      };
      textTracksChanges();
      tracks.addEventListener('change', textTracksChanges);
      tracks.addEventListener('addtrack', textTracksChanges);
      tracks.addEventListener('removetrack', textTracksChanges);
      this.on('dispose', function () {
        remoteTracks.off('addtrack', handleAddTrack);
        remoteTracks.off('removetrack', handleRemoveTrack);
        tracks.removeEventListener('change', textTracksChanges);
        tracks.removeEventListener('addtrack', textTracksChanges);
        tracks.removeEventListener('removetrack', textTracksChanges);
        for (var i = 0; i < tracks.length; i++) {
          var track = tracks[i];
          track.removeEventListener('cuechange', updateDisplay);
        }
      });
    }
    ;
    _proto.addTextTrack = function addTextTrack(kind, label, language) {
      if (!kind) {
        throw new Error('TextTrack kind is required but was not provided');
      }
      return createTrackHelper(this, kind, label, language);
    }
    ;
    _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {
      var track = mergeOptions$3(options, {
        tech: this
      });
      return new REMOTE.remoteTextEl.TrackClass(track);
    }
    ;
    _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
      var _this7 = this;
      if (options === void 0) {
        options = {};
      }
      var htmlTrackElement = this.createRemoteTextTrack(options);
      if (manualCleanup !== true && manualCleanup !== false) {
        log$1.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
        manualCleanup = true;
      }
      this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
      this.remoteTextTracks().addTrack(htmlTrackElement.track);
      if (manualCleanup !== true) {
        this.ready(function () {
          return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
        });
      }
      return htmlTrackElement;
    }
    ;
    _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
      var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);
      this.remoteTextTrackEls().removeTrackElement_(trackElement);
      this.remoteTextTracks().removeTrack(track);
      this.autoRemoteTextTracks_.removeTrack(track);
    }
    ;
    _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
      return {};
    }
    ;
    _proto.requestPictureInPicture = function requestPictureInPicture() {
      var PromiseClass = this.options_.Promise || window.Promise;
      if (PromiseClass) {
        return PromiseClass.reject();
      }
    }
    ;
    _proto.disablePictureInPicture = function disablePictureInPicture() {
      return true;
    }
    ;
    _proto.setDisablePictureInPicture = function setDisablePictureInPicture() {}
    ;
    _proto.setPoster = function setPoster() {}
    ;
    _proto.playsinline = function playsinline() {}
    ;
    _proto.setPlaysinline = function setPlaysinline() {}
    ;
    _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks() {}
    ;
    _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks() {}
    ;
    _proto.canPlayType = function canPlayType() {
      return '';
    }
    ;
    Tech.canPlayType = function canPlayType() {
      return '';
    }
    ;
    Tech.canPlaySource = function canPlaySource(srcObj, options) {
      return Tech.canPlayType(srcObj.type);
    }
    ;
    Tech.isTech = function isTech(component) {
      return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
    }
    ;
    Tech.registerTech = function registerTech(name, tech) {
      if (!Tech.techs_) {
        Tech.techs_ = {};
      }
      if (!Tech.isTech(tech)) {
        throw new Error("Tech " + name + " must be a Tech");
      }
      if (!Tech.canPlayType) {
        throw new Error('Techs must have a static canPlayType method on them');
      }
      if (!Tech.canPlaySource) {
        throw new Error('Techs must have a static canPlaySource method on them');
      }
      name = toTitleCase$1(name);
      Tech.techs_[name] = tech;
      Tech.techs_[toLowerCase(name)] = tech;
      if (name !== 'Tech') {
        Tech.defaultTechOrder_.push(name);
      }
      return tech;
    }
    ;
    Tech.getTech = function getTech(name) {
      if (!name) {
        return;
      }
      if (Tech.techs_ && Tech.techs_[name]) {
        return Tech.techs_[name];
      }
      name = toTitleCase$1(name);
      if (window && window.videojs && window.videojs[name]) {
        log$1.warn("The " + name + " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)");
        return window.videojs[name];
      }
    };
    return Tech;
  }(Component$1);
  ALL.names.forEach(function (name) {
    var props = ALL[name];
    Tech.prototype[props.getterName] = function () {
      this[props.privateName] = this[props.privateName] || new props.ListClass();
      return this[props.privateName];
    };
  });
  Tech.prototype.featuresVolumeControl = true;
  Tech.prototype.featuresMuteControl = true;
  Tech.prototype.featuresFullscreenResize = false;
  Tech.prototype.featuresPlaybackRate = false;
  Tech.prototype.featuresProgressEvents = false;
  Tech.prototype.featuresSourceset = false;
  Tech.prototype.featuresTimeupdateEvents = false;
  Tech.prototype.featuresNativeTextTracks = false;
  Tech.withSourceHandlers = function (_Tech) {
    _Tech.registerSourceHandler = function (handler, index) {
      var handlers = _Tech.sourceHandlers;
      if (!handlers) {
        handlers = _Tech.sourceHandlers = [];
      }
      if (index === undefined) {
        index = handlers.length;
      }
      handlers.splice(index, 0, handler);
    };
    _Tech.canPlayType = function (type) {
      var handlers = _Tech.sourceHandlers || [];
      var can;
      for (var i = 0; i < handlers.length; i++) {
        can = handlers[i].canPlayType(type);
        if (can) {
          return can;
        }
      }
      return '';
    };
    _Tech.selectSourceHandler = function (source, options) {
      var handlers = _Tech.sourceHandlers || [];
      var can;
      for (var i = 0; i < handlers.length; i++) {
        can = handlers[i].canHandleSource(source, options);
        if (can) {
          return handlers[i];
        }
      }
      return null;
    };
    _Tech.canPlaySource = function (srcObj, options) {
      var sh = _Tech.selectSourceHandler(srcObj, options);
      if (sh) {
        return sh.canHandleSource(srcObj, options);
      }
      return '';
    };
    var deferrable = ['seekable', 'seeking', 'duration'];
    deferrable.forEach(function (fnName) {
      var originalFn = this[fnName];
      if (typeof originalFn !== 'function') {
        return;
      }
      this[fnName] = function () {
        if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
          return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
        }
        return originalFn.apply(this, arguments);
      };
    }, _Tech.prototype);
    _Tech.prototype.setSource = function (source) {
      var sh = _Tech.selectSourceHandler(source, this.options_);
      if (!sh) {
        if (_Tech.nativeSourceHandler) {
          sh = _Tech.nativeSourceHandler;
        } else {
          log$1.error('No source handler found for the current source.');
        }
      }
      this.disposeSourceHandler();
      this.off('dispose', this.disposeSourceHandler_);
      if (sh !== _Tech.nativeSourceHandler) {
        this.currentSource_ = source;
      }
      this.sourceHandler_ = sh.handleSource(source, this, this.options_);
      this.one('dispose', this.disposeSourceHandler_);
    };
    _Tech.prototype.disposeSourceHandler = function () {
      if (this.currentSource_) {
        this.clearTracks(['audio', 'video']);
        this.currentSource_ = null;
      }
      this.cleanupAutoTextTracks();
      if (this.sourceHandler_) {
        if (this.sourceHandler_.dispose) {
          this.sourceHandler_.dispose();
        }
        this.sourceHandler_ = null;
      }
    };
  };
  Component$1.registerComponent('Tech', Tech);
  Tech.registerTech('Tech', Tech);
  Tech.defaultTechOrder_ = [];
  var middlewares = {};
  var middlewareInstances = {};
  var TERMINATOR = {};
  function use(type, middleware) {
    middlewares[type] = middlewares[type] || [];
    middlewares[type].push(middleware);
  }
  function setSource(player, src, next) {
    player.setTimeout(function () {
      return setSourceHelper(src, middlewares[src.type], next, player);
    }, 1);
  }
  function setTech(middleware, tech) {
    middleware.forEach(function (mw) {
      return mw.setTech && mw.setTech(tech);
    });
  }
  function get(middleware, tech, method) {
    return middleware.reduceRight(middlewareIterator(method), tech[method]());
  }
  function set(middleware, tech, method, arg) {
    return tech[method](middleware.reduce(middlewareIterator(method), arg));
  }
  function mediate(middleware, tech, method, arg) {
    if (arg === void 0) {
      arg = null;
    }
    var callMethod = 'call' + toTitleCase$1(method);
    var middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);
    var terminated = middlewareValue === TERMINATOR;
    var returnValue = terminated ? null : tech[method](middlewareValue);
    executeRight(middleware, method, returnValue, terminated);
    return returnValue;
  }
  var allowedGetters = {
    buffered: 1,
    currentTime: 1,
    duration: 1,
    muted: 1,
    played: 1,
    paused: 1,
    seekable: 1,
    volume: 1,
    ended: 1
  };
  var allowedSetters = {
    setCurrentTime: 1,
    setMuted: 1,
    setVolume: 1
  };
  var allowedMediators = {
    play: 1,
    pause: 1
  };
  function middlewareIterator(method) {
    return function (value, mw) {
      if (value === TERMINATOR) {
        return TERMINATOR;
      }
      if (mw[method]) {
        return mw[method](value);
      }
      return value;
    };
  }
  function executeRight(mws, method, value, terminated) {
    for (var i = mws.length - 1; i >= 0; i--) {
      var mw = mws[i];
      if (mw[method]) {
        mw[method](terminated, value);
      }
    }
  }
  function clearCacheForPlayer(player) {
    middlewareInstances[player.id()] = null;
  }
  function getOrCreateFactory(player, mwFactory) {
    var mws = middlewareInstances[player.id()];
    var mw = null;
    if (mws === undefined || mws === null) {
      mw = mwFactory(player);
      middlewareInstances[player.id()] = [[mwFactory, mw]];
      return mw;
    }
    for (var i = 0; i < mws.length; i++) {
      var _mws$i = mws[i],
          mwf = _mws$i[0],
          mwi = _mws$i[1];
      if (mwf !== mwFactory) {
        continue;
      }
      mw = mwi;
    }
    if (mw === null) {
      mw = mwFactory(player);
      mws.push([mwFactory, mw]);
    }
    return mw;
  }
  function setSourceHelper(src, middleware, next, player, acc, lastRun) {
    if (src === void 0) {
      src = {};
    }
    if (middleware === void 0) {
      middleware = [];
    }
    if (acc === void 0) {
      acc = [];
    }
    if (lastRun === void 0) {
      lastRun = false;
    }
    var _middleware = middleware,
        mwFactory = _middleware[0],
        mwrest = _middleware.slice(1);
    if (typeof mwFactory === 'string') {
      setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);
    } else if (mwFactory) {
      var mw = getOrCreateFactory(player, mwFactory);
      if (!mw.setSource) {
        acc.push(mw);
        return setSourceHelper(src, mwrest, next, player, acc, lastRun);
      }
      mw.setSource(assign({}, src), function (err, _src) {
        if (err) {
          return setSourceHelper(src, mwrest, next, player, acc, lastRun);
        }
        acc.push(mw);
        setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
      });
    } else if (mwrest.length) {
      setSourceHelper(src, mwrest, next, player, acc, lastRun);
    } else if (lastRun) {
      next(src, acc);
    } else {
      setSourceHelper(src, middlewares['*'], next, player, acc, true);
    }
  }
  var MimetypesKind = {
    opus: 'video/ogg',
    ogv: 'video/ogg',
    mp4: 'video/mp4',
    mov: 'video/mp4',
    m4v: 'video/mp4',
    mkv: 'video/x-matroska',
    m4a: 'audio/mp4',
    mp3: 'audio/mpeg',
    aac: 'audio/aac',
    caf: 'audio/x-caf',
    flac: 'audio/flac',
    oga: 'audio/ogg',
    wav: 'audio/wav',
    m3u8: 'application/x-mpegURL',
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    gif: 'image/gif',
    png: 'image/png',
    svg: 'image/svg+xml',
    webp: 'image/webp'
  };
  var getMimetype = function getMimetype(src) {
    if (src === void 0) {
      src = '';
    }
    var ext = getFileExtension(src);
    var mimetype = MimetypesKind[ext.toLowerCase()];
    return mimetype || '';
  };
  var findMimetype = function findMimetype(player, src) {
    if (!src) {
      return '';
    }
    if (player.cache_.source.src === src && player.cache_.source.type) {
      return player.cache_.source.type;
    }
    var matchingSources = player.cache_.sources.filter(function (s) {
      return s.src === src;
    });
    if (matchingSources.length) {
      return matchingSources[0].type;
    }
    var sources = player.$$('source');
    for (var i = 0; i < sources.length; i++) {
      var s = sources[i];
      if (s.type && s.src && s.src === src) {
        return s.type;
      }
    }
    return getMimetype(src);
  };
  var filterSource = function filterSource(src) {
    if (Array.isArray(src)) {
      var newsrc = [];
      src.forEach(function (srcobj) {
        srcobj = filterSource(srcobj);
        if (Array.isArray(srcobj)) {
          newsrc = newsrc.concat(srcobj);
        } else if (isObject$1(srcobj)) {
          newsrc.push(srcobj);
        }
      });
      src = newsrc;
    } else if (typeof src === 'string' && src.trim()) {
      src = [fixSource({
        src: src
      })];
    } else if (isObject$1(src) && typeof src.src === 'string' && src.src && src.src.trim()) {
      src = [fixSource(src)];
    } else {
      src = [];
    }
    return src;
  };
  function fixSource(src) {
    if (!src.type) {
      var mimetype = getMimetype(src.src);
      if (mimetype) {
        src.type = mimetype;
      }
    }
    return src;
  }
  var MediaLoader = function (_Component) {
    inheritsLoose(MediaLoader, _Component);
    function MediaLoader(player, options, ready) {
      var _this;
      var options_ = mergeOptions$3({
        createEl: false
      }, options);
      _this = _Component.call(this, player, options_, ready) || this;
      if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
        for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
          var techName = toTitleCase$1(j[i]);
          var tech = Tech.getTech(techName);
          if (!techName) {
            tech = Component$1.getComponent(techName);
          }
          if (tech && tech.isSupported()) {
            player.loadTech_(techName);
            break;
          }
        }
      } else {
        player.src(options.playerOptions.sources);
      }
      return _this;
    }
    return MediaLoader;
  }(Component$1);
  Component$1.registerComponent('MediaLoader', MediaLoader);
  var ClickableComponent = function (_Component) {
    inheritsLoose(ClickableComponent, _Component);
    function ClickableComponent(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.handleMouseOver_ = function (e) {
        return _this.handleMouseOver(e);
      };
      _this.handleMouseOut_ = function (e) {
        return _this.handleMouseOut(e);
      };
      _this.handleClick_ = function (e) {
        return _this.handleClick(e);
      };
      _this.handleKeyDown_ = function (e) {
        return _this.handleKeyDown(e);
      };
      _this.emitTapEvents();
      _this.enable();
      return _this;
    }
    var _proto = ClickableComponent.prototype;
    _proto.createEl = function createEl$1(tag, props, attributes) {
      if (tag === void 0) {
        tag = 'div';
      }
      if (props === void 0) {
        props = {};
      }
      if (attributes === void 0) {
        attributes = {};
      }
      props = assign({
        className: this.buildCSSClass(),
        tabIndex: 0
      }, props);
      if (tag === 'button') {
        log$1.error("Creating a ClickableComponent with an HTML element of " + tag + " is not supported; use a Button instead.");
      }
      attributes = assign({
        role: 'button'
      }, attributes);
      this.tabIndex_ = props.tabIndex;
      var el = createEl(tag, props, attributes);
      el.appendChild(createEl('span', {
        className: 'vjs-icon-placeholder'
      }, {
        'aria-hidden': true
      }));
      this.createControlTextEl(el);
      return el;
    };
    _proto.dispose = function dispose() {
      this.controlTextEl_ = null;
      _Component.prototype.dispose.call(this);
    }
    ;
    _proto.createControlTextEl = function createControlTextEl(el) {
      this.controlTextEl_ = createEl('span', {
        className: 'vjs-control-text'
      }, {
        'aria-live': 'polite'
      });
      if (el) {
        el.appendChild(this.controlTextEl_);
      }
      this.controlText(this.controlText_, el);
      return this.controlTextEl_;
    }
    ;
    _proto.controlText = function controlText(text, el) {
      if (el === void 0) {
        el = this.el();
      }
      if (text === undefined) {
        return this.controlText_ || 'Need Text';
      }
      var localizedText = this.localize(text);
      this.controlText_ = text;
      textContent(this.controlTextEl_, localizedText);
      if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {
        el.setAttribute('title', localizedText);
      }
    }
    ;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-control vjs-button " + _Component.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.enable = function enable() {
      if (!this.enabled_) {
        this.enabled_ = true;
        this.removeClass('vjs-disabled');
        this.el_.setAttribute('aria-disabled', 'false');
        if (typeof this.tabIndex_ !== 'undefined') {
          this.el_.setAttribute('tabIndex', this.tabIndex_);
        }
        this.on(['tap', 'click'], this.handleClick_);
        this.on('keydown', this.handleKeyDown_);
      }
    }
    ;
    _proto.disable = function disable() {
      this.enabled_ = false;
      this.addClass('vjs-disabled');
      this.el_.setAttribute('aria-disabled', 'true');
      if (typeof this.tabIndex_ !== 'undefined') {
        this.el_.removeAttribute('tabIndex');
      }
      this.off('mouseover', this.handleMouseOver_);
      this.off('mouseout', this.handleMouseOut_);
      this.off(['tap', 'click'], this.handleClick_);
      this.off('keydown', this.handleKeyDown_);
    }
    ;
    _proto.handleLanguagechange = function handleLanguagechange() {
      this.controlText(this.controlText_);
    }
    ;
    _proto.handleClick = function handleClick(event) {
      if (this.options_.clickHandler) {
        this.options_.clickHandler.call(this, arguments);
      }
    }
    ;
    _proto.handleKeyDown = function handleKeyDown(event) {
      if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {
        event.preventDefault();
        event.stopPropagation();
        this.trigger('click');
      } else {
        _Component.prototype.handleKeyDown.call(this, event);
      }
    };
    return ClickableComponent;
  }(Component$1);
  Component$1.registerComponent('ClickableComponent', ClickableComponent);
  var PosterImage = function (_ClickableComponent) {
    inheritsLoose(PosterImage, _ClickableComponent);
    function PosterImage(player, options) {
      var _this;
      _this = _ClickableComponent.call(this, player, options) || this;
      _this.update();
      _this.update_ = function (e) {
        return _this.update(e);
      };
      player.on('posterchange', _this.update_);
      return _this;
    }
    var _proto = PosterImage.prototype;
    _proto.dispose = function dispose() {
      this.player().off('posterchange', this.update_);
      _ClickableComponent.prototype.dispose.call(this);
    }
    ;
    _proto.createEl = function createEl$1() {
      var el = createEl('div', {
        className: 'vjs-poster',
        tabIndex: -1
      });
      return el;
    }
    ;
    _proto.update = function update(event) {
      var url = this.player().poster();
      this.setSrc(url);
      if (url) {
        this.show();
      } else {
        this.hide();
      }
    }
    ;
    _proto.setSrc = function setSrc(url) {
      var backgroundImage = '';
      if (url) {
        backgroundImage = "url(\"" + url + "\")";
      }
      this.el_.style.backgroundImage = backgroundImage;
    }
    ;
    _proto.handleClick = function handleClick(event) {
      if (!this.player_.controls()) {
        return;
      }
      var sourceIsEncrypted = this.player_.usingPlugin('eme') && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
      if (this.player_.tech(true) &&
      !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {
        this.player_.tech(true).focus();
      }
      if (this.player_.paused()) {
        silencePromise(this.player_.play());
      } else {
        this.player_.pause();
      }
    };
    return PosterImage;
  }(ClickableComponent);
  Component$1.registerComponent('PosterImage', PosterImage);
  var darkGray = '#222';
  var lightGray = '#ccc';
  var fontMap = {
    monospace: 'monospace',
    sansSerif: 'sans-serif',
    serif: 'serif',
    monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
    monospaceSerif: '"Courier New", monospace',
    proportionalSansSerif: 'sans-serif',
    proportionalSerif: 'serif',
    casual: '"Comic Sans MS", Impact, fantasy',
    script: '"Monotype Corsiva", cursive',
    smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
  };
  function constructColor(color, opacity) {
    var hex;
    if (color.length === 4) {
      hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
    } else if (color.length === 7) {
      hex = color.slice(1);
    } else {
      throw new Error('Invalid color code provided, ' + color + '; must be formatted as e.g. #f0e or #f604e2.');
    }
    return 'rgba(' + parseInt(hex.slice(0, 2), 16) + ',' + parseInt(hex.slice(2, 4), 16) + ',' + parseInt(hex.slice(4, 6), 16) + ',' + opacity + ')';
  }
  function tryUpdateStyle(el, style, rule) {
    try {
      el.style[style] = rule;
    } catch (e) {
      return;
    }
  }
  var TextTrackDisplay = function (_Component) {
    inheritsLoose(TextTrackDisplay, _Component);
    function TextTrackDisplay(player, options, ready) {
      var _this;
      _this = _Component.call(this, player, options, ready) || this;
      var updateDisplayHandler = function updateDisplayHandler(e) {
        return _this.updateDisplay(e);
      };
      player.on('loadstart', function (e) {
        return _this.toggleDisplay(e);
      });
      player.on('texttrackchange', updateDisplayHandler);
      player.on('loadedmetadata', function (e) {
        return _this.preselectTrack(e);
      });
      player.ready(bind(assertThisInitialized(_this), function () {
        if (player.tech_ && player.tech_.featuresNativeTextTracks) {
          this.hide();
          return;
        }
        player.on('fullscreenchange', updateDisplayHandler);
        player.on('playerresize', updateDisplayHandler);
        window.addEventListener('orientationchange', updateDisplayHandler);
        player.on('dispose', function () {
          return window.removeEventListener('orientationchange', updateDisplayHandler);
        });
        var tracks = this.options_.playerOptions.tracks || [];
        for (var i = 0; i < tracks.length; i++) {
          this.player_.addRemoteTextTrack(tracks[i], true);
        }
        this.preselectTrack();
      }));
      return _this;
    }
    var _proto = TextTrackDisplay.prototype;
    _proto.preselectTrack = function preselectTrack() {
      var modes = {
        captions: 1,
        subtitles: 1
      };
      var trackList = this.player_.textTracks();
      var userPref = this.player_.cache_.selectedLanguage;
      var firstDesc;
      var firstCaptions;
      var preferredTrack;
      for (var i = 0; i < trackList.length; i++) {
        var track = trackList[i];
        if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {
          if (track.kind === userPref.kind) {
            preferredTrack = track;
          } else if (!preferredTrack) {
            preferredTrack = track;
          }
        } else if (userPref && !userPref.enabled) {
          preferredTrack = null;
          firstDesc = null;
          firstCaptions = null;
        } else if (track["default"]) {
          if (track.kind === 'descriptions' && !firstDesc) {
            firstDesc = track;
          } else if (track.kind in modes && !firstCaptions) {
            firstCaptions = track;
          }
        }
      }
      if (preferredTrack) {
        preferredTrack.mode = 'showing';
      } else if (firstCaptions) {
        firstCaptions.mode = 'showing';
      } else if (firstDesc) {
        firstDesc.mode = 'showing';
      }
    }
    ;
    _proto.toggleDisplay = function toggleDisplay() {
      if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
        this.hide();
      } else {
        this.show();
      }
    }
    ;
    _proto.createEl = function createEl() {
      return _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-text-track-display'
      }, {
        'translate': 'yes',
        'aria-live': 'off',
        'aria-atomic': 'true'
      });
    }
    ;
    _proto.clearDisplay = function clearDisplay() {
      if (typeof window.WebVTT === 'function') {
        window.WebVTT.processCues(window, [], this.el_);
      }
    }
    ;
    _proto.updateDisplay = function updateDisplay() {
      var tracks = this.player_.textTracks();
      var allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
      this.clearDisplay();
      if (allowMultipleShowingTracks) {
        var showingTracks = [];
        for (var _i = 0; _i < tracks.length; ++_i) {
          var track = tracks[_i];
          if (track.mode !== 'showing') {
            continue;
          }
          showingTracks.push(track);
        }
        this.updateForTrack(showingTracks);
        return;
      }
      var descriptionsTrack = null;
      var captionsSubtitlesTrack = null;
      var i = tracks.length;
      while (i--) {
        var _track = tracks[i];
        if (_track.mode === 'showing') {
          if (_track.kind === 'descriptions') {
            descriptionsTrack = _track;
          } else {
            captionsSubtitlesTrack = _track;
          }
        }
      }
      if (captionsSubtitlesTrack) {
        if (this.getAttribute('aria-live') !== 'off') {
          this.setAttribute('aria-live', 'off');
        }
        this.updateForTrack(captionsSubtitlesTrack);
      } else if (descriptionsTrack) {
        if (this.getAttribute('aria-live') !== 'assertive') {
          this.setAttribute('aria-live', 'assertive');
        }
        this.updateForTrack(descriptionsTrack);
      }
    }
    ;
    _proto.updateDisplayState = function updateDisplayState(track) {
      var overrides = this.player_.textTrackSettings.getValues();
      var cues = track.activeCues;
      var i = cues.length;
      while (i--) {
        var cue = cues[i];
        if (!cue) {
          continue;
        }
        var cueDiv = cue.displayState;
        if (overrides.color) {
          cueDiv.firstChild.style.color = overrides.color;
        }
        if (overrides.textOpacity) {
          tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
        }
        if (overrides.backgroundColor) {
          cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
        }
        if (overrides.backgroundOpacity) {
          tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
        }
        if (overrides.windowColor) {
          if (overrides.windowOpacity) {
            tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
          } else {
            cueDiv.style.backgroundColor = overrides.windowColor;
          }
        }
        if (overrides.edgeStyle) {
          if (overrides.edgeStyle === 'dropshadow') {
            cueDiv.firstChild.style.textShadow = "2px 2px 3px " + darkGray + ", 2px 2px 4px " + darkGray + ", 2px 2px 5px " + darkGray;
          } else if (overrides.edgeStyle === 'raised') {
            cueDiv.firstChild.style.textShadow = "1px 1px " + darkGray + ", 2px 2px " + darkGray + ", 3px 3px " + darkGray;
          } else if (overrides.edgeStyle === 'depressed') {
            cueDiv.firstChild.style.textShadow = "1px 1px " + lightGray + ", 0 1px " + lightGray + ", -1px -1px " + darkGray + ", 0 -1px " + darkGray;
          } else if (overrides.edgeStyle === 'uniform') {
            cueDiv.firstChild.style.textShadow = "0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray;
          }
        }
        if (overrides.fontPercent && overrides.fontPercent !== 1) {
          var fontSize = window.parseFloat(cueDiv.style.fontSize);
          cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
          cueDiv.style.height = 'auto';
          cueDiv.style.top = 'auto';
        }
        if (overrides.fontFamily && overrides.fontFamily !== 'default') {
          if (overrides.fontFamily === 'small-caps') {
            cueDiv.firstChild.style.fontVariant = 'small-caps';
          } else {
            cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
          }
        }
      }
    }
    ;
    _proto.updateForTrack = function updateForTrack(tracks) {
      if (!Array.isArray(tracks)) {
        tracks = [tracks];
      }
      if (typeof window.WebVTT !== 'function' || tracks.every(function (track) {
        return !track.activeCues;
      })) {
        return;
      }
      var cues = [];
      for (var i = 0; i < tracks.length; ++i) {
        var track = tracks[i];
        for (var j = 0; j < track.activeCues.length; ++j) {
          cues.push(track.activeCues[j]);
        }
      }
      window.WebVTT.processCues(window, cues, this.el_);
      for (var _i2 = 0; _i2 < tracks.length; ++_i2) {
        var _track2 = tracks[_i2];
        for (var _j = 0; _j < _track2.activeCues.length; ++_j) {
          var cueEl = _track2.activeCues[_j].displayState;
          addClass(cueEl, 'vjs-text-track-cue');
          addClass(cueEl, 'vjs-text-track-cue-' + (_track2.language ? _track2.language : _i2));
          if (_track2.language) {
            setAttribute(cueEl, 'lang', _track2.language);
          }
        }
        if (this.player_.textTrackSettings) {
          this.updateDisplayState(_track2);
        }
      }
    };
    return TextTrackDisplay;
  }(Component$1);
  Component$1.registerComponent('TextTrackDisplay', TextTrackDisplay);
  var LoadingSpinner = function (_Component) {
    inheritsLoose(LoadingSpinner, _Component);
    function LoadingSpinner() {
      return _Component.apply(this, arguments) || this;
    }
    var _proto = LoadingSpinner.prototype;
    _proto.createEl = function createEl$1() {
      var isAudio = this.player_.isAudio();
      var playerType = this.localize(isAudio ? 'Audio Player' : 'Video Player');
      var controlText = createEl('span', {
        className: 'vjs-control-text',
        textContent: this.localize('{1} is loading.', [playerType])
      });
      var el = _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-loading-spinner',
        dir: 'ltr'
      });
      el.appendChild(controlText);
      return el;
    };
    return LoadingSpinner;
  }(Component$1);
  Component$1.registerComponent('LoadingSpinner', LoadingSpinner);
  var Button = function (_ClickableComponent) {
    inheritsLoose(Button, _ClickableComponent);
    function Button() {
      return _ClickableComponent.apply(this, arguments) || this;
    }
    var _proto = Button.prototype;
    _proto.createEl = function createEl$1(tag, props, attributes) {
      if (props === void 0) {
        props = {};
      }
      if (attributes === void 0) {
        attributes = {};
      }
      tag = 'button';
      props = assign({
        className: this.buildCSSClass()
      }, props);
      attributes = assign({
        type: 'button'
      }, attributes);
      var el = createEl(tag, props, attributes);
      el.appendChild(createEl('span', {
        className: 'vjs-icon-placeholder'
      }, {
        'aria-hidden': true
      }));
      this.createControlTextEl(el);
      return el;
    }
    ;
    _proto.addChild = function addChild(child, options) {
      if (options === void 0) {
        options = {};
      }
      var className = this.constructor.name;
      log$1.warn("Adding an actionable (user controllable) child to a Button (" + className + ") is not supported; use a ClickableComponent instead.");
      return Component$1.prototype.addChild.call(this, child, options);
    }
    ;
    _proto.enable = function enable() {
      _ClickableComponent.prototype.enable.call(this);
      this.el_.removeAttribute('disabled');
    }
    ;
    _proto.disable = function disable() {
      _ClickableComponent.prototype.disable.call(this);
      this.el_.setAttribute('disabled', 'disabled');
    }
    ;
    _proto.handleKeyDown = function handleKeyDown(event) {
      if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {
        event.stopPropagation();
        return;
      }
      _ClickableComponent.prototype.handleKeyDown.call(this, event);
    };
    return Button;
  }(ClickableComponent);
  Component$1.registerComponent('Button', Button);
  var BigPlayButton = function (_Button) {
    inheritsLoose(BigPlayButton, _Button);
    function BigPlayButton(player, options) {
      var _this;
      _this = _Button.call(this, player, options) || this;
      _this.mouseused_ = false;
      _this.on('mousedown', function (e) {
        return _this.handleMouseDown(e);
      });
      return _this;
    }
    var _proto = BigPlayButton.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return 'vjs-big-play-button';
    }
    ;
    _proto.handleClick = function handleClick(event) {
      var playPromise = this.player_.play();
      if (this.mouseused_ && event.clientX && event.clientY) {
        var sourceIsEncrypted = this.player_.usingPlugin('eme') && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
        silencePromise(playPromise);
        if (this.player_.tech(true) &&
        !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {
          this.player_.tech(true).focus();
        }
        return;
      }
      var cb = this.player_.getChild('controlBar');
      var playToggle = cb && cb.getChild('playToggle');
      if (!playToggle) {
        this.player_.tech(true).focus();
        return;
      }
      var playFocus = function playFocus() {
        return playToggle.focus();
      };
      if (isPromise(playPromise)) {
        playPromise.then(playFocus, function () {});
      } else {
        this.setTimeout(playFocus, 1);
      }
    };
    _proto.handleKeyDown = function handleKeyDown(event) {
      this.mouseused_ = false;
      _Button.prototype.handleKeyDown.call(this, event);
    };
    _proto.handleMouseDown = function handleMouseDown(event) {
      this.mouseused_ = true;
    };
    return BigPlayButton;
  }(Button);
  BigPlayButton.prototype.controlText_ = 'Play Video';
  Component$1.registerComponent('BigPlayButton', BigPlayButton);
  var CloseButton = function (_Button) {
    inheritsLoose(CloseButton, _Button);
    function CloseButton(player, options) {
      var _this;
      _this = _Button.call(this, player, options) || this;
      _this.controlText(options && options.controlText || _this.localize('Close'));
      return _this;
    }
    var _proto = CloseButton.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-close-button " + _Button.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.handleClick = function handleClick(event) {
      this.trigger({
        type: 'close',
        bubbles: false
      });
    }
    ;
    _proto.handleKeyDown = function handleKeyDown(event) {
      if (keycode.isEventKey(event, 'Esc')) {
        event.preventDefault();
        event.stopPropagation();
        this.trigger('click');
      } else {
        _Button.prototype.handleKeyDown.call(this, event);
      }
    };
    return CloseButton;
  }(Button);
  Component$1.registerComponent('CloseButton', CloseButton);
  var PlayToggle = function (_Button) {
    inheritsLoose(PlayToggle, _Button);
    function PlayToggle(player, options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      _this = _Button.call(this, player, options) || this;
      options.replay = options.replay === undefined || options.replay;
      _this.on(player, 'play', function (e) {
        return _this.handlePlay(e);
      });
      _this.on(player, 'pause', function (e) {
        return _this.handlePause(e);
      });
      if (options.replay) {
        _this.on(player, 'ended', function (e) {
          return _this.handleEnded(e);
        });
      }
      return _this;
    }
    var _proto = PlayToggle.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-play-control " + _Button.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.handleClick = function handleClick(event) {
      if (this.player_.paused()) {
        silencePromise(this.player_.play());
      } else {
        this.player_.pause();
      }
    }
    ;
    _proto.handleSeeked = function handleSeeked(event) {
      this.removeClass('vjs-ended');
      if (this.player_.paused()) {
        this.handlePause(event);
      } else {
        this.handlePlay(event);
      }
    }
    ;
    _proto.handlePlay = function handlePlay(event) {
      this.removeClass('vjs-ended');
      this.removeClass('vjs-paused');
      this.addClass('vjs-playing');
      this.controlText('Pause');
    }
    ;
    _proto.handlePause = function handlePause(event) {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
      this.controlText('Play');
    }
    ;
    _proto.handleEnded = function handleEnded(event) {
      var _this2 = this;
      this.removeClass('vjs-playing');
      this.addClass('vjs-ended');
      this.controlText('Replay');
      this.one(this.player_, 'seeked', function (e) {
        return _this2.handleSeeked(e);
      });
    };
    return PlayToggle;
  }(Button);
  PlayToggle.prototype.controlText_ = 'Play';
  Component$1.registerComponent('PlayToggle', PlayToggle);
  var defaultImplementation = function defaultImplementation(seconds, guide) {
    seconds = seconds < 0 ? 0 : seconds;
    var s = Math.floor(seconds % 60);
    var m = Math.floor(seconds / 60 % 60);
    var h = Math.floor(seconds / 3600);
    var gm = Math.floor(guide / 60 % 60);
    var gh = Math.floor(guide / 3600);
    if (isNaN(seconds) || seconds === Infinity) {
      h = m = s = '-';
    }
    h = h > 0 || gh > 0 ? h + ':' : '';
    m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';
    s = s < 10 ? '0' + s : s;
    return h + m + s;
  };
  var implementation = defaultImplementation;
  function setFormatTime(customImplementation) {
    implementation = customImplementation;
  }
  function resetFormatTime() {
    implementation = defaultImplementation;
  }
  function formatTime(seconds, guide) {
    if (guide === void 0) {
      guide = seconds;
    }
    return implementation(seconds, guide);
  }
  var TimeDisplay = function (_Component) {
    inheritsLoose(TimeDisplay, _Component);
    function TimeDisplay(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.on(player, ['timeupdate', 'ended'], function (e) {
        return _this.updateContent(e);
      });
      _this.updateTextNode_();
      return _this;
    }
    var _proto = TimeDisplay.prototype;
    _proto.createEl = function createEl$1() {
      var className = this.buildCSSClass();
      var el = _Component.prototype.createEl.call(this, 'div', {
        className: className + " vjs-time-control vjs-control"
      });
      var span = createEl('span', {
        className: 'vjs-control-text',
        textContent: this.localize(this.labelText_) + "\xA0"
      }, {
        role: 'presentation'
      });
      el.appendChild(span);
      this.contentEl_ = createEl('span', {
        className: className + "-display"
      }, {
        'aria-live': 'off',
        'role': 'presentation'
      });
      el.appendChild(this.contentEl_);
      return el;
    };
    _proto.dispose = function dispose() {
      this.contentEl_ = null;
      this.textNode_ = null;
      _Component.prototype.dispose.call(this);
    }
    ;
    _proto.updateTextNode_ = function updateTextNode_(time) {
      var _this2 = this;
      if (time === void 0) {
        time = 0;
      }
      time = formatTime(time);
      if (this.formattedTime_ === time) {
        return;
      }
      this.formattedTime_ = time;
      this.requestNamedAnimationFrame('TimeDisplay#updateTextNode_', function () {
        if (!_this2.contentEl_) {
          return;
        }
        var oldNode = _this2.textNode_;
        if (oldNode && _this2.contentEl_.firstChild !== oldNode) {
          oldNode = null;
          log$1.warn('TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.');
        }
        _this2.textNode_ = document.createTextNode(_this2.formattedTime_);
        if (!_this2.textNode_) {
          return;
        }
        if (oldNode) {
          _this2.contentEl_.replaceChild(_this2.textNode_, oldNode);
        } else {
          _this2.contentEl_.appendChild(_this2.textNode_);
        }
      });
    }
    ;
    _proto.updateContent = function updateContent(event) {};
    return TimeDisplay;
  }(Component$1);
  TimeDisplay.prototype.labelText_ = 'Time';
  TimeDisplay.prototype.controlText_ = 'Time';
  Component$1.registerComponent('TimeDisplay', TimeDisplay);
  var CurrentTimeDisplay = function (_TimeDisplay) {
    inheritsLoose(CurrentTimeDisplay, _TimeDisplay);
    function CurrentTimeDisplay() {
      return _TimeDisplay.apply(this, arguments) || this;
    }
    var _proto = CurrentTimeDisplay.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return 'vjs-current-time';
    }
    ;
    _proto.updateContent = function updateContent(event) {
      var time;
      if (this.player_.ended()) {
        time = this.player_.duration();
      } else {
        time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      }
      this.updateTextNode_(time);
    };
    return CurrentTimeDisplay;
  }(TimeDisplay);
  CurrentTimeDisplay.prototype.labelText_ = 'Current Time';
  CurrentTimeDisplay.prototype.controlText_ = 'Current Time';
  Component$1.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);
  var DurationDisplay = function (_TimeDisplay) {
    inheritsLoose(DurationDisplay, _TimeDisplay);
    function DurationDisplay(player, options) {
      var _this;
      _this = _TimeDisplay.call(this, player, options) || this;
      var updateContent = function updateContent(e) {
        return _this.updateContent(e);
      };
      _this.on(player, 'durationchange', updateContent);
      _this.on(player, 'loadstart', updateContent);
      _this.on(player, 'loadedmetadata', updateContent);
      return _this;
    }
    var _proto = DurationDisplay.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return 'vjs-duration';
    }
    ;
    _proto.updateContent = function updateContent(event) {
      var duration = this.player_.duration();
      this.updateTextNode_(duration);
    };
    return DurationDisplay;
  }(TimeDisplay);
  DurationDisplay.prototype.labelText_ = 'Duration';
  DurationDisplay.prototype.controlText_ = 'Duration';
  Component$1.registerComponent('DurationDisplay', DurationDisplay);
  var TimeDivider = function (_Component) {
    inheritsLoose(TimeDivider, _Component);
    function TimeDivider() {
      return _Component.apply(this, arguments) || this;
    }
    var _proto = TimeDivider.prototype;
    _proto.createEl = function createEl() {
      var el = _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-time-control vjs-time-divider'
      }, {
        'aria-hidden': true
      });
      var div = _Component.prototype.createEl.call(this, 'div');
      var span = _Component.prototype.createEl.call(this, 'span', {
        textContent: '/'
      });
      div.appendChild(span);
      el.appendChild(div);
      return el;
    };
    return TimeDivider;
  }(Component$1);
  Component$1.registerComponent('TimeDivider', TimeDivider);
  var RemainingTimeDisplay = function (_TimeDisplay) {
    inheritsLoose(RemainingTimeDisplay, _TimeDisplay);
    function RemainingTimeDisplay(player, options) {
      var _this;
      _this = _TimeDisplay.call(this, player, options) || this;
      _this.on(player, 'durationchange', function (e) {
        return _this.updateContent(e);
      });
      return _this;
    }
    var _proto = RemainingTimeDisplay.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return 'vjs-remaining-time';
    }
    ;
    _proto.createEl = function createEl$1() {
      var el = _TimeDisplay.prototype.createEl.call(this);
      if (this.options_.displayNegative !== false) {
        el.insertBefore(createEl('span', {}, {
          'aria-hidden': true
        }, '-'), this.contentEl_);
      }
      return el;
    }
    ;
    _proto.updateContent = function updateContent(event) {
      if (typeof this.player_.duration() !== 'number') {
        return;
      }
      var time;
      if (this.player_.ended()) {
        time = 0;
      } else if (this.player_.remainingTimeDisplay) {
        time = this.player_.remainingTimeDisplay();
      } else {
        time = this.player_.remainingTime();
      }
      this.updateTextNode_(time);
    };
    return RemainingTimeDisplay;
  }(TimeDisplay);
  RemainingTimeDisplay.prototype.labelText_ = 'Remaining Time';
  RemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';
  Component$1.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);
  var LiveDisplay = function (_Component) {
    inheritsLoose(LiveDisplay, _Component);
    function LiveDisplay(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.updateShowing();
      _this.on(_this.player(), 'durationchange', function (e) {
        return _this.updateShowing(e);
      });
      return _this;
    }
    var _proto = LiveDisplay.prototype;
    _proto.createEl = function createEl$1() {
      var el = _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-live-control vjs-control'
      });
      this.contentEl_ = createEl('div', {
        className: 'vjs-live-display'
      }, {
        'aria-live': 'off'
      });
      this.contentEl_.appendChild(createEl('span', {
        className: 'vjs-control-text',
        textContent: this.localize('Stream Type') + "\xA0"
      }));
      this.contentEl_.appendChild(document.createTextNode(this.localize('LIVE')));
      el.appendChild(this.contentEl_);
      return el;
    };
    _proto.dispose = function dispose() {
      this.contentEl_ = null;
      _Component.prototype.dispose.call(this);
    }
    ;
    _proto.updateShowing = function updateShowing(event) {
      if (this.player().duration() === Infinity) {
        this.show();
      } else {
        this.hide();
      }
    };
    return LiveDisplay;
  }(Component$1);
  Component$1.registerComponent('LiveDisplay', LiveDisplay);
  var SeekToLive = function (_Button) {
    inheritsLoose(SeekToLive, _Button);
    function SeekToLive(player, options) {
      var _this;
      _this = _Button.call(this, player, options) || this;
      _this.updateLiveEdgeStatus();
      if (_this.player_.liveTracker) {
        _this.updateLiveEdgeStatusHandler_ = function (e) {
          return _this.updateLiveEdgeStatus(e);
        };
        _this.on(_this.player_.liveTracker, 'liveedgechange', _this.updateLiveEdgeStatusHandler_);
      }
      return _this;
    }
    var _proto = SeekToLive.prototype;
    _proto.createEl = function createEl$1() {
      var el = _Button.prototype.createEl.call(this, 'button', {
        className: 'vjs-seek-to-live-control vjs-control'
      });
      this.textEl_ = createEl('span', {
        className: 'vjs-seek-to-live-text',
        textContent: this.localize('LIVE')
      }, {
        'aria-hidden': 'true'
      });
      el.appendChild(this.textEl_);
      return el;
    }
    ;
    _proto.updateLiveEdgeStatus = function updateLiveEdgeStatus() {
      if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {
        this.setAttribute('aria-disabled', true);
        this.addClass('vjs-at-live-edge');
        this.controlText('Seek to live, currently playing live');
      } else {
        this.setAttribute('aria-disabled', false);
        this.removeClass('vjs-at-live-edge');
        this.controlText('Seek to live, currently behind live');
      }
    }
    ;
    _proto.handleClick = function handleClick() {
      this.player_.liveTracker.seekToLiveEdge();
    }
    ;
    _proto.dispose = function dispose() {
      if (this.player_.liveTracker) {
        this.off(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatusHandler_);
      }
      this.textEl_ = null;
      _Button.prototype.dispose.call(this);
    };
    return SeekToLive;
  }(Button);
  SeekToLive.prototype.controlText_ = 'Seek to live, currently playing live';
  Component$1.registerComponent('SeekToLive', SeekToLive);
  var clamp = function clamp(number, min, max) {
    number = Number(number);
    return Math.min(max, Math.max(min, isNaN(number) ? min : number));
  };
  var Slider = function (_Component) {
    inheritsLoose(Slider, _Component);
    function Slider(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.handleMouseDown_ = function (e) {
        return _this.handleMouseDown(e);
      };
      _this.handleMouseUp_ = function (e) {
        return _this.handleMouseUp(e);
      };
      _this.handleKeyDown_ = function (e) {
        return _this.handleKeyDown(e);
      };
      _this.handleClick_ = function (e) {
        return _this.handleClick(e);
      };
      _this.handleMouseMove_ = function (e) {
        return _this.handleMouseMove(e);
      };
      _this.update_ = function (e) {
        return _this.update(e);
      };
      _this.bar = _this.getChild(_this.options_.barName);
      _this.vertical(!!_this.options_.vertical);
      _this.enable();
      return _this;
    }
    var _proto = Slider.prototype;
    _proto.enabled = function enabled() {
      return this.enabled_;
    }
    ;
    _proto.enable = function enable() {
      if (this.enabled()) {
        return;
      }
      this.on('mousedown', this.handleMouseDown_);
      this.on('touchstart', this.handleMouseDown_);
      this.on('keydown', this.handleKeyDown_);
      this.on('click', this.handleClick_);
      this.on(this.player_, 'controlsvisible', this.update);
      if (this.playerEvent) {
        this.on(this.player_, this.playerEvent, this.update);
      }
      this.removeClass('disabled');
      this.setAttribute('tabindex', 0);
      this.enabled_ = true;
    }
    ;
    _proto.disable = function disable() {
      if (!this.enabled()) {
        return;
      }
      var doc = this.bar.el_.ownerDocument;
      this.off('mousedown', this.handleMouseDown_);
      this.off('touchstart', this.handleMouseDown_);
      this.off('keydown', this.handleKeyDown_);
      this.off('click', this.handleClick_);
      this.off(this.player_, 'controlsvisible', this.update_);
      this.off(doc, 'mousemove', this.handleMouseMove_);
      this.off(doc, 'mouseup', this.handleMouseUp_);
      this.off(doc, 'touchmove', this.handleMouseMove_);
      this.off(doc, 'touchend', this.handleMouseUp_);
      this.removeAttribute('tabindex');
      this.addClass('disabled');
      if (this.playerEvent) {
        this.off(this.player_, this.playerEvent, this.update);
      }
      this.enabled_ = false;
    }
    ;
    _proto.createEl = function createEl(type, props, attributes) {
      if (props === void 0) {
        props = {};
      }
      if (attributes === void 0) {
        attributes = {};
      }
      props.className = props.className + ' vjs-slider';
      props = assign({
        tabIndex: 0
      }, props);
      attributes = assign({
        'role': 'slider',
        'aria-valuenow': 0,
        'aria-valuemin': 0,
        'aria-valuemax': 100,
        'tabIndex': 0
      }, attributes);
      return _Component.prototype.createEl.call(this, type, props, attributes);
    }
    ;
    _proto.handleMouseDown = function handleMouseDown(event) {
      var doc = this.bar.el_.ownerDocument;
      if (event.type === 'mousedown') {
        event.preventDefault();
      }
      if (event.type === 'touchstart' && !IS_CHROME) {
        event.preventDefault();
      }
      blockTextSelection();
      this.addClass('vjs-sliding');
      this.trigger('slideractive');
      this.on(doc, 'mousemove', this.handleMouseMove_);
      this.on(doc, 'mouseup', this.handleMouseUp_);
      this.on(doc, 'touchmove', this.handleMouseMove_);
      this.on(doc, 'touchend', this.handleMouseUp_);
      this.handleMouseMove(event, true);
    }
    ;
    _proto.handleMouseMove = function handleMouseMove(event) {}
    ;
    _proto.handleMouseUp = function handleMouseUp() {
      var doc = this.bar.el_.ownerDocument;
      unblockTextSelection();
      this.removeClass('vjs-sliding');
      this.trigger('sliderinactive');
      this.off(doc, 'mousemove', this.handleMouseMove_);
      this.off(doc, 'mouseup', this.handleMouseUp_);
      this.off(doc, 'touchmove', this.handleMouseMove_);
      this.off(doc, 'touchend', this.handleMouseUp_);
      this.update();
    }
    ;
    _proto.update = function update() {
      var _this2 = this;
      if (!this.el_ || !this.bar) {
        return;
      }
      var progress = this.getProgress();
      if (progress === this.progress_) {
        return progress;
      }
      this.progress_ = progress;
      this.requestNamedAnimationFrame('Slider#update', function () {
        var sizeKey = _this2.vertical() ? 'height' : 'width';
        _this2.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + '%';
      });
      return progress;
    }
    ;
    _proto.getProgress = function getProgress() {
      return Number(clamp(this.getPercent(), 0, 1).toFixed(4));
    }
    ;
    _proto.calculateDistance = function calculateDistance(event) {
      var position = getPointerPosition(this.el_, event);
      if (this.vertical()) {
        return position.y;
      }
      return position.x;
    }
    ;
    _proto.handleKeyDown = function handleKeyDown(event) {
      if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {
        event.preventDefault();
        event.stopPropagation();
        this.stepBack();
      } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {
        event.preventDefault();
        event.stopPropagation();
        this.stepForward();
      } else {
        _Component.prototype.handleKeyDown.call(this, event);
      }
    }
    ;
    _proto.handleClick = function handleClick(event) {
      event.stopPropagation();
      event.preventDefault();
    }
    ;
    _proto.vertical = function vertical(bool) {
      if (bool === undefined) {
        return this.vertical_ || false;
      }
      this.vertical_ = !!bool;
      if (this.vertical_) {
        this.addClass('vjs-slider-vertical');
      } else {
        this.addClass('vjs-slider-horizontal');
      }
    };
    return Slider;
  }(Component$1);
  Component$1.registerComponent('Slider', Slider);
  var percentify = function percentify(time, end) {
    return clamp(time / end * 100, 0, 100).toFixed(2) + '%';
  };
  var LoadProgressBar = function (_Component) {
    inheritsLoose(LoadProgressBar, _Component);
    function LoadProgressBar(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.partEls_ = [];
      _this.on(player, 'progress', function (e) {
        return _this.update(e);
      });
      return _this;
    }
    var _proto = LoadProgressBar.prototype;
    _proto.createEl = function createEl$1() {
      var el = _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-load-progress'
      });
      var wrapper = createEl('span', {
        className: 'vjs-control-text'
      });
      var loadedText = createEl('span', {
        textContent: this.localize('Loaded')
      });
      var separator = document.createTextNode(': ');
      this.percentageEl_ = createEl('span', {
        className: 'vjs-control-text-loaded-percentage',
        textContent: '0%'
      });
      el.appendChild(wrapper);
      wrapper.appendChild(loadedText);
      wrapper.appendChild(separator);
      wrapper.appendChild(this.percentageEl_);
      return el;
    };
    _proto.dispose = function dispose() {
      this.partEls_ = null;
      this.percentageEl_ = null;
      _Component.prototype.dispose.call(this);
    }
    ;
    _proto.update = function update(event) {
      var _this2 = this;
      this.requestNamedAnimationFrame('LoadProgressBar#update', function () {
        var liveTracker = _this2.player_.liveTracker;
        var buffered = _this2.player_.buffered();
        var duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : _this2.player_.duration();
        var bufferedEnd = _this2.player_.bufferedEnd();
        var children = _this2.partEls_;
        var percent = percentify(bufferedEnd, duration);
        if (_this2.percent_ !== percent) {
          _this2.el_.style.width = percent;
          textContent(_this2.percentageEl_, percent);
          _this2.percent_ = percent;
        }
        for (var i = 0; i < buffered.length; i++) {
          var start = buffered.start(i);
          var end = buffered.end(i);
          var part = children[i];
          if (!part) {
            part = _this2.el_.appendChild(createEl());
            children[i] = part;
          }
          if (part.dataset.start === start && part.dataset.end === end) {
            continue;
          }
          part.dataset.start = start;
          part.dataset.end = end;
          part.style.left = percentify(start, bufferedEnd);
          part.style.width = percentify(end - start, bufferedEnd);
        }
        for (var _i = children.length; _i > buffered.length; _i--) {
          _this2.el_.removeChild(children[_i - 1]);
        }
        children.length = buffered.length;
      });
    };
    return LoadProgressBar;
  }(Component$1);
  Component$1.registerComponent('LoadProgressBar', LoadProgressBar);
  var TimeTooltip = function (_Component) {
    inheritsLoose(TimeTooltip, _Component);
    function TimeTooltip(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.update = throttle(bind(assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
      return _this;
    }
    var _proto = TimeTooltip.prototype;
    _proto.createEl = function createEl() {
      return _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-time-tooltip'
      }, {
        'aria-hidden': 'true'
      });
    }
    ;
    _proto.update = function update(seekBarRect, seekBarPoint, content) {
      var tooltipRect = findPosition(this.el_);
      var playerRect = getBoundingClientRect(this.player_.el());
      var seekBarPointPx = seekBarRect.width * seekBarPoint;
      if (!playerRect || !tooltipRect) {
        return;
      }
      var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;
      var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);
      var pullTooltipBy = tooltipRect.width / 2;
      if (spaceLeftOfPoint < pullTooltipBy) {
        pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
      } else if (spaceRightOfPoint < pullTooltipBy) {
        pullTooltipBy = spaceRightOfPoint;
      }
      if (pullTooltipBy < 0) {
        pullTooltipBy = 0;
      } else if (pullTooltipBy > tooltipRect.width) {
        pullTooltipBy = tooltipRect.width;
      }
      pullTooltipBy = Math.round(pullTooltipBy);
      this.el_.style.right = "-" + pullTooltipBy + "px";
      this.write(content);
    }
    ;
    _proto.write = function write(content) {
      textContent(this.el_, content);
    }
    ;
    _proto.updateTime = function updateTime(seekBarRect, seekBarPoint, time, cb) {
      var _this2 = this;
      this.requestNamedAnimationFrame('TimeTooltip#updateTime', function () {
        var content;
        var duration = _this2.player_.duration();
        if (_this2.player_.liveTracker && _this2.player_.liveTracker.isLive()) {
          var liveWindow = _this2.player_.liveTracker.liveWindow();
          var secondsBehind = liveWindow - seekBarPoint * liveWindow;
          content = (secondsBehind < 1 ? '' : '-') + formatTime(secondsBehind, liveWindow);
        } else {
          content = formatTime(time, duration);
        }
        _this2.update(seekBarRect, seekBarPoint, content);
        if (cb) {
          cb();
        }
      });
    };
    return TimeTooltip;
  }(Component$1);
  Component$1.registerComponent('TimeTooltip', TimeTooltip);
  var PlayProgressBar = function (_Component) {
    inheritsLoose(PlayProgressBar, _Component);
    function PlayProgressBar(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.update = throttle(bind(assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
      return _this;
    }
    var _proto = PlayProgressBar.prototype;
    _proto.createEl = function createEl() {
      return _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-play-progress vjs-slider-bar'
      }, {
        'aria-hidden': 'true'
      });
    }
    ;
    _proto.update = function update(seekBarRect, seekBarPoint) {
      var timeTooltip = this.getChild('timeTooltip');
      if (!timeTooltip) {
        return;
      }
      var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      timeTooltip.updateTime(seekBarRect, seekBarPoint, time);
    };
    return PlayProgressBar;
  }(Component$1);
  PlayProgressBar.prototype.options_ = {
    children: []
  };
  if (!IS_IOS && !IS_ANDROID) {
    PlayProgressBar.prototype.options_.children.push('timeTooltip');
  }
  Component$1.registerComponent('PlayProgressBar', PlayProgressBar);
  var MouseTimeDisplay = function (_Component) {
    inheritsLoose(MouseTimeDisplay, _Component);
    function MouseTimeDisplay(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.update = throttle(bind(assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
      return _this;
    }
    var _proto = MouseTimeDisplay.prototype;
    _proto.createEl = function createEl() {
      return _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-mouse-display'
      });
    }
    ;
    _proto.update = function update(seekBarRect, seekBarPoint) {
      var _this2 = this;
      var time = seekBarPoint * this.player_.duration();
      this.getChild('timeTooltip').updateTime(seekBarRect, seekBarPoint, time, function () {
        _this2.el_.style.left = seekBarRect.width * seekBarPoint + "px";
      });
    };
    return MouseTimeDisplay;
  }(Component$1);
  MouseTimeDisplay.prototype.options_ = {
    children: ['timeTooltip']
  };
  Component$1.registerComponent('MouseTimeDisplay', MouseTimeDisplay);
  var STEP_SECONDS = 5;
  var PAGE_KEY_MULTIPLIER = 12;
  var SeekBar = function (_Slider) {
    inheritsLoose(SeekBar, _Slider);
    function SeekBar(player, options) {
      var _this;
      _this = _Slider.call(this, player, options) || this;
      _this.setEventHandlers_();
      return _this;
    }
    var _proto = SeekBar.prototype;
    _proto.setEventHandlers_ = function setEventHandlers_() {
      var _this2 = this;
      this.update_ = bind(this, this.update);
      this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);
      this.on(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);
      if (this.player_.liveTracker) {
        this.on(this.player_.liveTracker, 'liveedgechange', this.update);
      }
      this.updateInterval = null;
      this.enableIntervalHandler_ = function (e) {
        return _this2.enableInterval_(e);
      };
      this.disableIntervalHandler_ = function (e) {
        return _this2.disableInterval_(e);
      };
      this.on(this.player_, ['playing'], this.enableIntervalHandler_);
      this.on(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_);
      if ('hidden' in document && 'visibilityState' in document) {
        this.on(document, 'visibilitychange', this.toggleVisibility_);
      }
    };
    _proto.toggleVisibility_ = function toggleVisibility_(e) {
      if (document.visibilityState === 'hidden') {
        this.cancelNamedAnimationFrame('SeekBar#update');
        this.cancelNamedAnimationFrame('Slider#update');
        this.disableInterval_(e);
      } else {
        if (!this.player_.ended() && !this.player_.paused()) {
          this.enableInterval_();
        }
        this.update();
      }
    };
    _proto.enableInterval_ = function enableInterval_() {
      if (this.updateInterval) {
        return;
      }
      this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);
    };
    _proto.disableInterval_ = function disableInterval_(e) {
      if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== 'ended') {
        return;
      }
      if (!this.updateInterval) {
        return;
      }
      this.clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
    ;
    _proto.createEl = function createEl() {
      return _Slider.prototype.createEl.call(this, 'div', {
        className: 'vjs-progress-holder'
      }, {
        'aria-label': this.localize('Progress Bar')
      });
    }
    ;
    _proto.update = function update(event) {
      var _this3 = this;
      if (document.visibilityState === 'hidden') {
        return;
      }
      var percent = _Slider.prototype.update.call(this);
      this.requestNamedAnimationFrame('SeekBar#update', function () {
        var currentTime = _this3.player_.ended() ? _this3.player_.duration() : _this3.getCurrentTime_();
        var liveTracker = _this3.player_.liveTracker;
        var duration = _this3.player_.duration();
        if (liveTracker && liveTracker.isLive()) {
          duration = _this3.player_.liveTracker.liveCurrentTime();
        }
        if (_this3.percent_ !== percent) {
          _this3.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));
          _this3.percent_ = percent;
        }
        if (_this3.currentTime_ !== currentTime || _this3.duration_ !== duration) {
          _this3.el_.setAttribute('aria-valuetext', _this3.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));
          _this3.currentTime_ = currentTime;
          _this3.duration_ = duration;
        }
        if (_this3.bar) {
          _this3.bar.update(getBoundingClientRect(_this3.el()), _this3.getProgress());
        }
      });
      return percent;
    }
    ;
    _proto.userSeek_ = function userSeek_(ct) {
      if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
        this.player_.liveTracker.nextSeekedFromUser();
      }
      this.player_.currentTime(ct);
    }
    ;
    _proto.getCurrentTime_ = function getCurrentTime_() {
      return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    }
    ;
    _proto.getPercent = function getPercent() {
      var currentTime = this.getCurrentTime_();
      var percent;
      var liveTracker = this.player_.liveTracker;
      if (liveTracker && liveTracker.isLive()) {
        percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();
        if (liveTracker.atLiveEdge()) {
          percent = 1;
        }
      } else {
        percent = currentTime / this.player_.duration();
      }
      return percent;
    }
    ;
    _proto.handleMouseDown = function handleMouseDown(event) {
      if (!isSingleLeftClick(event)) {
        return;
      }
      event.stopPropagation();
      this.videoWasPlaying = !this.player_.paused();
      this.player_.pause();
      _Slider.prototype.handleMouseDown.call(this, event);
    }
    ;
    _proto.handleMouseMove = function handleMouseMove(event, mouseDown) {
      if (mouseDown === void 0) {
        mouseDown = false;
      }
      if (!isSingleLeftClick(event)) {
        return;
      }
      if (!mouseDown && !this.player_.scrubbing()) {
        this.player_.scrubbing(true);
      }
      var newTime;
      var distance = this.calculateDistance(event);
      var liveTracker = this.player_.liveTracker;
      if (!liveTracker || !liveTracker.isLive()) {
        newTime = distance * this.player_.duration();
        if (newTime === this.player_.duration()) {
          newTime = newTime - 0.1;
        }
      } else {
        if (distance >= 0.99) {
          liveTracker.seekToLiveEdge();
          return;
        }
        var seekableStart = liveTracker.seekableStart();
        var seekableEnd = liveTracker.liveCurrentTime();
        newTime = seekableStart + distance * liveTracker.liveWindow();
        if (newTime >= seekableEnd) {
          newTime = seekableEnd;
        }
        if (newTime <= seekableStart) {
          newTime = seekableStart + 0.1;
        }
        if (newTime === Infinity) {
          return;
        }
      }
      this.userSeek_(newTime);
    };
    _proto.enable = function enable() {
      _Slider.prototype.enable.call(this);
      var mouseTimeDisplay = this.getChild('mouseTimeDisplay');
      if (!mouseTimeDisplay) {
        return;
      }
      mouseTimeDisplay.show();
    };
    _proto.disable = function disable() {
      _Slider.prototype.disable.call(this);
      var mouseTimeDisplay = this.getChild('mouseTimeDisplay');
      if (!mouseTimeDisplay) {
        return;
      }
      mouseTimeDisplay.hide();
    }
    ;
    _proto.handleMouseUp = function handleMouseUp(event) {
      _Slider.prototype.handleMouseUp.call(this, event);
      if (event) {
        event.stopPropagation();
      }
      this.player_.scrubbing(false);
      this.player_.trigger({
        type: 'timeupdate',
        target: this,
        manuallyTriggered: true
      });
      if (this.videoWasPlaying) {
        silencePromise(this.player_.play());
      } else {
        this.update_();
      }
    }
    ;
    _proto.stepForward = function stepForward() {
      this.userSeek_(this.player_.currentTime() + STEP_SECONDS);
    }
    ;
    _proto.stepBack = function stepBack() {
      this.userSeek_(this.player_.currentTime() - STEP_SECONDS);
    }
    ;
    _proto.handleAction = function handleAction(event) {
      if (this.player_.paused()) {
        this.player_.play();
      } else {
        this.player_.pause();
      }
    }
    ;
    _proto.handleKeyDown = function handleKeyDown(event) {
      var liveTracker = this.player_.liveTracker;
      if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {
        event.preventDefault();
        event.stopPropagation();
        this.handleAction(event);
      } else if (keycode.isEventKey(event, 'Home')) {
        event.preventDefault();
        event.stopPropagation();
        this.userSeek_(0);
      } else if (keycode.isEventKey(event, 'End')) {
        event.preventDefault();
        event.stopPropagation();
        if (liveTracker && liveTracker.isLive()) {
          this.userSeek_(liveTracker.liveCurrentTime());
        } else {
          this.userSeek_(this.player_.duration());
        }
      } else if (/^[0-9]$/.test(keycode(event))) {
        event.preventDefault();
        event.stopPropagation();
        var gotoFraction = (keycode.codes[keycode(event)] - keycode.codes['0']) * 10.0 / 100.0;
        if (liveTracker && liveTracker.isLive()) {
          this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);
        } else {
          this.userSeek_(this.player_.duration() * gotoFraction);
        }
      } else if (keycode.isEventKey(event, 'PgDn')) {
        event.preventDefault();
        event.stopPropagation();
        this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);
      } else if (keycode.isEventKey(event, 'PgUp')) {
        event.preventDefault();
        event.stopPropagation();
        this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);
      } else {
        _Slider.prototype.handleKeyDown.call(this, event);
      }
    };
    _proto.dispose = function dispose() {
      this.disableInterval_();
      this.off(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);
      if (this.player_.liveTracker) {
        this.off(this.player_.liveTracker, 'liveedgechange', this.update);
      }
      this.off(this.player_, ['playing'], this.enableIntervalHandler_);
      this.off(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_);
      if ('hidden' in document && 'visibilityState' in document) {
        this.off(document, 'visibilitychange', this.toggleVisibility_);
      }
      _Slider.prototype.dispose.call(this);
    };
    return SeekBar;
  }(Slider);
  SeekBar.prototype.options_ = {
    children: ['loadProgressBar', 'playProgressBar'],
    barName: 'playProgressBar'
  };
  if (!IS_IOS && !IS_ANDROID) {
    SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');
  }
  Component$1.registerComponent('SeekBar', SeekBar);
  var ProgressControl = function (_Component) {
    inheritsLoose(ProgressControl, _Component);
    function ProgressControl(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.handleMouseMove = throttle(bind(assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
      _this.throttledHandleMouseSeek = throttle(bind(assertThisInitialized(_this), _this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);
      _this.handleMouseUpHandler_ = function (e) {
        return _this.handleMouseUp(e);
      };
      _this.handleMouseDownHandler_ = function (e) {
        return _this.handleMouseDown(e);
      };
      _this.enable();
      return _this;
    }
    var _proto = ProgressControl.prototype;
    _proto.createEl = function createEl() {
      return _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-progress-control vjs-control'
      });
    }
    ;
    _proto.handleMouseMove = function handleMouseMove(event) {
      var seekBar = this.getChild('seekBar');
      if (!seekBar) {
        return;
      }
      var playProgressBar = seekBar.getChild('playProgressBar');
      var mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');
      if (!playProgressBar && !mouseTimeDisplay) {
        return;
      }
      var seekBarEl = seekBar.el();
      var seekBarRect = findPosition(seekBarEl);
      var seekBarPoint = getPointerPosition(seekBarEl, event).x;
      seekBarPoint = clamp(seekBarPoint, 0, 1);
      if (mouseTimeDisplay) {
        mouseTimeDisplay.update(seekBarRect, seekBarPoint);
      }
      if (playProgressBar) {
        playProgressBar.update(seekBarRect, seekBar.getProgress());
      }
    }
    ;
    _proto.handleMouseSeek = function handleMouseSeek(event) {
      var seekBar = this.getChild('seekBar');
      if (seekBar) {
        seekBar.handleMouseMove(event);
      }
    }
    ;
    _proto.enabled = function enabled() {
      return this.enabled_;
    }
    ;
    _proto.disable = function disable() {
      this.children().forEach(function (child) {
        return child.disable && child.disable();
      });
      if (!this.enabled()) {
        return;
      }
      this.off(['mousedown', 'touchstart'], this.handleMouseDownHandler_);
      this.off(this.el_, 'mousemove', this.handleMouseMove);
      this.removeListenersAddedOnMousedownAndTouchstart();
      this.addClass('disabled');
      this.enabled_ = false;
      if (this.player_.scrubbing()) {
        var seekBar = this.getChild('seekBar');
        this.player_.scrubbing(false);
        if (seekBar.videoWasPlaying) {
          silencePromise(this.player_.play());
        }
      }
    }
    ;
    _proto.enable = function enable() {
      this.children().forEach(function (child) {
        return child.enable && child.enable();
      });
      if (this.enabled()) {
        return;
      }
      this.on(['mousedown', 'touchstart'], this.handleMouseDownHandler_);
      this.on(this.el_, 'mousemove', this.handleMouseMove);
      this.removeClass('disabled');
      this.enabled_ = true;
    }
    ;
    _proto.removeListenersAddedOnMousedownAndTouchstart = function removeListenersAddedOnMousedownAndTouchstart() {
      var doc = this.el_.ownerDocument;
      this.off(doc, 'mousemove', this.throttledHandleMouseSeek);
      this.off(doc, 'touchmove', this.throttledHandleMouseSeek);
      this.off(doc, 'mouseup', this.handleMouseUpHandler_);
      this.off(doc, 'touchend', this.handleMouseUpHandler_);
    }
    ;
    _proto.handleMouseDown = function handleMouseDown(event) {
      var doc = this.el_.ownerDocument;
      var seekBar = this.getChild('seekBar');
      if (seekBar) {
        seekBar.handleMouseDown(event);
      }
      this.on(doc, 'mousemove', this.throttledHandleMouseSeek);
      this.on(doc, 'touchmove', this.throttledHandleMouseSeek);
      this.on(doc, 'mouseup', this.handleMouseUpHandler_);
      this.on(doc, 'touchend', this.handleMouseUpHandler_);
    }
    ;
    _proto.handleMouseUp = function handleMouseUp(event) {
      var seekBar = this.getChild('seekBar');
      if (seekBar) {
        seekBar.handleMouseUp(event);
      }
      this.removeListenersAddedOnMousedownAndTouchstart();
    };
    return ProgressControl;
  }(Component$1);
  ProgressControl.prototype.options_ = {
    children: ['seekBar']
  };
  Component$1.registerComponent('ProgressControl', ProgressControl);
  var PictureInPictureToggle = function (_Button) {
    inheritsLoose(PictureInPictureToggle, _Button);
    function PictureInPictureToggle(player, options) {
      var _this;
      _this = _Button.call(this, player, options) || this;
      _this.on(player, ['enterpictureinpicture', 'leavepictureinpicture'], function (e) {
        return _this.handlePictureInPictureChange(e);
      });
      _this.on(player, ['disablepictureinpicturechanged', 'loadedmetadata'], function (e) {
        return _this.handlePictureInPictureEnabledChange(e);
      });
      _this.disable();
      return _this;
    }
    var _proto = PictureInPictureToggle.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-picture-in-picture-control " + _Button.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.handlePictureInPictureEnabledChange = function handlePictureInPictureEnabledChange() {
      if (document.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false) {
        this.enable();
      } else {
        this.disable();
      }
    }
    ;
    _proto.handlePictureInPictureChange = function handlePictureInPictureChange(event) {
      if (this.player_.isInPictureInPicture()) {
        this.controlText('Exit Picture-in-Picture');
      } else {
        this.controlText('Picture-in-Picture');
      }
      this.handlePictureInPictureEnabledChange();
    }
    ;
    _proto.handleClick = function handleClick(event) {
      if (!this.player_.isInPictureInPicture()) {
        this.player_.requestPictureInPicture();
      } else {
        this.player_.exitPictureInPicture();
      }
    };
    return PictureInPictureToggle;
  }(Button);
  PictureInPictureToggle.prototype.controlText_ = 'Picture-in-Picture';
  Component$1.registerComponent('PictureInPictureToggle', PictureInPictureToggle);
  var FullscreenToggle = function (_Button) {
    inheritsLoose(FullscreenToggle, _Button);
    function FullscreenToggle(player, options) {
      var _this;
      _this = _Button.call(this, player, options) || this;
      _this.on(player, 'fullscreenchange', function (e) {
        return _this.handleFullscreenChange(e);
      });
      if (document[player.fsApi_.fullscreenEnabled] === false) {
        _this.disable();
      }
      return _this;
    }
    var _proto = FullscreenToggle.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-fullscreen-control " + _Button.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.handleFullscreenChange = function handleFullscreenChange(event) {
      if (this.player_.isFullscreen()) {
        this.controlText('Non-Fullscreen');
      } else {
        this.controlText('Fullscreen');
      }
    }
    ;
    _proto.handleClick = function handleClick(event) {
      if (!this.player_.isFullscreen()) {
        this.player_.requestFullscreen();
      } else {
        this.player_.exitFullscreen();
      }
    };
    return FullscreenToggle;
  }(Button);
  FullscreenToggle.prototype.controlText_ = 'Fullscreen';
  Component$1.registerComponent('FullscreenToggle', FullscreenToggle);
  var checkVolumeSupport = function checkVolumeSupport(self, player) {
    if (player.tech_ && !player.tech_.featuresVolumeControl) {
      self.addClass('vjs-hidden');
    }
    self.on(player, 'loadstart', function () {
      if (!player.tech_.featuresVolumeControl) {
        self.addClass('vjs-hidden');
      } else {
        self.removeClass('vjs-hidden');
      }
    });
  };
  var VolumeLevel = function (_Component) {
    inheritsLoose(VolumeLevel, _Component);
    function VolumeLevel() {
      return _Component.apply(this, arguments) || this;
    }
    var _proto = VolumeLevel.prototype;
    _proto.createEl = function createEl() {
      var el = _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-volume-level'
      });
      el.appendChild(_Component.prototype.createEl.call(this, 'span', {
        className: 'vjs-control-text'
      }));
      return el;
    };
    return VolumeLevel;
  }(Component$1);
  Component$1.registerComponent('VolumeLevel', VolumeLevel);
  var VolumeLevelTooltip = function (_Component) {
    inheritsLoose(VolumeLevelTooltip, _Component);
    function VolumeLevelTooltip(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.update = throttle(bind(assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
      return _this;
    }
    var _proto = VolumeLevelTooltip.prototype;
    _proto.createEl = function createEl() {
      return _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-volume-tooltip'
      }, {
        'aria-hidden': 'true'
      });
    }
    ;
    _proto.update = function update(rangeBarRect, rangeBarPoint, vertical, content) {
      if (!vertical) {
        var tooltipRect = getBoundingClientRect(this.el_);
        var playerRect = getBoundingClientRect(this.player_.el());
        var volumeBarPointPx = rangeBarRect.width * rangeBarPoint;
        if (!playerRect || !tooltipRect) {
          return;
        }
        var spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;
        var spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);
        var pullTooltipBy = tooltipRect.width / 2;
        if (spaceLeftOfPoint < pullTooltipBy) {
          pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
        } else if (spaceRightOfPoint < pullTooltipBy) {
          pullTooltipBy = spaceRightOfPoint;
        }
        if (pullTooltipBy < 0) {
          pullTooltipBy = 0;
        } else if (pullTooltipBy > tooltipRect.width) {
          pullTooltipBy = tooltipRect.width;
        }
        this.el_.style.right = "-" + pullTooltipBy + "px";
      }
      this.write(content + "%");
    }
    ;
    _proto.write = function write(content) {
      textContent(this.el_, content);
    }
    ;
    _proto.updateVolume = function updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {
      var _this2 = this;
      this.requestNamedAnimationFrame('VolumeLevelTooltip#updateVolume', function () {
        _this2.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));
        if (cb) {
          cb();
        }
      });
    };
    return VolumeLevelTooltip;
  }(Component$1);
  Component$1.registerComponent('VolumeLevelTooltip', VolumeLevelTooltip);
  var MouseVolumeLevelDisplay = function (_Component) {
    inheritsLoose(MouseVolumeLevelDisplay, _Component);
    function MouseVolumeLevelDisplay(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      _this.update = throttle(bind(assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
      return _this;
    }
    var _proto = MouseVolumeLevelDisplay.prototype;
    _proto.createEl = function createEl() {
      return _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-mouse-display'
      });
    }
    ;
    _proto.update = function update(rangeBarRect, rangeBarPoint, vertical) {
      var _this2 = this;
      var volume = 100 * rangeBarPoint;
      this.getChild('volumeLevelTooltip').updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, function () {
        if (vertical) {
          _this2.el_.style.bottom = rangeBarRect.height * rangeBarPoint + "px";
        } else {
          _this2.el_.style.left = rangeBarRect.width * rangeBarPoint + "px";
        }
      });
    };
    return MouseVolumeLevelDisplay;
  }(Component$1);
  MouseVolumeLevelDisplay.prototype.options_ = {
    children: ['volumeLevelTooltip']
  };
  Component$1.registerComponent('MouseVolumeLevelDisplay', MouseVolumeLevelDisplay);
  var VolumeBar = function (_Slider) {
    inheritsLoose(VolumeBar, _Slider);
    function VolumeBar(player, options) {
      var _this;
      _this = _Slider.call(this, player, options) || this;
      _this.on('slideractive', function (e) {
        return _this.updateLastVolume_(e);
      });
      _this.on(player, 'volumechange', function (e) {
        return _this.updateARIAAttributes(e);
      });
      player.ready(function () {
        return _this.updateARIAAttributes();
      });
      return _this;
    }
    var _proto = VolumeBar.prototype;
    _proto.createEl = function createEl() {
      return _Slider.prototype.createEl.call(this, 'div', {
        className: 'vjs-volume-bar vjs-slider-bar'
      }, {
        'aria-label': this.localize('Volume Level'),
        'aria-live': 'polite'
      });
    }
    ;
    _proto.handleMouseDown = function handleMouseDown(event) {
      if (!isSingleLeftClick(event)) {
        return;
      }
      _Slider.prototype.handleMouseDown.call(this, event);
    }
    ;
    _proto.handleMouseMove = function handleMouseMove(event) {
      var mouseVolumeLevelDisplay = this.getChild('mouseVolumeLevelDisplay');
      if (mouseVolumeLevelDisplay) {
        var volumeBarEl = this.el();
        var volumeBarRect = getBoundingClientRect(volumeBarEl);
        var vertical = this.vertical();
        var volumeBarPoint = getPointerPosition(volumeBarEl, event);
        volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;
        volumeBarPoint = clamp(volumeBarPoint, 0, 1);
        mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);
      }
      if (!isSingleLeftClick(event)) {
        return;
      }
      this.checkMuted();
      this.player_.volume(this.calculateDistance(event));
    }
    ;
    _proto.checkMuted = function checkMuted() {
      if (this.player_.muted()) {
        this.player_.muted(false);
      }
    }
    ;
    _proto.getPercent = function getPercent() {
      if (this.player_.muted()) {
        return 0;
      }
      return this.player_.volume();
    }
    ;
    _proto.stepForward = function stepForward() {
      this.checkMuted();
      this.player_.volume(this.player_.volume() + 0.1);
    }
    ;
    _proto.stepBack = function stepBack() {
      this.checkMuted();
      this.player_.volume(this.player_.volume() - 0.1);
    }
    ;
    _proto.updateARIAAttributes = function updateARIAAttributes(event) {
      var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
      this.el_.setAttribute('aria-valuenow', ariaValue);
      this.el_.setAttribute('aria-valuetext', ariaValue + '%');
    }
    ;
    _proto.volumeAsPercentage_ = function volumeAsPercentage_() {
      return Math.round(this.player_.volume() * 100);
    }
    ;
    _proto.updateLastVolume_ = function updateLastVolume_() {
      var _this2 = this;
      var volumeBeforeDrag = this.player_.volume();
      this.one('sliderinactive', function () {
        if (_this2.player_.volume() === 0) {
          _this2.player_.lastVolume_(volumeBeforeDrag);
        }
      });
    };
    return VolumeBar;
  }(Slider);
  VolumeBar.prototype.options_ = {
    children: ['volumeLevel'],
    barName: 'volumeLevel'
  };
  if (!IS_IOS && !IS_ANDROID) {
    VolumeBar.prototype.options_.children.splice(0, 0, 'mouseVolumeLevelDisplay');
  }
  VolumeBar.prototype.playerEvent = 'volumechange';
  Component$1.registerComponent('VolumeBar', VolumeBar);
  var VolumeControl = function (_Component) {
    inheritsLoose(VolumeControl, _Component);
    function VolumeControl(player, options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      options.vertical = options.vertical || false;
      if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {
        options.volumeBar = options.volumeBar || {};
        options.volumeBar.vertical = options.vertical;
      }
      _this = _Component.call(this, player, options) || this;
      checkVolumeSupport(assertThisInitialized(_this), player);
      _this.throttledHandleMouseMove = throttle(bind(assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
      _this.handleMouseUpHandler_ = function (e) {
        return _this.handleMouseUp(e);
      };
      _this.on('mousedown', function (e) {
        return _this.handleMouseDown(e);
      });
      _this.on('touchstart', function (e) {
        return _this.handleMouseDown(e);
      });
      _this.on('mousemove', function (e) {
        return _this.handleMouseMove(e);
      });
      _this.on(_this.volumeBar, ['focus', 'slideractive'], function () {
        _this.volumeBar.addClass('vjs-slider-active');
        _this.addClass('vjs-slider-active');
        _this.trigger('slideractive');
      });
      _this.on(_this.volumeBar, ['blur', 'sliderinactive'], function () {
        _this.volumeBar.removeClass('vjs-slider-active');
        _this.removeClass('vjs-slider-active');
        _this.trigger('sliderinactive');
      });
      return _this;
    }
    var _proto = VolumeControl.prototype;
    _proto.createEl = function createEl() {
      var orientationClass = 'vjs-volume-horizontal';
      if (this.options_.vertical) {
        orientationClass = 'vjs-volume-vertical';
      }
      return _Component.prototype.createEl.call(this, 'div', {
        className: "vjs-volume-control vjs-control " + orientationClass
      });
    }
    ;
    _proto.handleMouseDown = function handleMouseDown(event) {
      var doc = this.el_.ownerDocument;
      this.on(doc, 'mousemove', this.throttledHandleMouseMove);
      this.on(doc, 'touchmove', this.throttledHandleMouseMove);
      this.on(doc, 'mouseup', this.handleMouseUpHandler_);
      this.on(doc, 'touchend', this.handleMouseUpHandler_);
    }
    ;
    _proto.handleMouseUp = function handleMouseUp(event) {
      var doc = this.el_.ownerDocument;
      this.off(doc, 'mousemove', this.throttledHandleMouseMove);
      this.off(doc, 'touchmove', this.throttledHandleMouseMove);
      this.off(doc, 'mouseup', this.handleMouseUpHandler_);
      this.off(doc, 'touchend', this.handleMouseUpHandler_);
    }
    ;
    _proto.handleMouseMove = function handleMouseMove(event) {
      this.volumeBar.handleMouseMove(event);
    };
    return VolumeControl;
  }(Component$1);
  VolumeControl.prototype.options_ = {
    children: ['volumeBar']
  };
  Component$1.registerComponent('VolumeControl', VolumeControl);
  var checkMuteSupport = function checkMuteSupport(self, player) {
    if (player.tech_ && !player.tech_.featuresMuteControl) {
      self.addClass('vjs-hidden');
    }
    self.on(player, 'loadstart', function () {
      if (!player.tech_.featuresMuteControl) {
        self.addClass('vjs-hidden');
      } else {
        self.removeClass('vjs-hidden');
      }
    });
  };
  var MuteToggle = function (_Button) {
    inheritsLoose(MuteToggle, _Button);
    function MuteToggle(player, options) {
      var _this;
      _this = _Button.call(this, player, options) || this;
      checkMuteSupport(assertThisInitialized(_this), player);
      _this.on(player, ['loadstart', 'volumechange'], function (e) {
        return _this.update(e);
      });
      return _this;
    }
    var _proto = MuteToggle.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-mute-control " + _Button.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.handleClick = function handleClick(event) {
      var vol = this.player_.volume();
      var lastVolume = this.player_.lastVolume_();
      if (vol === 0) {
        var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;
        this.player_.volume(volumeToSet);
        this.player_.muted(false);
      } else {
        this.player_.muted(this.player_.muted() ? false : true);
      }
    }
    ;
    _proto.update = function update(event) {
      this.updateIcon_();
      this.updateControlText_();
    }
    ;
    _proto.updateIcon_ = function updateIcon_() {
      var vol = this.player_.volume();
      var level = 3;
      if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {
        this.player_.muted(this.player_.tech_.el_.muted);
      }
      if (vol === 0 || this.player_.muted()) {
        level = 0;
      } else if (vol < 0.33) {
        level = 1;
      } else if (vol < 0.67) {
        level = 2;
      }
      for (var i = 0; i < 4; i++) {
        removeClass(this.el_, "vjs-vol-" + i);
      }
      addClass(this.el_, "vjs-vol-" + level);
    }
    ;
    _proto.updateControlText_ = function updateControlText_() {
      var soundOff = this.player_.muted() || this.player_.volume() === 0;
      var text = soundOff ? 'Unmute' : 'Mute';
      if (this.controlText() !== text) {
        this.controlText(text);
      }
    };
    return MuteToggle;
  }(Button);
  MuteToggle.prototype.controlText_ = 'Mute';
  Component$1.registerComponent('MuteToggle', MuteToggle);
  var VolumePanel = function (_Component) {
    inheritsLoose(VolumePanel, _Component);
    function VolumePanel(player, options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      if (typeof options.inline !== 'undefined') {
        options.inline = options.inline;
      } else {
        options.inline = true;
      }
      if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {
        options.volumeControl = options.volumeControl || {};
        options.volumeControl.vertical = !options.inline;
      }
      _this = _Component.call(this, player, options) || this;
      _this.handleKeyPressHandler_ = function (e) {
        return _this.handleKeyPress(e);
      };
      _this.on(player, ['loadstart'], function (e) {
        return _this.volumePanelState_(e);
      });
      _this.on(_this.muteToggle, 'keyup', function (e) {
        return _this.handleKeyPress(e);
      });
      _this.on(_this.volumeControl, 'keyup', function (e) {
        return _this.handleVolumeControlKeyUp(e);
      });
      _this.on('keydown', function (e) {
        return _this.handleKeyPress(e);
      });
      _this.on('mouseover', function (e) {
        return _this.handleMouseOver(e);
      });
      _this.on('mouseout', function (e) {
        return _this.handleMouseOut(e);
      });
      _this.on(_this.volumeControl, ['slideractive'], _this.sliderActive_);
      _this.on(_this.volumeControl, ['sliderinactive'], _this.sliderInactive_);
      return _this;
    }
    var _proto = VolumePanel.prototype;
    _proto.sliderActive_ = function sliderActive_() {
      this.addClass('vjs-slider-active');
    }
    ;
    _proto.sliderInactive_ = function sliderInactive_() {
      this.removeClass('vjs-slider-active');
    }
    ;
    _proto.volumePanelState_ = function volumePanelState_() {
      if (this.volumeControl.hasClass('vjs-hidden') && this.muteToggle.hasClass('vjs-hidden')) {
        this.addClass('vjs-hidden');
      }
      if (this.volumeControl.hasClass('vjs-hidden') && !this.muteToggle.hasClass('vjs-hidden')) {
        this.addClass('vjs-mute-toggle-only');
      }
    }
    ;
    _proto.createEl = function createEl() {
      var orientationClass = 'vjs-volume-panel-horizontal';
      if (!this.options_.inline) {
        orientationClass = 'vjs-volume-panel-vertical';
      }
      return _Component.prototype.createEl.call(this, 'div', {
        className: "vjs-volume-panel vjs-control " + orientationClass
      });
    }
    ;
    _proto.dispose = function dispose() {
      this.handleMouseOut();
      _Component.prototype.dispose.call(this);
    }
    ;
    _proto.handleVolumeControlKeyUp = function handleVolumeControlKeyUp(event) {
      if (keycode.isEventKey(event, 'Esc')) {
        this.muteToggle.focus();
      }
    }
    ;
    _proto.handleMouseOver = function handleMouseOver(event) {
      this.addClass('vjs-hover');
      on(document, 'keyup', this.handleKeyPressHandler_);
    }
    ;
    _proto.handleMouseOut = function handleMouseOut(event) {
      this.removeClass('vjs-hover');
      off(document, 'keyup', this.handleKeyPressHandler_);
    }
    ;
    _proto.handleKeyPress = function handleKeyPress(event) {
      if (keycode.isEventKey(event, 'Esc')) {
        this.handleMouseOut();
      }
    };
    return VolumePanel;
  }(Component$1);
  VolumePanel.prototype.options_ = {
    children: ['muteToggle', 'volumeControl']
  };
  Component$1.registerComponent('VolumePanel', VolumePanel);
  var Menu = function (_Component) {
    inheritsLoose(Menu, _Component);
    function Menu(player, options) {
      var _this;
      _this = _Component.call(this, player, options) || this;
      if (options) {
        _this.menuButton_ = options.menuButton;
      }
      _this.focusedChild_ = -1;
      _this.on('keydown', function (e) {
        return _this.handleKeyDown(e);
      });
      _this.boundHandleBlur_ = function (e) {
        return _this.handleBlur(e);
      };
      _this.boundHandleTapClick_ = function (e) {
        return _this.handleTapClick(e);
      };
      return _this;
    }
    var _proto = Menu.prototype;
    _proto.addEventListenerForItem = function addEventListenerForItem(component) {
      if (!(component instanceof Component$1)) {
        return;
      }
      this.on(component, 'blur', this.boundHandleBlur_);
      this.on(component, ['tap', 'click'], this.boundHandleTapClick_);
    }
    ;
    _proto.removeEventListenerForItem = function removeEventListenerForItem(component) {
      if (!(component instanceof Component$1)) {
        return;
      }
      this.off(component, 'blur', this.boundHandleBlur_);
      this.off(component, ['tap', 'click'], this.boundHandleTapClick_);
    }
    ;
    _proto.removeChild = function removeChild(component) {
      if (typeof component === 'string') {
        component = this.getChild(component);
      }
      this.removeEventListenerForItem(component);
      _Component.prototype.removeChild.call(this, component);
    }
    ;
    _proto.addItem = function addItem(component) {
      var childComponent = this.addChild(component);
      if (childComponent) {
        this.addEventListenerForItem(childComponent);
      }
    }
    ;
    _proto.createEl = function createEl$1() {
      var contentElType = this.options_.contentElType || 'ul';
      this.contentEl_ = createEl(contentElType, {
        className: 'vjs-menu-content'
      });
      this.contentEl_.setAttribute('role', 'menu');
      var el = _Component.prototype.createEl.call(this, 'div', {
        append: this.contentEl_,
        className: 'vjs-menu'
      });
      el.appendChild(this.contentEl_);
      on(el, 'click', function (event) {
        event.preventDefault();
        event.stopImmediatePropagation();
      });
      return el;
    };
    _proto.dispose = function dispose() {
      this.contentEl_ = null;
      this.boundHandleBlur_ = null;
      this.boundHandleTapClick_ = null;
      _Component.prototype.dispose.call(this);
    }
    ;
    _proto.handleBlur = function handleBlur(event) {
      var relatedTarget = event.relatedTarget || document.activeElement;
      if (!this.children().some(function (element) {
        return element.el() === relatedTarget;
      })) {
        var btn = this.menuButton_;
        if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {
          btn.unpressButton();
        }
      }
    }
    ;
    _proto.handleTapClick = function handleTapClick(event) {
      if (this.menuButton_) {
        this.menuButton_.unpressButton();
        var childComponents = this.children();
        if (!Array.isArray(childComponents)) {
          return;
        }
        var foundComponent = childComponents.filter(function (component) {
          return component.el() === event.target;
        })[0];
        if (!foundComponent) {
          return;
        }
        if (foundComponent.name() !== 'CaptionSettingsMenuItem') {
          this.menuButton_.focus();
        }
      }
    }
    ;
    _proto.handleKeyDown = function handleKeyDown(event) {
      if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {
        event.preventDefault();
        event.stopPropagation();
        this.stepForward();
      } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {
        event.preventDefault();
        event.stopPropagation();
        this.stepBack();
      }
    }
    ;
    _proto.stepForward = function stepForward() {
      var stepChild = 0;
      if (this.focusedChild_ !== undefined) {
        stepChild = this.focusedChild_ + 1;
      }
      this.focus(stepChild);
    }
    ;
    _proto.stepBack = function stepBack() {
      var stepChild = 0;
      if (this.focusedChild_ !== undefined) {
        stepChild = this.focusedChild_ - 1;
      }
      this.focus(stepChild);
    }
    ;
    _proto.focus = function focus(item) {
      if (item === void 0) {
        item = 0;
      }
      var children = this.children().slice();
      var haveTitle = children.length && children[0].hasClass('vjs-menu-title');
      if (haveTitle) {
        children.shift();
      }
      if (children.length > 0) {
        if (item < 0) {
          item = 0;
        } else if (item >= children.length) {
          item = children.length - 1;
        }
        this.focusedChild_ = item;
        children[item].el_.focus();
      }
    };
    return Menu;
  }(Component$1);
  Component$1.registerComponent('Menu', Menu);
  var MenuButton = function (_Component) {
    inheritsLoose(MenuButton, _Component);
    function MenuButton(player, options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      _this = _Component.call(this, player, options) || this;
      _this.menuButton_ = new Button(player, options);
      _this.menuButton_.controlText(_this.controlText_);
      _this.menuButton_.el_.setAttribute('aria-haspopup', 'true');
      var buttonClass = Button.prototype.buildCSSClass();
      _this.menuButton_.el_.className = _this.buildCSSClass() + ' ' + buttonClass;
      _this.menuButton_.removeClass('vjs-control');
      _this.addChild(_this.menuButton_);
      _this.update();
      _this.enabled_ = true;
      var handleClick = function handleClick(e) {
        return _this.handleClick(e);
      };
      _this.handleMenuKeyUp_ = function (e) {
        return _this.handleMenuKeyUp(e);
      };
      _this.on(_this.menuButton_, 'tap', handleClick);
      _this.on(_this.menuButton_, 'click', handleClick);
      _this.on(_this.menuButton_, 'keydown', function (e) {
        return _this.handleKeyDown(e);
      });
      _this.on(_this.menuButton_, 'mouseenter', function () {
        _this.addClass('vjs-hover');
        _this.menu.show();
        on(document, 'keyup', _this.handleMenuKeyUp_);
      });
      _this.on('mouseleave', function (e) {
        return _this.handleMouseLeave(e);
      });
      _this.on('keydown', function (e) {
        return _this.handleSubmenuKeyDown(e);
      });
      return _this;
    }
    var _proto = MenuButton.prototype;
    _proto.update = function update() {
      var menu = this.createMenu();
      if (this.menu) {
        this.menu.dispose();
        this.removeChild(this.menu);
      }
      this.menu = menu;
      this.addChild(menu);
      this.buttonPressed_ = false;
      this.menuButton_.el_.setAttribute('aria-expanded', 'false');
      if (this.items && this.items.length <= this.hideThreshold_) {
        this.hide();
      } else {
        this.show();
      }
    }
    ;
    _proto.createMenu = function createMenu() {
      var menu = new Menu(this.player_, {
        menuButton: this
      });
      this.hideThreshold_ = 0;
      if (this.options_.title) {
        var titleEl = createEl('li', {
          className: 'vjs-menu-title',
          textContent: toTitleCase$1(this.options_.title),
          tabIndex: -1
        });
        var titleComponent = new Component$1(this.player_, {
          el: titleEl
        });
        menu.addItem(titleComponent);
      }
      this.items = this.createItems();
      if (this.items) {
        for (var i = 0; i < this.items.length; i++) {
          menu.addItem(this.items[i]);
        }
      }
      return menu;
    }
    ;
    _proto.createItems = function createItems() {}
    ;
    _proto.createEl = function createEl() {
      return _Component.prototype.createEl.call(this, 'div', {
        className: this.buildWrapperCSSClass()
      }, {});
    }
    ;
    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
      var menuButtonClass = 'vjs-menu-button';
      if (this.options_.inline === true) {
        menuButtonClass += '-inline';
      } else {
        menuButtonClass += '-popup';
      }
      var buttonClass = Button.prototype.buildCSSClass();
      return "vjs-menu-button " + menuButtonClass + " " + buttonClass + " " + _Component.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.buildCSSClass = function buildCSSClass() {
      var menuButtonClass = 'vjs-menu-button';
      if (this.options_.inline === true) {
        menuButtonClass += '-inline';
      } else {
        menuButtonClass += '-popup';
      }
      return "vjs-menu-button " + menuButtonClass + " " + _Component.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.controlText = function controlText(text, el) {
      if (el === void 0) {
        el = this.menuButton_.el();
      }
      return this.menuButton_.controlText(text, el);
    }
    ;
    _proto.dispose = function dispose() {
      this.handleMouseLeave();
      _Component.prototype.dispose.call(this);
    }
    ;
    _proto.handleClick = function handleClick(event) {
      if (this.buttonPressed_) {
        this.unpressButton();
      } else {
        this.pressButton();
      }
    }
    ;
    _proto.handleMouseLeave = function handleMouseLeave(event) {
      this.removeClass('vjs-hover');
      off(document, 'keyup', this.handleMenuKeyUp_);
    }
    ;
    _proto.focus = function focus() {
      this.menuButton_.focus();
    }
    ;
    _proto.blur = function blur() {
      this.menuButton_.blur();
    }
    ;
    _proto.handleKeyDown = function handleKeyDown(event) {
      if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {
        if (this.buttonPressed_) {
          this.unpressButton();
        }
        if (!keycode.isEventKey(event, 'Tab')) {
          event.preventDefault();
          this.menuButton_.focus();
        }
      } else if (keycode.isEventKey(event, 'Up') || keycode.isEventKey(event, 'Down')) {
        if (!this.buttonPressed_) {
          event.preventDefault();
          this.pressButton();
        }
      }
    }
    ;
    _proto.handleMenuKeyUp = function handleMenuKeyUp(event) {
      if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {
        this.removeClass('vjs-hover');
      }
    }
    ;
    _proto.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {
      this.handleSubmenuKeyDown(event);
    }
    ;
    _proto.handleSubmenuKeyDown = function handleSubmenuKeyDown(event) {
      if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {
        if (this.buttonPressed_) {
          this.unpressButton();
        }
        if (!keycode.isEventKey(event, 'Tab')) {
          event.preventDefault();
          this.menuButton_.focus();
        }
      }
    }
    ;
    _proto.pressButton = function pressButton() {
      if (this.enabled_) {
        this.buttonPressed_ = true;
        this.menu.show();
        this.menu.lockShowing();
        this.menuButton_.el_.setAttribute('aria-expanded', 'true');
        if (IS_IOS && isInFrame()) {
          return;
        }
        this.menu.focus();
      }
    }
    ;
    _proto.unpressButton = function unpressButton() {
      if (this.enabled_) {
        this.buttonPressed_ = false;
        this.menu.unlockShowing();
        this.menu.hide();
        this.menuButton_.el_.setAttribute('aria-expanded', 'false');
      }
    }
    ;
    _proto.disable = function disable() {
      this.unpressButton();
      this.enabled_ = false;
      this.addClass('vjs-disabled');
      this.menuButton_.disable();
    }
    ;
    _proto.enable = function enable() {
      this.enabled_ = true;
      this.removeClass('vjs-disabled');
      this.menuButton_.enable();
    };
    return MenuButton;
  }(Component$1);
  Component$1.registerComponent('MenuButton', MenuButton);
  var TrackButton = function (_MenuButton) {
    inheritsLoose(TrackButton, _MenuButton);
    function TrackButton(player, options) {
      var _this;
      var tracks = options.tracks;
      _this = _MenuButton.call(this, player, options) || this;
      if (_this.items.length <= 1) {
        _this.hide();
      }
      if (!tracks) {
        return assertThisInitialized(_this);
      }
      var updateHandler = bind(assertThisInitialized(_this), _this.update);
      tracks.addEventListener('removetrack', updateHandler);
      tracks.addEventListener('addtrack', updateHandler);
      tracks.addEventListener('labelchange', updateHandler);
      _this.player_.on('ready', updateHandler);
      _this.player_.on('dispose', function () {
        tracks.removeEventListener('removetrack', updateHandler);
        tracks.removeEventListener('addtrack', updateHandler);
        tracks.removeEventListener('labelchange', updateHandler);
      });
      return _this;
    }
    return TrackButton;
  }(MenuButton);
  Component$1.registerComponent('TrackButton', TrackButton);
  var MenuKeys = ['Tab', 'Esc', 'Up', 'Down', 'Right', 'Left'];
  var MenuItem = function (_ClickableComponent) {
    inheritsLoose(MenuItem, _ClickableComponent);
    function MenuItem(player, options) {
      var _this;
      _this = _ClickableComponent.call(this, player, options) || this;
      _this.selectable = options.selectable;
      _this.isSelected_ = options.selected || false;
      _this.multiSelectable = options.multiSelectable;
      _this.selected(_this.isSelected_);
      if (_this.selectable) {
        if (_this.multiSelectable) {
          _this.el_.setAttribute('role', 'menuitemcheckbox');
        } else {
          _this.el_.setAttribute('role', 'menuitemradio');
        }
      } else {
        _this.el_.setAttribute('role', 'menuitem');
      }
      return _this;
    }
    var _proto = MenuItem.prototype;
    _proto.createEl = function createEl$1(type, props, attrs) {
      this.nonIconControl = true;
      var el = _ClickableComponent.prototype.createEl.call(this, 'li', assign({
        className: 'vjs-menu-item',
        tabIndex: -1
      }, props), attrs);
      el.replaceChild(createEl('span', {
        className: 'vjs-menu-item-text',
        textContent: this.localize(this.options_.label)
      }), el.querySelector('.vjs-icon-placeholder'));
      return el;
    }
    ;
    _proto.handleKeyDown = function handleKeyDown(event) {
      if (!MenuKeys.some(function (key) {
        return keycode.isEventKey(event, key);
      })) {
        _ClickableComponent.prototype.handleKeyDown.call(this, event);
      }
    }
    ;
    _proto.handleClick = function handleClick(event) {
      this.selected(true);
    }
    ;
    _proto.selected = function selected(_selected) {
      if (this.selectable) {
        if (_selected) {
          this.addClass('vjs-selected');
          this.el_.setAttribute('aria-checked', 'true');
          this.controlText(', selected');
          this.isSelected_ = true;
        } else {
          this.removeClass('vjs-selected');
          this.el_.setAttribute('aria-checked', 'false');
          this.controlText('');
          this.isSelected_ = false;
        }
      }
    };
    return MenuItem;
  }(ClickableComponent);
  Component$1.registerComponent('MenuItem', MenuItem);
  var TextTrackMenuItem = function (_MenuItem) {
    inheritsLoose(TextTrackMenuItem, _MenuItem);
    function TextTrackMenuItem(player, options) {
      var _this;
      var track = options.track;
      var tracks = player.textTracks();
      options.label = track.label || track.language || 'Unknown';
      options.selected = track.mode === 'showing';
      _this = _MenuItem.call(this, player, options) || this;
      _this.track = track;
      _this.kinds = (options.kinds || [options.kind || _this.track.kind]).filter(Boolean);
      var changeHandler = function changeHandler() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this.handleTracksChange.apply(assertThisInitialized(_this), args);
      };
      var selectedLanguageChangeHandler = function selectedLanguageChangeHandler() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        _this.handleSelectedLanguageChange.apply(assertThisInitialized(_this), args);
      };
      player.on(['loadstart', 'texttrackchange'], changeHandler);
      tracks.addEventListener('change', changeHandler);
      tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
      _this.on('dispose', function () {
        player.off(['loadstart', 'texttrackchange'], changeHandler);
        tracks.removeEventListener('change', changeHandler);
        tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
      });
      if (tracks.onchange === undefined) {
        var event;
        _this.on(['tap', 'click'], function () {
          if (typeof window.Event !== 'object') {
            try {
              event = new window.Event('change');
            } catch (err) {
            }
          }
          if (!event) {
            event = document.createEvent('Event');
            event.initEvent('change', true, true);
          }
          tracks.dispatchEvent(event);
        });
      }
      _this.handleTracksChange();
      return _this;
    }
    var _proto = TextTrackMenuItem.prototype;
    _proto.handleClick = function handleClick(event) {
      var referenceTrack = this.track;
      var tracks = this.player_.textTracks();
      _MenuItem.prototype.handleClick.call(this, event);
      if (!tracks) {
        return;
      }
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        if (this.kinds.indexOf(track.kind) === -1) {
          continue;
        }
        if (track === referenceTrack) {
          if (track.mode !== 'showing') {
            track.mode = 'showing';
          }
        } else if (track.mode !== 'disabled') {
          track.mode = 'disabled';
        }
      }
    }
    ;
    _proto.handleTracksChange = function handleTracksChange(event) {
      var shouldBeSelected = this.track.mode === 'showing';
      if (shouldBeSelected !== this.isSelected_) {
        this.selected(shouldBeSelected);
      }
    };
    _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
      if (this.track.mode === 'showing') {
        var selectedLanguage = this.player_.cache_.selectedLanguage;
        if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
          return;
        }
        this.player_.cache_.selectedLanguage = {
          enabled: true,
          language: this.track.language,
          kind: this.track.kind
        };
      }
    };
    _proto.dispose = function dispose() {
      this.track = null;
      _MenuItem.prototype.dispose.call(this);
    };
    return TextTrackMenuItem;
  }(MenuItem);
  Component$1.registerComponent('TextTrackMenuItem', TextTrackMenuItem);
  var OffTextTrackMenuItem = function (_TextTrackMenuItem) {
    inheritsLoose(OffTextTrackMenuItem, _TextTrackMenuItem);
    function OffTextTrackMenuItem(player, options) {
      options.track = {
        player: player,
        kind: options.kind,
        kinds: options.kinds,
        "default": false,
        mode: 'disabled'
      };
      if (!options.kinds) {
        options.kinds = [options.kind];
      }
      if (options.label) {
        options.track.label = options.label;
      } else {
        options.track.label = options.kinds.join(' and ') + ' off';
      }
      options.selectable = true;
      options.multiSelectable = false;
      return _TextTrackMenuItem.call(this, player, options) || this;
    }
    var _proto = OffTextTrackMenuItem.prototype;
    _proto.handleTracksChange = function handleTracksChange(event) {
      var tracks = this.player().textTracks();
      var shouldBeSelected = true;
      for (var i = 0, l = tracks.length; i < l; i++) {
        var track = tracks[i];
        if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {
          shouldBeSelected = false;
          break;
        }
      }
      if (shouldBeSelected !== this.isSelected_) {
        this.selected(shouldBeSelected);
      }
    };
    _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
      var tracks = this.player().textTracks();
      var allHidden = true;
      for (var i = 0, l = tracks.length; i < l; i++) {
        var track = tracks[i];
        if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {
          allHidden = false;
          break;
        }
      }
      if (allHidden) {
        this.player_.cache_.selectedLanguage = {
          enabled: false
        };
      }
    };
    return OffTextTrackMenuItem;
  }(TextTrackMenuItem);
  Component$1.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);
  var TextTrackButton = function (_TrackButton) {
    inheritsLoose(TextTrackButton, _TrackButton);
    function TextTrackButton(player, options) {
      if (options === void 0) {
        options = {};
      }
      options.tracks = player.textTracks();
      return _TrackButton.call(this, player, options) || this;
    }
    var _proto = TextTrackButton.prototype;
    _proto.createItems = function createItems(items, TrackMenuItem) {
      if (items === void 0) {
        items = [];
      }
      if (TrackMenuItem === void 0) {
        TrackMenuItem = TextTrackMenuItem;
      }
      var label;
      if (this.label_) {
        label = this.label_ + " off";
      }
      items.push(new OffTextTrackMenuItem(this.player_, {
        kinds: this.kinds_,
        kind: this.kind_,
        label: label
      }));
      this.hideThreshold_ += 1;
      var tracks = this.player_.textTracks();
      if (!Array.isArray(this.kinds_)) {
        this.kinds_ = [this.kind_];
      }
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        if (this.kinds_.indexOf(track.kind) > -1) {
          var item = new TrackMenuItem(this.player_, {
            track: track,
            kinds: this.kinds_,
            kind: this.kind_,
            selectable: true,
            multiSelectable: false
          });
          item.addClass("vjs-" + track.kind + "-menu-item");
          items.push(item);
        }
      }
      return items;
    };
    return TextTrackButton;
  }(TrackButton);
  Component$1.registerComponent('TextTrackButton', TextTrackButton);
  var ChaptersTrackMenuItem = function (_MenuItem) {
    inheritsLoose(ChaptersTrackMenuItem, _MenuItem);
    function ChaptersTrackMenuItem(player, options) {
      var _this;
      var track = options.track;
      var cue = options.cue;
      var currentTime = player.currentTime();
      options.selectable = true;
      options.multiSelectable = false;
      options.label = cue.text;
      options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
      _this = _MenuItem.call(this, player, options) || this;
      _this.track = track;
      _this.cue = cue;
      track.addEventListener('cuechange', bind(assertThisInitialized(_this), _this.update));
      return _this;
    }
    var _proto = ChaptersTrackMenuItem.prototype;
    _proto.handleClick = function handleClick(event) {
      _MenuItem.prototype.handleClick.call(this);
      this.player_.currentTime(this.cue.startTime);
      this.update(this.cue.startTime);
    }
    ;
    _proto.update = function update(event) {
      var cue = this.cue;
      var currentTime = this.player_.currentTime();
      this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);
    };
    return ChaptersTrackMenuItem;
  }(MenuItem);
  Component$1.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);
  var ChaptersButton = function (_TextTrackButton) {
    inheritsLoose(ChaptersButton, _TextTrackButton);
    function ChaptersButton(player, options, ready) {
      return _TextTrackButton.call(this, player, options, ready) || this;
    }
    var _proto = ChaptersButton.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-chapters-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
    };
    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
      return "vjs-chapters-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
    }
    ;
    _proto.update = function update(event) {
      if (!this.track_ || event && (event.type === 'addtrack' || event.type === 'removetrack')) {
        this.setTrack(this.findChaptersTrack());
      }
      _TextTrackButton.prototype.update.call(this);
    }
    ;
    _proto.setTrack = function setTrack(track) {
      if (this.track_ === track) {
        return;
      }
      if (!this.updateHandler_) {
        this.updateHandler_ = this.update.bind(this);
      }
      if (this.track_) {
        var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        if (remoteTextTrackEl) {
          remoteTextTrackEl.removeEventListener('load', this.updateHandler_);
        }
        this.track_ = null;
      }
      this.track_ = track;
      if (this.track_) {
        this.track_.mode = 'hidden';
        var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        if (_remoteTextTrackEl) {
          _remoteTextTrackEl.addEventListener('load', this.updateHandler_);
        }
      }
    }
    ;
    _proto.findChaptersTrack = function findChaptersTrack() {
      var tracks = this.player_.textTracks() || [];
      for (var i = tracks.length - 1; i >= 0; i--) {
        var track = tracks[i];
        if (track.kind === this.kind_) {
          return track;
        }
      }
    }
    ;
    _proto.getMenuCaption = function getMenuCaption() {
      if (this.track_ && this.track_.label) {
        return this.track_.label;
      }
      return this.localize(toTitleCase$1(this.kind_));
    }
    ;
    _proto.createMenu = function createMenu() {
      this.options_.title = this.getMenuCaption();
      return _TextTrackButton.prototype.createMenu.call(this);
    }
    ;
    _proto.createItems = function createItems() {
      var items = [];
      if (!this.track_) {
        return items;
      }
      var cues = this.track_.cues;
      if (!cues) {
        return items;
      }
      for (var i = 0, l = cues.length; i < l; i++) {
        var cue = cues[i];
        var mi = new ChaptersTrackMenuItem(this.player_, {
          track: this.track_,
          cue: cue
        });
        items.push(mi);
      }
      return items;
    };
    return ChaptersButton;
  }(TextTrackButton);
  ChaptersButton.prototype.kind_ = 'chapters';
  ChaptersButton.prototype.controlText_ = 'Chapters';
  Component$1.registerComponent('ChaptersButton', ChaptersButton);
  var DescriptionsButton = function (_TextTrackButton) {
    inheritsLoose(DescriptionsButton, _TextTrackButton);
    function DescriptionsButton(player, options, ready) {
      var _this;
      _this = _TextTrackButton.call(this, player, options, ready) || this;
      var tracks = player.textTracks();
      var changeHandler = bind(assertThisInitialized(_this), _this.handleTracksChange);
      tracks.addEventListener('change', changeHandler);
      _this.on('dispose', function () {
        tracks.removeEventListener('change', changeHandler);
      });
      return _this;
    }
    var _proto = DescriptionsButton.prototype;
    _proto.handleTracksChange = function handleTracksChange(event) {
      var tracks = this.player().textTracks();
      var disabled = false;
      for (var i = 0, l = tracks.length; i < l; i++) {
        var track = tracks[i];
        if (track.kind !== this.kind_ && track.mode === 'showing') {
          disabled = true;
          break;
        }
      }
      if (disabled) {
        this.disable();
      } else {
        this.enable();
      }
    }
    ;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-descriptions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
    };
    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
      return "vjs-descriptions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
    };
    return DescriptionsButton;
  }(TextTrackButton);
  DescriptionsButton.prototype.kind_ = 'descriptions';
  DescriptionsButton.prototype.controlText_ = 'Descriptions';
  Component$1.registerComponent('DescriptionsButton', DescriptionsButton);
  var SubtitlesButton = function (_TextTrackButton) {
    inheritsLoose(SubtitlesButton, _TextTrackButton);
    function SubtitlesButton(player, options, ready) {
      return _TextTrackButton.call(this, player, options, ready) || this;
    }
    var _proto = SubtitlesButton.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-subtitles-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
    };
    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
      return "vjs-subtitles-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
    };
    return SubtitlesButton;
  }(TextTrackButton);
  SubtitlesButton.prototype.kind_ = 'subtitles';
  SubtitlesButton.prototype.controlText_ = 'Subtitles';
  Component$1.registerComponent('SubtitlesButton', SubtitlesButton);
  var CaptionSettingsMenuItem = function (_TextTrackMenuItem) {
    inheritsLoose(CaptionSettingsMenuItem, _TextTrackMenuItem);
    function CaptionSettingsMenuItem(player, options) {
      var _this;
      options.track = {
        player: player,
        kind: options.kind,
        label: options.kind + ' settings',
        selectable: false,
        "default": false,
        mode: 'disabled'
      };
      options.selectable = false;
      options.name = 'CaptionSettingsMenuItem';
      _this = _TextTrackMenuItem.call(this, player, options) || this;
      _this.addClass('vjs-texttrack-settings');
      _this.controlText(', opens ' + options.kind + ' settings dialog');
      return _this;
    }
    var _proto = CaptionSettingsMenuItem.prototype;
    _proto.handleClick = function handleClick(event) {
      this.player().getChild('textTrackSettings').open();
    };
    return CaptionSettingsMenuItem;
  }(TextTrackMenuItem);
  Component$1.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);
  var CaptionsButton = function (_TextTrackButton) {
    inheritsLoose(CaptionsButton, _TextTrackButton);
    function CaptionsButton(player, options, ready) {
      return _TextTrackButton.call(this, player, options, ready) || this;
    }
    var _proto = CaptionsButton.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-captions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
    };
    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
      return "vjs-captions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
    }
    ;
    _proto.createItems = function createItems() {
      var items = [];
      if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {
        items.push(new CaptionSettingsMenuItem(this.player_, {
          kind: this.kind_
        }));
        this.hideThreshold_ += 1;
      }
      return _TextTrackButton.prototype.createItems.call(this, items);
    };
    return CaptionsButton;
  }(TextTrackButton);
  CaptionsButton.prototype.kind_ = 'captions';
  CaptionsButton.prototype.controlText_ = 'Captions';
  Component$1.registerComponent('CaptionsButton', CaptionsButton);
  var SubsCapsMenuItem = function (_TextTrackMenuItem) {
    inheritsLoose(SubsCapsMenuItem, _TextTrackMenuItem);
    function SubsCapsMenuItem() {
      return _TextTrackMenuItem.apply(this, arguments) || this;
    }
    var _proto = SubsCapsMenuItem.prototype;
    _proto.createEl = function createEl$1(type, props, attrs) {
      var el = _TextTrackMenuItem.prototype.createEl.call(this, type, props, attrs);
      var parentSpan = el.querySelector('.vjs-menu-item-text');
      if (this.options_.track.kind === 'captions') {
        parentSpan.appendChild(createEl('span', {
          className: 'vjs-icon-placeholder'
        }, {
          'aria-hidden': true
        }));
        parentSpan.appendChild(createEl('span', {
          className: 'vjs-control-text',
          textContent: " " + this.localize('Captions')
        }));
      }
      return el;
    };
    return SubsCapsMenuItem;
  }(TextTrackMenuItem);
  Component$1.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);
  var SubsCapsButton = function (_TextTrackButton) {
    inheritsLoose(SubsCapsButton, _TextTrackButton);
    function SubsCapsButton(player, options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      _this = _TextTrackButton.call(this, player, options) || this;
      _this.label_ = 'subtitles';
      if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(_this.player_.language_) > -1) {
        _this.label_ = 'captions';
      }
      _this.menuButton_.controlText(toTitleCase$1(_this.label_));
      return _this;
    }
    var _proto = SubsCapsButton.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
    };
    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
      return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
    }
    ;
    _proto.createItems = function createItems() {
      var items = [];
      if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {
        items.push(new CaptionSettingsMenuItem(this.player_, {
          kind: this.label_
        }));
        this.hideThreshold_ += 1;
      }
      items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
      return items;
    };
    return SubsCapsButton;
  }(TextTrackButton);
  SubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];
  SubsCapsButton.prototype.controlText_ = 'Subtitles';
  Component$1.registerComponent('SubsCapsButton', SubsCapsButton);
  var AudioTrackMenuItem = function (_MenuItem) {
    inheritsLoose(AudioTrackMenuItem, _MenuItem);
    function AudioTrackMenuItem(player, options) {
      var _this;
      var track = options.track;
      var tracks = player.audioTracks();
      options.label = track.label || track.language || 'Unknown';
      options.selected = track.enabled;
      _this = _MenuItem.call(this, player, options) || this;
      _this.track = track;
      _this.addClass("vjs-" + track.kind + "-menu-item");
      var changeHandler = function changeHandler() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this.handleTracksChange.apply(assertThisInitialized(_this), args);
      };
      tracks.addEventListener('change', changeHandler);
      _this.on('dispose', function () {
        tracks.removeEventListener('change', changeHandler);
      });
      return _this;
    }
    var _proto = AudioTrackMenuItem.prototype;
    _proto.createEl = function createEl$1(type, props, attrs) {
      var el = _MenuItem.prototype.createEl.call(this, type, props, attrs);
      var parentSpan = el.querySelector('.vjs-menu-item-text');
      if (this.options_.track.kind === 'main-desc') {
        parentSpan.appendChild(createEl('span', {
          className: 'vjs-icon-placeholder'
        }, {
          'aria-hidden': true
        }));
        parentSpan.appendChild(createEl('span', {
          className: 'vjs-control-text',
          textContent: ' ' + this.localize('Descriptions')
        }));
      }
      return el;
    }
    ;
    _proto.handleClick = function handleClick(event) {
      _MenuItem.prototype.handleClick.call(this, event);
      this.track.enabled = true;
      if (this.player_.tech_.featuresNativeAudioTracks) {
        var tracks = this.player_.audioTracks();
        for (var i = 0; i < tracks.length; i++) {
          var track = tracks[i];
          if (track === this.track) {
            continue;
          }
          track.enabled = track === this.track;
        }
      }
    }
    ;
    _proto.handleTracksChange = function handleTracksChange(event) {
      this.selected(this.track.enabled);
    };
    return AudioTrackMenuItem;
  }(MenuItem);
  Component$1.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);
  var AudioTrackButton = function (_TrackButton) {
    inheritsLoose(AudioTrackButton, _TrackButton);
    function AudioTrackButton(player, options) {
      if (options === void 0) {
        options = {};
      }
      options.tracks = player.audioTracks();
      return _TrackButton.call(this, player, options) || this;
    }
    var _proto = AudioTrackButton.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-audio-button " + _TrackButton.prototype.buildCSSClass.call(this);
    };
    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
      return "vjs-audio-button " + _TrackButton.prototype.buildWrapperCSSClass.call(this);
    }
    ;
    _proto.createItems = function createItems(items) {
      if (items === void 0) {
        items = [];
      }
      this.hideThreshold_ = 1;
      var tracks = this.player_.audioTracks();
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        items.push(new AudioTrackMenuItem(this.player_, {
          track: track,
          selectable: true,
          multiSelectable: false
        }));
      }
      return items;
    };
    return AudioTrackButton;
  }(TrackButton);
  AudioTrackButton.prototype.controlText_ = 'Audio Track';
  Component$1.registerComponent('AudioTrackButton', AudioTrackButton);
  var PlaybackRateMenuItem = function (_MenuItem) {
    inheritsLoose(PlaybackRateMenuItem, _MenuItem);
    function PlaybackRateMenuItem(player, options) {
      var _this;
      var label = options.rate;
      var rate = parseFloat(label, 10);
      options.label = label;
      options.selected = rate === player.playbackRate();
      options.selectable = true;
      options.multiSelectable = false;
      _this = _MenuItem.call(this, player, options) || this;
      _this.label = label;
      _this.rate = rate;
      _this.on(player, 'ratechange', function (e) {
        return _this.update(e);
      });
      return _this;
    }
    var _proto = PlaybackRateMenuItem.prototype;
    _proto.handleClick = function handleClick(event) {
      _MenuItem.prototype.handleClick.call(this);
      this.player().playbackRate(this.rate);
    }
    ;
    _proto.update = function update(event) {
      this.selected(this.player().playbackRate() === this.rate);
    };
    return PlaybackRateMenuItem;
  }(MenuItem);
  PlaybackRateMenuItem.prototype.contentElType = 'button';
  Component$1.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);
  var PlaybackRateMenuButton = function (_MenuButton) {
    inheritsLoose(PlaybackRateMenuButton, _MenuButton);
    function PlaybackRateMenuButton(player, options) {
      var _this;
      _this = _MenuButton.call(this, player, options) || this;
      _this.menuButton_.el_.setAttribute('aria-describedby', _this.labelElId_);
      _this.updateVisibility();
      _this.updateLabel();
      _this.on(player, 'loadstart', function (e) {
        return _this.updateVisibility(e);
      });
      _this.on(player, 'ratechange', function (e) {
        return _this.updateLabel(e);
      });
      _this.on(player, 'playbackrateschange', function (e) {
        return _this.handlePlaybackRateschange(e);
      });
      return _this;
    }
    var _proto = PlaybackRateMenuButton.prototype;
    _proto.createEl = function createEl$1() {
      var el = _MenuButton.prototype.createEl.call(this);
      this.labelElId_ = 'vjs-playback-rate-value-label-' + this.id_;
      this.labelEl_ = createEl('div', {
        className: 'vjs-playback-rate-value',
        id: this.labelElId_,
        textContent: '1x'
      });
      el.appendChild(this.labelEl_);
      return el;
    };
    _proto.dispose = function dispose() {
      this.labelEl_ = null;
      _MenuButton.prototype.dispose.call(this);
    }
    ;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-playback-rate " + _MenuButton.prototype.buildCSSClass.call(this);
    };
    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
      return "vjs-playback-rate " + _MenuButton.prototype.buildWrapperCSSClass.call(this);
    }
    ;
    _proto.createItems = function createItems() {
      var rates = this.playbackRates();
      var items = [];
      for (var i = rates.length - 1; i >= 0; i--) {
        items.push(new PlaybackRateMenuItem(this.player(), {
          rate: rates[i] + 'x'
        }));
      }
      return items;
    }
    ;
    _proto.updateARIAAttributes = function updateARIAAttributes() {
      this.el().setAttribute('aria-valuenow', this.player().playbackRate());
    }
    ;
    _proto.handleClick = function handleClick(event) {
      var currentRate = this.player().playbackRate();
      var rates = this.playbackRates();
      var currentIndex = rates.indexOf(currentRate);
      var newIndex = (currentIndex + 1) % rates.length;
      this.player().playbackRate(rates[newIndex]);
    }
    ;
    _proto.handlePlaybackRateschange = function handlePlaybackRateschange(event) {
      this.update();
    }
    ;
    _proto.playbackRates = function playbackRates() {
      var player = this.player();
      return player.playbackRates && player.playbackRates() || [];
    }
    ;
    _proto.playbackRateSupported = function playbackRateSupported() {
      return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
    }
    ;
    _proto.updateVisibility = function updateVisibility(event) {
      if (this.playbackRateSupported()) {
        this.removeClass('vjs-hidden');
      } else {
        this.addClass('vjs-hidden');
      }
    }
    ;
    _proto.updateLabel = function updateLabel(event) {
      if (this.playbackRateSupported()) {
        this.labelEl_.textContent = this.player().playbackRate() + 'x';
      }
    };
    return PlaybackRateMenuButton;
  }(MenuButton);
  PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';
  Component$1.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);
  var Spacer = function (_Component) {
    inheritsLoose(Spacer, _Component);
    function Spacer() {
      return _Component.apply(this, arguments) || this;
    }
    var _proto = Spacer.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-spacer " + _Component.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.createEl = function createEl(tag, props, attributes) {
      if (tag === void 0) {
        tag = 'div';
      }
      if (props === void 0) {
        props = {};
      }
      if (attributes === void 0) {
        attributes = {};
      }
      if (!props.className) {
        props.className = this.buildCSSClass();
      }
      return _Component.prototype.createEl.call(this, tag, props, attributes);
    };
    return Spacer;
  }(Component$1);
  Component$1.registerComponent('Spacer', Spacer);
  var CustomControlSpacer = function (_Spacer) {
    inheritsLoose(CustomControlSpacer, _Spacer);
    function CustomControlSpacer() {
      return _Spacer.apply(this, arguments) || this;
    }
    var _proto = CustomControlSpacer.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-custom-control-spacer " + _Spacer.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.createEl = function createEl() {
      return _Spacer.prototype.createEl.call(this, 'div', {
        className: this.buildCSSClass(),
        textContent: "\xA0"
      });
    };
    return CustomControlSpacer;
  }(Spacer);
  Component$1.registerComponent('CustomControlSpacer', CustomControlSpacer);
  var ControlBar = function (_Component) {
    inheritsLoose(ControlBar, _Component);
    function ControlBar() {
      return _Component.apply(this, arguments) || this;
    }
    var _proto = ControlBar.prototype;
    _proto.createEl = function createEl() {
      return _Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-control-bar',
        dir: 'ltr'
      });
    };
    return ControlBar;
  }(Component$1);
  ControlBar.prototype.options_ = {
    children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'seekToLive', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']
  };
  if ('exitPictureInPicture' in document) {
    ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, 'pictureInPictureToggle');
  }
  Component$1.registerComponent('ControlBar', ControlBar);
  var ErrorDisplay = function (_ModalDialog) {
    inheritsLoose(ErrorDisplay, _ModalDialog);
    function ErrorDisplay(player, options) {
      var _this;
      _this = _ModalDialog.call(this, player, options) || this;
      _this.on(player, 'error', function (e) {
        return _this.open(e);
      });
      return _this;
    }
    var _proto = ErrorDisplay.prototype;
    _proto.buildCSSClass = function buildCSSClass() {
      return "vjs-error-display " + _ModalDialog.prototype.buildCSSClass.call(this);
    }
    ;
    _proto.content = function content() {
      var error = this.player().error();
      return error ? this.localize(error.message) : '';
    };
    return ErrorDisplay;
  }(ModalDialog);
  ErrorDisplay.prototype.options_ = _extends_1({}, ModalDialog.prototype.options_, {
    pauseOnOpen: false,
    fillAlways: true,
    temporary: false,
    uncloseable: true
  });
  Component$1.registerComponent('ErrorDisplay', ErrorDisplay);
  var LOCAL_STORAGE_KEY$1 = 'vjs-text-track-settings';
  var COLOR_BLACK = ['#000', 'Black'];
  var COLOR_BLUE = ['#00F', 'Blue'];
  var COLOR_CYAN = ['#0FF', 'Cyan'];
  var COLOR_GREEN = ['#0F0', 'Green'];
  var COLOR_MAGENTA = ['#F0F', 'Magenta'];
  var COLOR_RED = ['#F00', 'Red'];
  var COLOR_WHITE = ['#FFF', 'White'];
  var COLOR_YELLOW = ['#FF0', 'Yellow'];
  var OPACITY_OPAQUE = ['1', 'Opaque'];
  var OPACITY_SEMI = ['0.5', 'Semi-Transparent'];
  var OPACITY_TRANS = ['0', 'Transparent'];
  var selectConfigs = {
    backgroundColor: {
      selector: '.vjs-bg-color > select',
      id: 'captions-background-color-%s',
      label: 'Color',
      options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
    },
    backgroundOpacity: {
      selector: '.vjs-bg-opacity > select',
      id: 'captions-background-opacity-%s',
      label: 'Transparency',
      options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
    },
    color: {
      selector: '.vjs-fg-color > select',
      id: 'captions-foreground-color-%s',
      label: 'Color',
      options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
    },
    edgeStyle: {
      selector: '.vjs-edge-style > select',
      id: '%s',
      label: 'Text Edge Style',
      options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]
    },
    fontFamily: {
      selector: '.vjs-font-family > select',
      id: 'captions-font-family-%s',
      label: 'Font Family',
      options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]
    },
    fontPercent: {
      selector: '.vjs-font-percent > select',
      id: 'captions-font-size-%s',
      label: 'Font Size',
      options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],
      "default": 2,
      parser: function parser(v) {
        return v === '1.00' ? null : Number(v);
      }
    },
    textOpacity: {
      selector: '.vjs-text-opacity > select',
      id: 'captions-foreground-opacity-%s',
      label: 'Transparency',
      options: [OPACITY_OPAQUE, OPACITY_SEMI]
    },
    windowColor: {
      selector: '.vjs-window-color > select',
      id: 'captions-window-color-%s',
      label: 'Color'
    },
    windowOpacity: {
      selector: '.vjs-window-opacity > select',
      id: 'captions-window-opacity-%s',
      label: 'Transparency',
      options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
    }
  };
  selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;
  function parseOptionValue(value, parser) {
    if (parser) {
      value = parser(value);
    }
    if (value && value !== 'none') {
      return value;
    }
  }
  function getSelectedOptionValue(el, parser) {
    var value = el.options[el.options.selectedIndex].value;
    return parseOptionValue(value, parser);
  }
  function setSelectedOption(el, value, parser) {
    if (!value) {
      return;
    }
    for (var i = 0; i < el.options.length; i++) {
      if (parseOptionValue(el.options[i].value, parser) === value) {
        el.selectedIndex = i;
        break;
      }
    }
  }
  var TextTrackSettings = function (_ModalDialog) {
    inheritsLoose(TextTrackSettings, _ModalDialog);
    function TextTrackSettings(player, options) {
      var _this;
      options.temporary = false;
      _this = _ModalDialog.call(this, player, options) || this;
      _this.updateDisplay = _this.updateDisplay.bind(assertThisInitialized(_this));
      _this.fill();
      _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;
      _this.endDialog = createEl('p', {
        className: 'vjs-control-text',
        textContent: _this.localize('End of dialog window.')
      });
      _this.el().appendChild(_this.endDialog);
      _this.setDefaults();
      if (options.persistTextTrackSettings === undefined) {
        _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;
      }
      _this.on(_this.$('.vjs-done-button'), 'click', function () {
        _this.saveSettings();
        _this.close();
      });
      _this.on(_this.$('.vjs-default-button'), 'click', function () {
        _this.setDefaults();
        _this.updateDisplay();
      });
      each(selectConfigs, function (config) {
        _this.on(_this.$(config.selector), 'change', _this.updateDisplay);
      });
      if (_this.options_.persistTextTrackSettings) {
        _this.restoreSettings();
      }
      return _this;
    }
    var _proto = TextTrackSettings.prototype;
    _proto.dispose = function dispose() {
      this.endDialog = null;
      _ModalDialog.prototype.dispose.call(this);
    }
    ;
    _proto.createElSelect_ = function createElSelect_(key, legendId, type) {
      var _this2 = this;
      if (legendId === void 0) {
        legendId = '';
      }
      if (type === void 0) {
        type = 'label';
      }
      var config = selectConfigs[key];
      var id = config.id.replace('%s', this.id_);
      var selectLabelledbyIds = [legendId, id].join(' ').trim();
      return ["<" + type + " id=\"" + id + "\" class=\"" + (type === 'label' ? 'vjs-label' : '') + "\">", this.localize(config.label), "</" + type + ">", "<select aria-labelledby=\"" + selectLabelledbyIds + "\">"].concat(config.options.map(function (o) {
        var optionId = id + '-' + o[1].replace(/\W+/g, '');
        return ["<option id=\"" + optionId + "\" value=\"" + o[0] + "\" ", "aria-labelledby=\"" + selectLabelledbyIds + " " + optionId + "\">", _this2.localize(o[1]), '</option>'].join('');
      })).concat('</select>').join('');
    }
    ;
    _proto.createElFgColor_ = function createElFgColor_() {
      var legendId = "captions-text-legend-" + this.id_;
      return ['<fieldset class="vjs-fg-color vjs-track-setting">', "<legend id=\"" + legendId + "\">", this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');
    }
    ;
    _proto.createElBgColor_ = function createElBgColor_() {
      var legendId = "captions-background-" + this.id_;
      return ['<fieldset class="vjs-bg-color vjs-track-setting">', "<legend id=\"" + legendId + "\">", this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');
    }
    ;
    _proto.createElWinColor_ = function createElWinColor_() {
      var legendId = "captions-window-" + this.id_;
      return ['<fieldset class="vjs-window-color vjs-track-setting">', "<legend id=\"" + legendId + "\">", this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');
    }
    ;
    _proto.createElColors_ = function createElColors_() {
      return createEl('div', {
        className: 'vjs-track-settings-colors',
        innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')
      });
    }
    ;
    _proto.createElFont_ = function createElFont_() {
      return createEl('div', {
        className: 'vjs-track-settings-font',
        innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')
      });
    }
    ;
    _proto.createElControls_ = function createElControls_() {
      var defaultsDescription = this.localize('restore all settings to the default values');
      return createEl('div', {
        className: 'vjs-track-settings-controls',
        innerHTML: ["<button type=\"button\" class=\"vjs-default-button\" title=\"" + defaultsDescription + "\">", this.localize('Reset'), "<span class=\"vjs-control-text\"> " + defaultsDescription + "</span>", '</button>', "<button type=\"button\" class=\"vjs-done-button\">" + this.localize('Done') + "</button>"].join('')
      });
    };
    _proto.content = function content() {
      return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
    };
    _proto.label = function label() {
      return this.localize('Caption Settings Dialog');
    };
    _proto.description = function description() {
      return this.localize('Beginning of dialog window. Escape will cancel and close the window.');
    };
    _proto.buildCSSClass = function buildCSSClass() {
      return _ModalDialog.prototype.buildCSSClass.call(this) + ' vjs-text-track-settings';
    }
    ;
    _proto.getValues = function getValues() {
      var _this3 = this;
      return reduce(selectConfigs, function (accum, config, key) {
        var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);
        if (value !== undefined) {
          accum[key] = value;
        }
        return accum;
      }, {});
    }
    ;
    _proto.setValues = function setValues(values) {
      var _this4 = this;
      each(selectConfigs, function (config, key) {
        setSelectedOption(_this4.$(config.selector), values[key], config.parser);
      });
    }
    ;
    _proto.setDefaults = function setDefaults() {
      var _this5 = this;
      each(selectConfigs, function (config) {
        var index = config.hasOwnProperty('default') ? config["default"] : 0;
        _this5.$(config.selector).selectedIndex = index;
      });
    }
    ;
    _proto.restoreSettings = function restoreSettings() {
      var values;
      try {
        values = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY$1));
      } catch (err) {
        log$1.warn(err);
      }
      if (values) {
        this.setValues(values);
      }
    }
    ;
    _proto.saveSettings = function saveSettings() {
      if (!this.options_.persistTextTrackSettings) {
        return;
      }
      var values = this.getValues();
      try {
        if (Object.keys(values).length) {
          window.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values));
        } else {
          window.localStorage.removeItem(LOCAL_STORAGE_KEY$1);
        }
      } catch (err) {
        log$1.warn(err);
      }
    }
    ;
    _proto.updateDisplay = function updateDisplay() {
      var ttDisplay = this.player_.getChild('textTrackDisplay');
      if (ttDisplay) {
        ttDisplay.updateDisplay();
      }
    }
    ;
    _proto.conditionalBlur_ = function conditionalBlur_() {
      this.previouslyActiveEl_ = null;
      var cb = this.player_.controlBar;
      var subsCapsBtn = cb && cb.subsCapsButton;
      var ccBtn = cb && cb.captionsButton;
      if (subsCapsBtn) {
        subsCapsBtn.focus();
      } else if (ccBtn) {
        ccBtn.focus();
      }
    };
    return TextTrackSettings;
  }(ModalDialog);
  Component$1.registerComponent('TextTrackSettings', TextTrackSettings);
  var ResizeManager = function (_Component) {
    inheritsLoose(ResizeManager, _Component);
    function ResizeManager(player, options) {
      var _this;
      var RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window.ResizeObserver;
      if (options.ResizeObserver === null) {
        RESIZE_OBSERVER_AVAILABLE = false;
      }
      var options_ = mergeOptions$3({
        createEl: !RESIZE_OBSERVER_AVAILABLE,
        reportTouchActivity: false
      }, options);
      _this = _Component.call(this, player, options_) || this;
      _this.ResizeObserver = options.ResizeObserver || window.ResizeObserver;
      _this.loadListener_ = null;
      _this.resizeObserver_ = null;
      _this.debouncedHandler_ = debounce(function () {
        _this.resizeHandler();
      }, 100, false, assertThisInitialized(_this));
      if (RESIZE_OBSERVER_AVAILABLE) {
        _this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_);
        _this.resizeObserver_.observe(player.el());
      } else {
        _this.loadListener_ = function () {
          if (!_this.el_ || !_this.el_.contentWindow) {
            return;
          }
          var debouncedHandler_ = _this.debouncedHandler_;
          var unloadListener_ = _this.unloadListener_ = function () {
            off(this, 'resize', debouncedHandler_);
            off(this, 'unload', unloadListener_);
            unloadListener_ = null;
          };
          on(_this.el_.contentWindow, 'unload', unloadListener_);
          on(_this.el_.contentWindow, 'resize', debouncedHandler_);
        };
        _this.one('load', _this.loadListener_);
      }
      return _this;
    }
    var _proto = ResizeManager.prototype;
    _proto.createEl = function createEl() {
      return _Component.prototype.createEl.call(this, 'iframe', {
        className: 'vjs-resize-manager',
        tabIndex: -1
      }, {
        'aria-hidden': 'true'
      });
    }
    ;
    _proto.resizeHandler = function resizeHandler() {
      if (!this.player_ || !this.player_.trigger) {
        return;
      }
      this.player_.trigger('playerresize');
    };
    _proto.dispose = function dispose() {
      if (this.debouncedHandler_) {
        this.debouncedHandler_.cancel();
      }
      if (this.resizeObserver_) {
        if (this.player_.el()) {
          this.resizeObserver_.unobserve(this.player_.el());
        }
        this.resizeObserver_.disconnect();
      }
      if (this.loadListener_) {
        this.off('load', this.loadListener_);
      }
      if (this.el_ && this.el_.contentWindow && this.unloadListener_) {
        this.unloadListener_.call(this.el_.contentWindow);
      }
      this.ResizeObserver = null;
      this.resizeObserver = null;
      this.debouncedHandler_ = null;
      this.loadListener_ = null;
      _Component.prototype.dispose.call(this);
    };
    return ResizeManager;
  }(Component$1);
  Component$1.registerComponent('ResizeManager', ResizeManager);
  var defaults = {
    trackingThreshold: 20,
    liveTolerance: 15
  };
  var LiveTracker = function (_Component) {
    inheritsLoose(LiveTracker, _Component);
    function LiveTracker(player, options) {
      var _this;
      var options_ = mergeOptions$3(defaults, options, {
        createEl: false
      });
      _this = _Component.call(this, player, options_) || this;
      _this.handleVisibilityChange_ = function (e) {
        return _this.handleVisibilityChange(e);
      };
      _this.trackLiveHandler_ = function () {
        return _this.trackLive_();
      };
      _this.handlePlay_ = function (e) {
        return _this.handlePlay(e);
      };
      _this.handleFirstTimeupdate_ = function (e) {
        return _this.handleFirstTimeupdate(e);
      };
      _this.handleSeeked_ = function (e) {
        return _this.handleSeeked(e);
      };
      _this.seekToLiveEdge_ = function (e) {
        return _this.seekToLiveEdge(e);
      };
      _this.reset_();
      _this.on(_this.player_, 'durationchange', function (e) {
        return _this.handleDurationchange(e);
      });
      _this.on(_this.player_, 'canplay', function () {
        return _this.toggleTracking();
      });
      if (IE_VERSION && 'hidden' in document && 'visibilityState' in document) {
        _this.on(document, 'visibilitychange', _this.handleVisibilityChange_);
      }
      return _this;
    }
    var _proto = LiveTracker.prototype;
    _proto.handleVisibilityChange = function handleVisibilityChange() {
      if (this.player_.duration() !== Infinity) {
        return;
      }
      if (document.hidden) {
        this.stopTracking();
      } else {
        this.startTracking();
      }
    }
    ;
    _proto.trackLive_ = function trackLive_() {
      var seekable = this.player_.seekable();
      if (!seekable || !seekable.length) {
        return;
      }
      var newTime = Number(window.performance.now().toFixed(4));
      var deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1000;
      this.lastTime_ = newTime;
      this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
      var liveCurrentTime = this.liveCurrentTime();
      var currentTime = this.player_.currentTime();
      var isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;
      if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {
        isBehind = false;
      }
      if (isBehind !== this.behindLiveEdge_) {
        this.behindLiveEdge_ = isBehind;
        this.trigger('liveedgechange');
      }
    }
    ;
    _proto.handleDurationchange = function handleDurationchange() {
      this.toggleTracking();
    }
    ;
    _proto.toggleTracking = function toggleTracking() {
      if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {
        if (this.player_.options_.liveui) {
          this.player_.addClass('vjs-liveui');
        }
        this.startTracking();
      } else {
        this.player_.removeClass('vjs-liveui');
        this.stopTracking();
      }
    }
    ;
    _proto.startTracking = function startTracking() {
      if (this.isTracking()) {
        return;
      }
      if (!this.timeupdateSeen_) {
        this.timeupdateSeen_ = this.player_.hasStarted();
      }
      this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);
      this.trackLive_();
      this.on(this.player_, ['play', 'pause'], this.trackLiveHandler_);
      if (!this.timeupdateSeen_) {
        this.one(this.player_, 'play', this.handlePlay_);
        this.one(this.player_, 'timeupdate', this.handleFirstTimeupdate_);
      } else {
        this.on(this.player_, 'seeked', this.handleSeeked_);
      }
    }
    ;
    _proto.handleFirstTimeupdate = function handleFirstTimeupdate() {
      this.timeupdateSeen_ = true;
      this.on(this.player_, 'seeked', this.handleSeeked_);
    }
    ;
    _proto.handleSeeked = function handleSeeked() {
      var timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
      this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;
      this.nextSeekedFromUser_ = false;
      this.trackLive_();
    }
    ;
    _proto.handlePlay = function handlePlay() {
      this.one(this.player_, 'timeupdate', this.seekToLiveEdge_);
    }
    ;
    _proto.reset_ = function reset_() {
      this.lastTime_ = -1;
      this.pastSeekEnd_ = 0;
      this.lastSeekEnd_ = -1;
      this.behindLiveEdge_ = true;
      this.timeupdateSeen_ = false;
      this.seekedBehindLive_ = false;
      this.nextSeekedFromUser_ = false;
      this.clearInterval(this.trackingInterval_);
      this.trackingInterval_ = null;
      this.off(this.player_, ['play', 'pause'], this.trackLiveHandler_);
      this.off(this.player_, 'seeked', this.handleSeeked_);
      this.off(this.player_, 'play', this.handlePlay_);
      this.off(this.player_, 'timeupdate', this.handleFirstTimeupdate_);
      this.off(this.player_, 'timeupdate', this.seekToLiveEdge_);
    }
    ;
    _proto.nextSeekedFromUser = function nextSeekedFromUser() {
      this.nextSeekedFromUser_ = true;
    }
    ;
    _proto.stopTracking = function stopTracking() {
      if (!this.isTracking()) {
        return;
      }
      this.reset_();
      this.trigger('liveedgechange');
    }
    ;
    _proto.seekableEnd = function seekableEnd() {
      var seekable = this.player_.seekable();
      var seekableEnds = [];
      var i = seekable ? seekable.length : 0;
      while (i--) {
        seekableEnds.push(seekable.end(i));
      }
      return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;
    }
    ;
    _proto.seekableStart = function seekableStart() {
      var seekable = this.player_.seekable();
      var seekableStarts = [];
      var i = seekable ? seekable.length : 0;
      while (i--) {
        seekableStarts.push(seekable.start(i));
      }
      return seekableStarts.length ? seekableStarts.sort()[0] : 0;
    }
    ;
    _proto.liveWindow = function liveWindow() {
      var liveCurrentTime = this.liveCurrentTime();
      if (liveCurrentTime === Infinity) {
        return 0;
      }
      return liveCurrentTime - this.seekableStart();
    }
    ;
    _proto.isLive = function isLive() {
      return this.isTracking();
    }
    ;
    _proto.atLiveEdge = function atLiveEdge() {
      return !this.behindLiveEdge();
    }
    ;
    _proto.liveCurrentTime = function liveCurrentTime() {
      return this.pastSeekEnd() + this.seekableEnd();
    }
    ;
    _proto.pastSeekEnd = function pastSeekEnd() {
      var seekableEnd = this.seekableEnd();
      if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {
        this.pastSeekEnd_ = 0;
      }
      this.lastSeekEnd_ = seekableEnd;
      return this.pastSeekEnd_;
    }
    ;
    _proto.behindLiveEdge = function behindLiveEdge() {
      return this.behindLiveEdge_;
    }
    ;
    _proto.isTracking = function isTracking() {
      return typeof this.trackingInterval_ === 'number';
    }
    ;
    _proto.seekToLiveEdge = function seekToLiveEdge() {
      this.seekedBehindLive_ = false;
      if (this.atLiveEdge()) {
        return;
      }
      this.nextSeekedFromUser_ = false;
      this.player_.currentTime(this.liveCurrentTime());
    }
    ;
    _proto.dispose = function dispose() {
      this.off(document, 'visibilitychange', this.handleVisibilityChange_);
      this.stopTracking();
      _Component.prototype.dispose.call(this);
    };
    return LiveTracker;
  }(Component$1);
  Component$1.registerComponent('LiveTracker', LiveTracker);
  var sourcesetLoad = function sourcesetLoad(tech) {
    var el = tech.el();
    if (el.hasAttribute('src')) {
      tech.triggerSourceset(el.src);
      return true;
    }
    var sources = tech.$$('source');
    var srcUrls = [];
    var src = '';
    if (!sources.length) {
      return false;
    }
    for (var i = 0; i < sources.length; i++) {
      var url = sources[i].src;
      if (url && srcUrls.indexOf(url) === -1) {
        srcUrls.push(url);
      }
    }
    if (!srcUrls.length) {
      return false;
    }
    if (srcUrls.length === 1) {
      src = srcUrls[0];
    }
    tech.triggerSourceset(src);
    return true;
  };
  var innerHTMLDescriptorPolyfill = Object.defineProperty({}, 'innerHTML', {
    get: function get() {
      return this.cloneNode(true).innerHTML;
    },
    set: function set(v) {
      var dummy = document.createElement(this.nodeName.toLowerCase());
      dummy.innerHTML = v;
      var docFrag = document.createDocumentFragment();
      while (dummy.childNodes.length) {
        docFrag.appendChild(dummy.childNodes[0]);
      }
      this.innerText = '';
      window.Element.prototype.appendChild.call(this, docFrag);
      return this.innerHTML;
    }
  });
  var getDescriptor = function getDescriptor(priority, prop) {
    var descriptor = {};
    for (var i = 0; i < priority.length; i++) {
      descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);
      if (descriptor && descriptor.set && descriptor.get) {
        break;
      }
    }
    descriptor.enumerable = true;
    descriptor.configurable = true;
    return descriptor;
  };
  var getInnerHTMLDescriptor = function getInnerHTMLDescriptor(tech) {
    return getDescriptor([tech.el(), window.HTMLMediaElement.prototype, window.Element.prototype, innerHTMLDescriptorPolyfill], 'innerHTML');
  };
  var firstSourceWatch = function firstSourceWatch(tech) {
    var el = tech.el();
    if (el.resetSourceWatch_) {
      return;
    }
    var old = {};
    var innerDescriptor = getInnerHTMLDescriptor(tech);
    var appendWrapper = function appendWrapper(appendFn) {
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var retval = appendFn.apply(el, args);
        sourcesetLoad(tech);
        return retval;
      };
    };
    ['append', 'appendChild', 'insertAdjacentHTML'].forEach(function (k) {
      if (!el[k]) {
        return;
      }
      old[k] = el[k];
      el[k] = appendWrapper(old[k]);
    });
    Object.defineProperty(el, 'innerHTML', mergeOptions$3(innerDescriptor, {
      set: appendWrapper(innerDescriptor.set)
    }));
    el.resetSourceWatch_ = function () {
      el.resetSourceWatch_ = null;
      Object.keys(old).forEach(function (k) {
        el[k] = old[k];
      });
      Object.defineProperty(el, 'innerHTML', innerDescriptor);
    };
    tech.one('sourceset', el.resetSourceWatch_);
  };
  var srcDescriptorPolyfill = Object.defineProperty({}, 'src', {
    get: function get() {
      if (this.hasAttribute('src')) {
        return getAbsoluteURL(window.Element.prototype.getAttribute.call(this, 'src'));
      }
      return '';
    },
    set: function set(v) {
      window.Element.prototype.setAttribute.call(this, 'src', v);
      return v;
    }
  });
  var getSrcDescriptor = function getSrcDescriptor(tech) {
    return getDescriptor([tech.el(), window.HTMLMediaElement.prototype, srcDescriptorPolyfill], 'src');
  };
  var setupSourceset = function setupSourceset(tech) {
    if (!tech.featuresSourceset) {
      return;
    }
    var el = tech.el();
    if (el.resetSourceset_) {
      return;
    }
    var srcDescriptor = getSrcDescriptor(tech);
    var oldSetAttribute = el.setAttribute;
    var oldLoad = el.load;
    Object.defineProperty(el, 'src', mergeOptions$3(srcDescriptor, {
      set: function set(v) {
        var retval = srcDescriptor.set.call(el, v);
        tech.triggerSourceset(el.src);
        return retval;
      }
    }));
    el.setAttribute = function (n, v) {
      var retval = oldSetAttribute.call(el, n, v);
      if (/src/i.test(n)) {
        tech.triggerSourceset(el.src);
      }
      return retval;
    };
    el.load = function () {
      var retval = oldLoad.call(el);
      if (!sourcesetLoad(tech)) {
        tech.triggerSourceset('');
        firstSourceWatch(tech);
      }
      return retval;
    };
    if (el.currentSrc) {
      tech.triggerSourceset(el.currentSrc);
    } else if (!sourcesetLoad(tech)) {
      firstSourceWatch(tech);
    }
    el.resetSourceset_ = function () {
      el.resetSourceset_ = null;
      el.load = oldLoad;
      el.setAttribute = oldSetAttribute;
      Object.defineProperty(el, 'src', srcDescriptor);
      if (el.resetSourceWatch_) {
        el.resetSourceWatch_();
      }
    };
  };
  var defineLazyProperty = function defineLazyProperty(obj, key, getValue, setter) {
    if (setter === void 0) {
      setter = true;
    }
    var set = function set(value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        writable: true
      });
    };
    var options = {
      configurable: true,
      enumerable: true,
      get: function get() {
        var value = getValue();
        set(value);
        return value;
      }
    };
    if (setter) {
      options.set = set;
    }
    return Object.defineProperty(obj, key, options);
  };
  var Html5 = function (_Tech) {
    inheritsLoose(Html5, _Tech);
    function Html5(options, ready) {
      var _this;
      _this = _Tech.call(this, options, ready) || this;
      var source = options.source;
      var crossoriginTracks = false;
      if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
        _this.setSource(source);
      } else {
        _this.handleLateInit_(_this.el_);
      }
      if (options.enableSourceset) {
        _this.setupSourcesetHandling_();
      }
      _this.isScrubbing_ = false;
      if (_this.el_.hasChildNodes()) {
        var nodes = _this.el_.childNodes;
        var nodesLength = nodes.length;
        var removeNodes = [];
        while (nodesLength--) {
          var node = nodes[nodesLength];
          var nodeName = node.nodeName.toLowerCase();
          if (nodeName === 'track') {
            if (!_this.featuresNativeTextTracks) {
              removeNodes.push(node);
            } else {
              _this.remoteTextTrackEls().addTrackElement_(node);
              _this.remoteTextTracks().addTrack(node.track);
              _this.textTracks().addTrack(node.track);
              if (!crossoriginTracks && !_this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {
                crossoriginTracks = true;
              }
            }
          }
        }
        for (var i = 0; i < removeNodes.length; i++) {
          _this.el_.removeChild(removeNodes[i]);
        }
      }
      _this.proxyNativeTracks_();
      if (_this.featuresNativeTextTracks && crossoriginTracks) {
        log$1.warn('Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n' + 'This may prevent text tracks from loading.');
      }
      _this.restoreMetadataTracksInIOSNativePlayer_();
      if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
        _this.setControls(true);
      }
      _this.proxyWebkitFullscreen_();
      _this.triggerReady();
      return _this;
    }
    var _proto = Html5.prototype;
    _proto.dispose = function dispose() {
      if (this.el_ && this.el_.resetSourceset_) {
        this.el_.resetSourceset_();
      }
      Html5.disposeMediaElement(this.el_);
      this.options_ = null;
      _Tech.prototype.dispose.call(this);
    }
    ;
    _proto.setupSourcesetHandling_ = function setupSourcesetHandling_() {
      setupSourceset(this);
    }
    ;
    _proto.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {
      var textTracks = this.textTracks();
      var metadataTracksPreFullscreenState;
      var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot() {
        metadataTracksPreFullscreenState = [];
        for (var i = 0; i < textTracks.length; i++) {
          var track = textTracks[i];
          if (track.kind === 'metadata') {
            metadataTracksPreFullscreenState.push({
              track: track,
              storedMode: track.mode
            });
          }
        }
      };
      takeMetadataTrackSnapshot();
      textTracks.addEventListener('change', takeMetadataTrackSnapshot);
      this.on('dispose', function () {
        return textTracks.removeEventListener('change', takeMetadataTrackSnapshot);
      });
      var restoreTrackMode = function restoreTrackMode() {
        for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {
          var storedTrack = metadataTracksPreFullscreenState[i];
          if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {
            storedTrack.track.mode = storedTrack.storedMode;
          }
        }
        textTracks.removeEventListener('change', restoreTrackMode);
      };
      this.on('webkitbeginfullscreen', function () {
        textTracks.removeEventListener('change', takeMetadataTrackSnapshot);
        textTracks.removeEventListener('change', restoreTrackMode);
        textTracks.addEventListener('change', restoreTrackMode);
      });
      this.on('webkitendfullscreen', function () {
        textTracks.removeEventListener('change', takeMetadataTrackSnapshot);
        textTracks.addEventListener('change', takeMetadataTrackSnapshot);
        textTracks.removeEventListener('change', restoreTrackMode);
      });
    }
    ;
    _proto.overrideNative_ = function overrideNative_(type, override) {
      var _this2 = this;
      if (override !== this["featuresNative" + type + "Tracks"]) {
        return;
      }
      var lowerCaseType = type.toLowerCase();
      if (this[lowerCaseType + "TracksListeners_"]) {
        Object.keys(this[lowerCaseType + "TracksListeners_"]).forEach(function (eventName) {
          var elTracks = _this2.el()[lowerCaseType + "Tracks"];
          elTracks.removeEventListener(eventName, _this2[lowerCaseType + "TracksListeners_"][eventName]);
        });
      }
      this["featuresNative" + type + "Tracks"] = !override;
      this[lowerCaseType + "TracksListeners_"] = null;
      this.proxyNativeTracksForType_(lowerCaseType);
    }
    ;
    _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks(override) {
      this.overrideNative_('Audio', override);
    }
    ;
    _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks(override) {
      this.overrideNative_('Video', override);
    }
    ;
    _proto.proxyNativeTracksForType_ = function proxyNativeTracksForType_(name) {
      var _this3 = this;
      var props = NORMAL[name];
      var elTracks = this.el()[props.getterName];
      var techTracks = this[props.getterName]();
      if (!this["featuresNative" + props.capitalName + "Tracks"] || !elTracks || !elTracks.addEventListener) {
        return;
      }
      var listeners = {
        change: function change(e) {
          var event = {
            type: 'change',
            target: techTracks,
            currentTarget: techTracks,
            srcElement: techTracks
          };
          techTracks.trigger(event);
          if (name === 'text') {
            _this3[REMOTE.remoteText.getterName]().trigger(event);
          }
        },
        addtrack: function addtrack(e) {
          techTracks.addTrack(e.track);
        },
        removetrack: function removetrack(e) {
          techTracks.removeTrack(e.track);
        }
      };
      var removeOldTracks = function removeOldTracks() {
        var removeTracks = [];
        for (var i = 0; i < techTracks.length; i++) {
          var found = false;
          for (var j = 0; j < elTracks.length; j++) {
            if (elTracks[j] === techTracks[i]) {
              found = true;
              break;
            }
          }
          if (!found) {
            removeTracks.push(techTracks[i]);
          }
        }
        while (removeTracks.length) {
          techTracks.removeTrack(removeTracks.shift());
        }
      };
      this[props.getterName + 'Listeners_'] = listeners;
      Object.keys(listeners).forEach(function (eventName) {
        var listener = listeners[eventName];
        elTracks.addEventListener(eventName, listener);
        _this3.on('dispose', function (e) {
          return elTracks.removeEventListener(eventName, listener);
        });
      });
      this.on('loadstart', removeOldTracks);
      this.on('dispose', function (e) {
        return _this3.off('loadstart', removeOldTracks);
      });
    }
    ;
    _proto.proxyNativeTracks_ = function proxyNativeTracks_() {
      var _this4 = this;
      NORMAL.names.forEach(function (name) {
        _this4.proxyNativeTracksForType_(name);
      });
    }
    ;
    _proto.createEl = function createEl() {
      var el = this.options_.tag;
      if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
        if (el) {
          var clone = el.cloneNode(true);
          if (el.parentNode) {
            el.parentNode.insertBefore(clone, el);
          }
          Html5.disposeMediaElement(el);
          el = clone;
        } else {
          el = document.createElement('video');
          var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
          var attributes = mergeOptions$3({}, tagAttributes);
          if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
            delete attributes.controls;
          }
          setAttributes(el, assign(attributes, {
            id: this.options_.techId,
            "class": 'vjs-tech'
          }));
        }
        el.playerId = this.options_.playerId;
      }
      if (typeof this.options_.preload !== 'undefined') {
        setAttribute(el, 'preload', this.options_.preload);
      }
      if (this.options_.disablePictureInPicture !== undefined) {
        el.disablePictureInPicture = this.options_.disablePictureInPicture;
      }
      var settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];
      for (var i = 0; i < settingsAttrs.length; i++) {
        var attr = settingsAttrs[i];
        var value = this.options_[attr];
        if (typeof value !== 'undefined') {
          if (value) {
            setAttribute(el, attr, attr);
          } else {
            removeAttribute(el, attr);
          }
          el[attr] = value;
        }
      }
      return el;
    }
    ;
    _proto.handleLateInit_ = function handleLateInit_(el) {
      if (el.networkState === 0 || el.networkState === 3) {
        return;
      }
      if (el.readyState === 0) {
        var loadstartFired = false;
        var setLoadstartFired = function setLoadstartFired() {
          loadstartFired = true;
        };
        this.on('loadstart', setLoadstartFired);
        var triggerLoadstart = function triggerLoadstart() {
          if (!loadstartFired) {
            this.trigger('loadstart');
          }
        };
        this.on('loadedmetadata', triggerLoadstart);
        this.ready(function () {
          this.off('loadstart', setLoadstartFired);
          this.off('loadedmetadata', triggerLoadstart);
          if (!loadstartFired) {
            this.trigger('loadstart');
          }
        });
        return;
      }
      var eventsToTrigger = ['loadstart'];
      eventsToTrigger.push('loadedmetadata');
      if (el.readyState >= 2) {
        eventsToTrigger.push('loadeddata');
      }
      if (el.readyState >= 3) {
        eventsToTrigger.push('canplay');
      }
      if (el.readyState >= 4) {
        eventsToTrigger.push('canplaythrough');
      }
      this.ready(function () {
        eventsToTrigger.forEach(function (type) {
          this.trigger(type);
        }, this);
      });
    }
    ;
    _proto.setScrubbing = function setScrubbing(isScrubbing) {
      this.isScrubbing_ = isScrubbing;
    }
    ;
    _proto.scrubbing = function scrubbing() {
      return this.isScrubbing_;
    }
    ;
    _proto.setCurrentTime = function setCurrentTime(seconds) {
      try {
        if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {
          this.el_.fastSeek(seconds);
        } else {
          this.el_.currentTime = seconds;
        }
      } catch (e) {
        log$1(e, 'Video is not ready. (Video.js)');
      }
    }
    ;
    _proto.duration = function duration() {
      var _this5 = this;
      if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
        var checkProgress = function checkProgress() {
          if (_this5.el_.currentTime > 0) {
            if (_this5.el_.duration === Infinity) {
              _this5.trigger('durationchange');
            }
            _this5.off('timeupdate', checkProgress);
          }
        };
        this.on('timeupdate', checkProgress);
        return NaN;
      }
      return this.el_.duration || NaN;
    }
    ;
    _proto.width = function width() {
      return this.el_.offsetWidth;
    }
    ;
    _proto.height = function height() {
      return this.el_.offsetHeight;
    }
    ;
    _proto.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {
      var _this6 = this;
      if (!('webkitDisplayingFullscreen' in this.el_)) {
        return;
      }
      var endFn = function endFn() {
        this.trigger('fullscreenchange', {
          isFullscreen: false
        });
        if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {
          this.el_.controls = false;
        }
      };
      var beginFn = function beginFn() {
        if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {
          this.one('webkitendfullscreen', endFn);
          this.trigger('fullscreenchange', {
            isFullscreen: true,
            nativeIOSFullscreen: true
          });
        }
      };
      this.on('webkitbeginfullscreen', beginFn);
      this.on('dispose', function () {
        _this6.off('webkitbeginfullscreen', beginFn);
        _this6.off('webkitendfullscreen', endFn);
      });
    }
    ;
    _proto.supportsFullScreen = function supportsFullScreen() {
      if (typeof this.el_.webkitEnterFullScreen === 'function') {
        var userAgent = window.navigator && window.navigator.userAgent || '';
        if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
          return true;
        }
      }
      return false;
    }
    ;
    _proto.enterFullScreen = function enterFullScreen() {
      var video = this.el_;
      if (video.paused && video.networkState <= video.HAVE_METADATA) {
        silencePromise(this.el_.play());
        this.setTimeout(function () {
          video.pause();
          try {
            video.webkitEnterFullScreen();
          } catch (e) {
            this.trigger('fullscreenerror', e);
          }
        }, 0);
      } else {
        try {
          video.webkitEnterFullScreen();
        } catch (e) {
          this.trigger('fullscreenerror', e);
        }
      }
    }
    ;
    _proto.exitFullScreen = function exitFullScreen() {
      if (!this.el_.webkitDisplayingFullscreen) {
        this.trigger('fullscreenerror', new Error('The video is not fullscreen'));
        return;
      }
      this.el_.webkitExitFullScreen();
    }
    ;
    _proto.requestPictureInPicture = function requestPictureInPicture() {
      return this.el_.requestPictureInPicture();
    }
    ;
    _proto.src = function src(_src) {
      if (_src === undefined) {
        return this.el_.src;
      }
      this.setSrc(_src);
    }
    ;
    _proto.reset = function reset() {
      Html5.resetMediaElement(this.el_);
    }
    ;
    _proto.currentSrc = function currentSrc() {
      if (this.currentSource_) {
        return this.currentSource_.src;
      }
      return this.el_.currentSrc;
    }
    ;
    _proto.setControls = function setControls(val) {
      this.el_.controls = !!val;
    }
    ;
    _proto.addTextTrack = function addTextTrack(kind, label, language) {
      if (!this.featuresNativeTextTracks) {
        return _Tech.prototype.addTextTrack.call(this, kind, label, language);
      }
      return this.el_.addTextTrack(kind, label, language);
    }
    ;
    _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {
      if (!this.featuresNativeTextTracks) {
        return _Tech.prototype.createRemoteTextTrack.call(this, options);
      }
      var htmlTrackElement = document.createElement('track');
      if (options.kind) {
        htmlTrackElement.kind = options.kind;
      }
      if (options.label) {
        htmlTrackElement.label = options.label;
      }
      if (options.language || options.srclang) {
        htmlTrackElement.srclang = options.language || options.srclang;
      }
      if (options["default"]) {
        htmlTrackElement["default"] = options["default"];
      }
      if (options.id) {
        htmlTrackElement.id = options.id;
      }
      if (options.src) {
        htmlTrackElement.src = options.src;
      }
      return htmlTrackElement;
    }
    ;
    _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
      var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);
      if (this.featuresNativeTextTracks) {
        this.el().appendChild(htmlTrackElement);
      }
      return htmlTrackElement;
    }
    ;
    _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
      _Tech.prototype.removeRemoteTextTrack.call(this, track);
      if (this.featuresNativeTextTracks) {
        var tracks = this.$$('track');
        var i = tracks.length;
        while (i--) {
          if (track === tracks[i] || track === tracks[i].track) {
            this.el().removeChild(tracks[i]);
          }
        }
      }
    }
    ;
    _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
      if (typeof this.el().getVideoPlaybackQuality === 'function') {
        return this.el().getVideoPlaybackQuality();
      }
      var videoPlaybackQuality = {};
      if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {
        videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
        videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
      }
      if (window.performance && typeof window.performance.now === 'function') {
        videoPlaybackQuality.creationTime = window.performance.now();
      } else if (window.performance && window.performance.timing && typeof window.performance.timing.navigationStart === 'number') {
        videoPlaybackQuality.creationTime = window.Date.now() - window.performance.timing.navigationStart;
      }
      return videoPlaybackQuality;
    };
    return Html5;
  }(Tech);
  defineLazyProperty(Html5, 'TEST_VID', function () {
    if (!isReal()) {
      return;
    }
    var video = document.createElement('video');
    var track = document.createElement('track');
    track.kind = 'captions';
    track.srclang = 'en';
    track.label = 'English';
    video.appendChild(track);
    return video;
  });
  Html5.isSupported = function () {
    try {
      Html5.TEST_VID.volume = 0.5;
    } catch (e) {
      return false;
    }
    return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
  };
  Html5.canPlayType = function (type) {
    return Html5.TEST_VID.canPlayType(type);
  };
  Html5.canPlaySource = function (srcObj, options) {
    return Html5.canPlayType(srcObj.type);
  };
  Html5.canControlVolume = function () {
    try {
      var volume = Html5.TEST_VID.volume;
      Html5.TEST_VID.volume = volume / 2 + 0.1;
      var canControl = volume !== Html5.TEST_VID.volume;
      if (canControl && IS_IOS) {
        window.setTimeout(function () {
          if (Html5 && Html5.prototype) {
            Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;
          }
        });
        return false;
      }
      return canControl;
    } catch (e) {
      return false;
    }
  };
  Html5.canMuteVolume = function () {
    try {
      var muted = Html5.TEST_VID.muted;
      Html5.TEST_VID.muted = !muted;
      if (Html5.TEST_VID.muted) {
        setAttribute(Html5.TEST_VID, 'muted', 'muted');
      } else {
        removeAttribute(Html5.TEST_VID, 'muted', 'muted');
      }
      return muted !== Html5.TEST_VID.muted;
    } catch (e) {
      return false;
    }
  };
  Html5.canControlPlaybackRate = function () {
    if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
      return false;
    }
    try {
      var playbackRate = Html5.TEST_VID.playbackRate;
      Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
      return playbackRate !== Html5.TEST_VID.playbackRate;
    } catch (e) {
      return false;
    }
  };
  Html5.canOverrideAttributes = function () {
    try {
      var noop = function noop() {};
      Object.defineProperty(document.createElement('video'), 'src', {
        get: noop,
        set: noop
      });
      Object.defineProperty(document.createElement('audio'), 'src', {
        get: noop,
        set: noop
      });
      Object.defineProperty(document.createElement('video'), 'innerHTML', {
        get: noop,
        set: noop
      });
      Object.defineProperty(document.createElement('audio'), 'innerHTML', {
        get: noop,
        set: noop
      });
    } catch (e) {
      return false;
    }
    return true;
  };
  Html5.supportsNativeTextTracks = function () {
    return IS_ANY_SAFARI || IS_IOS && IS_CHROME;
  };
  Html5.supportsNativeVideoTracks = function () {
    return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
  };
  Html5.supportsNativeAudioTracks = function () {
    return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
  };
  Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];
  [['featuresMuteControl', 'canMuteVolume'], ['featuresPlaybackRate', 'canControlPlaybackRate'], ['featuresSourceset', 'canOverrideAttributes'], ['featuresNativeTextTracks', 'supportsNativeTextTracks'], ['featuresNativeVideoTracks', 'supportsNativeVideoTracks'], ['featuresNativeAudioTracks', 'supportsNativeAudioTracks']].forEach(function (_ref) {
    var key = _ref[0],
        fn = _ref[1];
    defineLazyProperty(Html5.prototype, key, function () {
      return Html5[fn]();
    }, true);
  });
  Html5.prototype.featuresVolumeControl = Html5.canControlVolume();
  Html5.prototype.movingMediaElementInDOM = !IS_IOS;
  Html5.prototype.featuresFullscreenResize = true;
  Html5.prototype.featuresProgressEvents = true;
  Html5.prototype.featuresTimeupdateEvents = true;
  var canPlayType;
  Html5.patchCanPlayType = function () {
    if (ANDROID_VERSION >= 4.0 && !IS_FIREFOX && !IS_CHROME) {
      canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
      Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
        var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
        if (type && mpegurlRE.test(type)) {
          return 'maybe';
        }
        return canPlayType.call(this, type);
      };
    }
  };
  Html5.unpatchCanPlayType = function () {
    var r = Html5.TEST_VID.constructor.prototype.canPlayType;
    if (canPlayType) {
      Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
    }
    return r;
  };
  Html5.patchCanPlayType();
  Html5.disposeMediaElement = function (el) {
    if (!el) {
      return;
    }
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
    while (el.hasChildNodes()) {
      el.removeChild(el.firstChild);
    }
    el.removeAttribute('src');
    if (typeof el.load === 'function') {
      (function () {
        try {
          el.load();
        } catch (e) {
        }
      })();
    }
  };
  Html5.resetMediaElement = function (el) {
    if (!el) {
      return;
    }
    var sources = el.querySelectorAll('source');
    var i = sources.length;
    while (i--) {
      el.removeChild(sources[i]);
    }
    el.removeAttribute('src');
    if (typeof el.load === 'function') {
      (function () {
        try {
          el.load();
        } catch (e) {
        }
      })();
    }
  };
  [
  'muted',
  'defaultMuted',
  'autoplay',
  'controls',
  'loop',
  'playsinline'].forEach(function (prop) {
    Html5.prototype[prop] = function () {
      return this.el_[prop] || this.el_.hasAttribute(prop);
    };
  });
  [
  'muted',
  'defaultMuted',
  'autoplay',
  'loop',
  'playsinline'].forEach(function (prop) {
    Html5.prototype['set' + toTitleCase$1(prop)] = function (v) {
      this.el_[prop] = v;
      if (v) {
        this.el_.setAttribute(prop, prop);
      } else {
        this.el_.removeAttribute(prop);
      }
    };
  });
  [
  'paused',
  'currentTime',
  'buffered',
  'volume',
  'poster',
  'preload',
  'error',
  'seeking',
  'seekable',
  'ended',
  'playbackRate',
  'defaultPlaybackRate',
  'disablePictureInPicture',
  'played',
  'networkState',
  'readyState',
  'videoWidth',
  'videoHeight',
  'crossOrigin'].forEach(function (prop) {
    Html5.prototype[prop] = function () {
      return this.el_[prop];
    };
  });
  [
  'volume',
  'src',
  'poster',
  'preload',
  'playbackRate',
  'defaultPlaybackRate',
  'disablePictureInPicture',
  'crossOrigin'].forEach(function (prop) {
    Html5.prototype['set' + toTitleCase$1(prop)] = function (v) {
      this.el_[prop] = v;
    };
  });
  [
  'pause',
  'load',
  'play'].forEach(function (prop) {
    Html5.prototype[prop] = function () {
      return this.el_[prop]();
    };
  });
  Tech.withSourceHandlers(Html5);
  Html5.nativeSourceHandler = {};
  Html5.nativeSourceHandler.canPlayType = function (type) {
    try {
      return Html5.TEST_VID.canPlayType(type);
    } catch (e) {
      return '';
    }
  };
  Html5.nativeSourceHandler.canHandleSource = function (source, options) {
    if (source.type) {
      return Html5.nativeSourceHandler.canPlayType(source.type);
    } else if (source.src) {
      var ext = getFileExtension(source.src);
      return Html5.nativeSourceHandler.canPlayType("video/" + ext);
    }
    return '';
  };
  Html5.nativeSourceHandler.handleSource = function (source, tech, options) {
    tech.setSrc(source.src);
  };
  Html5.nativeSourceHandler.dispose = function () {};
  Html5.registerSourceHandler(Html5.nativeSourceHandler);
  Tech.registerTech('Html5', Html5);
  var TECH_EVENTS_RETRIGGER = [
  'progress',
  'abort',
  'suspend',
  'emptied',
  'stalled',
  'loadedmetadata',
  'loadeddata',
  'timeupdate',
  'resize',
  'volumechange',
  'texttrackchange'];
  var TECH_EVENTS_QUEUE = {
    canplay: 'CanPlay',
    canplaythrough: 'CanPlayThrough',
    playing: 'Playing',
    seeked: 'Seeked'
  };
  var BREAKPOINT_ORDER = ['tiny', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'huge'];
  var BREAKPOINT_CLASSES = {};
  BREAKPOINT_ORDER.forEach(function (k) {
    var v = k.charAt(0) === 'x' ? "x-" + k.substring(1) : k;
    BREAKPOINT_CLASSES[k] = "vjs-layout-" + v;
  });
  var DEFAULT_BREAKPOINTS = {
    tiny: 210,
    xsmall: 320,
    small: 425,
    medium: 768,
    large: 1440,
    xlarge: 2560,
    huge: Infinity
  };
  var Player = function (_Component) {
    inheritsLoose(Player, _Component);
    function Player(tag, options, ready) {
      var _this;
      tag.id = tag.id || options.id || "vjs_video_" + newGUID();
      options = assign(Player.getTagSettings(tag), options);
      options.initChildren = false;
      options.createEl = false;
      options.evented = false;
      options.reportTouchActivity = false;
      if (!options.language) {
        if (typeof tag.closest === 'function') {
          var closest = tag.closest('[lang]');
          if (closest && closest.getAttribute) {
            options.language = closest.getAttribute('lang');
          }
        } else {
          var element = tag;
          while (element && element.nodeType === 1) {
            if (getAttributes(element).hasOwnProperty('lang')) {
              options.language = element.getAttribute('lang');
              break;
            }
            element = element.parentNode;
          }
        }
      }
      _this = _Component.call(this, null, options, ready) || this;
      _this.boundDocumentFullscreenChange_ = function (e) {
        return _this.documentFullscreenChange_(e);
      };
      _this.boundFullWindowOnEscKey_ = function (e) {
        return _this.fullWindowOnEscKey(e);
      };
      _this.boundUpdateStyleEl_ = function (e) {
        return _this.updateStyleEl_(e);
      };
      _this.boundApplyInitTime_ = function (e) {
        return _this.applyInitTime_(e);
      };
      _this.boundUpdateCurrentBreakpoint_ = function (e) {
        return _this.updateCurrentBreakpoint_(e);
      };
      _this.boundHandleTechClick_ = function (e) {
        return _this.handleTechClick_(e);
      };
      _this.boundHandleTechDoubleClick_ = function (e) {
        return _this.handleTechDoubleClick_(e);
      };
      _this.boundHandleTechTouchStart_ = function (e) {
        return _this.handleTechTouchStart_(e);
      };
      _this.boundHandleTechTouchMove_ = function (e) {
        return _this.handleTechTouchMove_(e);
      };
      _this.boundHandleTechTouchEnd_ = function (e) {
        return _this.handleTechTouchEnd_(e);
      };
      _this.boundHandleTechTap_ = function (e) {
        return _this.handleTechTap_(e);
      };
      _this.isFullscreen_ = false;
      _this.log = createLogger(_this.id_);
      _this.fsApi_ = FullscreenApi;
      _this.isPosterFromTech_ = false;
      _this.queuedCallbacks_ = [];
      _this.isReady_ = false;
      _this.hasStarted_ = false;
      _this.userActive_ = false;
      _this.debugEnabled_ = false;
      if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {
        throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');
      }
      _this.tag = tag;
      _this.tagAttributes = tag && getAttributes(tag);
      _this.language(_this.options_.language);
      if (options.languages) {
        var languagesToLower = {};
        Object.getOwnPropertyNames(options.languages).forEach(function (name) {
          languagesToLower[name.toLowerCase()] = options.languages[name];
        });
        _this.languages_ = languagesToLower;
      } else {
        _this.languages_ = Player.prototype.options_.languages;
      }
      _this.resetCache_();
      _this.poster_ = options.poster || '';
      _this.controls_ = !!options.controls;
      tag.controls = false;
      tag.removeAttribute('controls');
      _this.changingSrc_ = false;
      _this.playCallbacks_ = [];
      _this.playTerminatedQueue_ = [];
      if (tag.hasAttribute('autoplay')) {
        _this.autoplay(true);
      } else {
        _this.autoplay(_this.options_.autoplay);
      }
      if (options.plugins) {
        Object.keys(options.plugins).forEach(function (name) {
          if (typeof _this[name] !== 'function') {
            throw new Error("plugin \"" + name + "\" does not exist");
          }
        });
      }
      _this.scrubbing_ = false;
      _this.el_ = _this.createEl();
      evented(assertThisInitialized(_this), {
        eventBusKey: 'el_'
      });
      if (_this.fsApi_.requestFullscreen) {
        on(document, _this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);
        _this.on(_this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);
      }
      if (_this.fluid_) {
        _this.on(['playerreset', 'resize'], _this.boundUpdateStyleEl_);
      }
      var playerOptionsCopy = mergeOptions$3(_this.options_);
      if (options.plugins) {
        Object.keys(options.plugins).forEach(function (name) {
          _this[name](options.plugins[name]);
        });
      }
      if (options.debug) {
        _this.debug(true);
      }
      _this.options_.playerOptions = playerOptionsCopy;
      _this.middleware_ = [];
      _this.playbackRates(options.playbackRates);
      _this.initChildren();
      _this.isAudio(tag.nodeName.toLowerCase() === 'audio');
      if (_this.controls()) {
        _this.addClass('vjs-controls-enabled');
      } else {
        _this.addClass('vjs-controls-disabled');
      }
      _this.el_.setAttribute('role', 'region');
      if (_this.isAudio()) {
        _this.el_.setAttribute('aria-label', _this.localize('Audio Player'));
      } else {
        _this.el_.setAttribute('aria-label', _this.localize('Video Player'));
      }
      if (_this.isAudio()) {
        _this.addClass('vjs-audio');
      }
      if (_this.flexNotSupported_()) {
        _this.addClass('vjs-no-flex');
      }
      if (TOUCH_ENABLED) {
        _this.addClass('vjs-touch-enabled');
      }
      if (!IS_IOS) {
        _this.addClass('vjs-workinghover');
      }
      Player.players[_this.id_] = assertThisInitialized(_this);
      var majorVersion = version$5.split('.')[0];
      _this.addClass("vjs-v" + majorVersion);
      _this.userActive(true);
      _this.reportUserActivity();
      _this.one('play', function (e) {
        return _this.listenForUserActivity_(e);
      });
      _this.on('stageclick', function (e) {
        return _this.handleStageClick_(e);
      });
      _this.on('keydown', function (e) {
        return _this.handleKeyDown(e);
      });
      _this.on('languagechange', function (e) {
        return _this.handleLanguagechange(e);
      });
      _this.breakpoints(_this.options_.breakpoints);
      _this.responsive(_this.options_.responsive);
      return _this;
    }
    var _proto = Player.prototype;
    _proto.dispose = function dispose() {
      var _this2 = this;
      this.trigger('dispose');
      this.off('dispose');
      off(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
      off(document, 'keydown', this.boundFullWindowOnEscKey_);
      if (this.styleEl_ && this.styleEl_.parentNode) {
        this.styleEl_.parentNode.removeChild(this.styleEl_);
        this.styleEl_ = null;
      }
      Player.players[this.id_] = null;
      if (this.tag && this.tag.player) {
        this.tag.player = null;
      }
      if (this.el_ && this.el_.player) {
        this.el_.player = null;
      }
      if (this.tech_) {
        this.tech_.dispose();
        this.isPosterFromTech_ = false;
        this.poster_ = '';
      }
      if (this.playerElIngest_) {
        this.playerElIngest_ = null;
      }
      if (this.tag) {
        this.tag = null;
      }
      clearCacheForPlayer(this);
      ALL.names.forEach(function (name) {
        var props = ALL[name];
        var list = _this2[props.getterName]();
        if (list && list.off) {
          list.off();
        }
      });
      _Component.prototype.dispose.call(this);
    }
    ;
    _proto.createEl = function createEl() {
      var tag = this.tag;
      var el;
      var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');
      var divEmbed = this.tag.tagName.toLowerCase() === 'video-js';
      if (playerElIngest) {
        el = this.el_ = tag.parentNode;
      } else if (!divEmbed) {
        el = this.el_ = _Component.prototype.createEl.call(this, 'div');
      }
      var attrs = getAttributes(tag);
      if (divEmbed) {
        el = this.el_ = tag;
        tag = this.tag = document.createElement('video');
        while (el.children.length) {
          tag.appendChild(el.firstChild);
        }
        if (!hasClass(el, 'video-js')) {
          addClass(el, 'video-js');
        }
        el.appendChild(tag);
        playerElIngest = this.playerElIngest_ = el;
        Object.keys(el).forEach(function (k) {
          try {
            tag[k] = el[k];
          } catch (e) {
          }
        });
      }
      tag.setAttribute('tabindex', '-1');
      attrs.tabindex = '-1';
      if (IE_VERSION || IS_CHROME && IS_WINDOWS) {
        tag.setAttribute('role', 'application');
        attrs.role = 'application';
      }
      tag.removeAttribute('width');
      tag.removeAttribute('height');
      if ('width' in attrs) {
        delete attrs.width;
      }
      if ('height' in attrs) {
        delete attrs.height;
      }
      Object.getOwnPropertyNames(attrs).forEach(function (attr) {
        if (!(divEmbed && attr === 'class')) {
          el.setAttribute(attr, attrs[attr]);
        }
        if (divEmbed) {
          tag.setAttribute(attr, attrs[attr]);
        }
      });
      tag.playerId = tag.id;
      tag.id += '_html5_api';
      tag.className = 'vjs-tech';
      tag.player = el.player = this;
      this.addClass('vjs-paused');
      if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
        this.styleEl_ = createStyleElement('vjs-styles-dimensions');
        var defaultsStyleEl = $('.vjs-styles-defaults');
        var head = $('head');
        head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
      }
      this.fill_ = false;
      this.fluid_ = false;
      this.width(this.options_.width);
      this.height(this.options_.height);
      this.fill(this.options_.fill);
      this.fluid(this.options_.fluid);
      this.aspectRatio(this.options_.aspectRatio);
      this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
      var links = tag.getElementsByTagName('a');
      for (var i = 0; i < links.length; i++) {
        var linkEl = links.item(i);
        addClass(linkEl, 'vjs-hidden');
        linkEl.setAttribute('hidden', 'hidden');
      }
      tag.initNetworkState_ = tag.networkState;
      if (tag.parentNode && !playerElIngest) {
        tag.parentNode.insertBefore(el, tag);
      }
      prependTo(tag, el);
      this.children_.unshift(tag);
      this.el_.setAttribute('lang', this.language_);
      this.el_.setAttribute('translate', 'no');
      this.el_ = el;
      return el;
    }
    ;
    _proto.crossOrigin = function crossOrigin(value) {
      if (!value) {
        return this.techGet_('crossOrigin');
      }
      if (value !== 'anonymous' && value !== 'use-credentials') {
        log$1.warn("crossOrigin must be \"anonymous\" or \"use-credentials\", given \"" + value + "\"");
        return;
      }
      this.techCall_('setCrossOrigin', value);
      return;
    }
    ;
    _proto.width = function width(value) {
      return this.dimension('width', value);
    }
    ;
    _proto.height = function height(value) {
      return this.dimension('height', value);
    }
    ;
    _proto.dimension = function dimension(_dimension, value) {
      var privDimension = _dimension + '_';
      if (value === undefined) {
        return this[privDimension] || 0;
      }
      if (value === '' || value === 'auto') {
        this[privDimension] = undefined;
        this.updateStyleEl_();
        return;
      }
      var parsedVal = parseFloat(value);
      if (isNaN(parsedVal)) {
        log$1.error("Improper value \"" + value + "\" supplied for for " + _dimension);
        return;
      }
      this[privDimension] = parsedVal;
      this.updateStyleEl_();
    }
    ;
    _proto.fluid = function fluid(bool) {
      var _this3 = this;
      if (bool === undefined) {
        return !!this.fluid_;
      }
      this.fluid_ = !!bool;
      if (isEvented(this)) {
        this.off(['playerreset', 'resize'], this.boundUpdateStyleEl_);
      }
      if (bool) {
        this.addClass('vjs-fluid');
        this.fill(false);
        addEventedCallback(this, function () {
          _this3.on(['playerreset', 'resize'], _this3.boundUpdateStyleEl_);
        });
      } else {
        this.removeClass('vjs-fluid');
      }
      this.updateStyleEl_();
    }
    ;
    _proto.fill = function fill(bool) {
      if (bool === undefined) {
        return !!this.fill_;
      }
      this.fill_ = !!bool;
      if (bool) {
        this.addClass('vjs-fill');
        this.fluid(false);
      } else {
        this.removeClass('vjs-fill');
      }
    }
    ;
    _proto.aspectRatio = function aspectRatio(ratio) {
      if (ratio === undefined) {
        return this.aspectRatio_;
      }
      if (!/^\d+\:\d+$/.test(ratio)) {
        throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');
      }
      this.aspectRatio_ = ratio;
      this.fluid(true);
      this.updateStyleEl_();
    }
    ;
    _proto.updateStyleEl_ = function updateStyleEl_() {
      if (window.VIDEOJS_NO_DYNAMIC_STYLE === true) {
        var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;
        var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;
        var techEl = this.tech_ && this.tech_.el();
        if (techEl) {
          if (_width >= 0) {
            techEl.width = _width;
          }
          if (_height >= 0) {
            techEl.height = _height;
          }
        }
        return;
      }
      var width;
      var height;
      var aspectRatio;
      var idClass;
      if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {
        aspectRatio = this.aspectRatio_;
      } else if (this.videoWidth() > 0) {
        aspectRatio = this.videoWidth() + ':' + this.videoHeight();
      } else {
        aspectRatio = '16:9';
      }
      var ratioParts = aspectRatio.split(':');
      var ratioMultiplier = ratioParts[1] / ratioParts[0];
      if (this.width_ !== undefined) {
        width = this.width_;
      } else if (this.height_ !== undefined) {
        width = this.height_ / ratioMultiplier;
      } else {
        width = this.videoWidth() || 300;
      }
      if (this.height_ !== undefined) {
        height = this.height_;
      } else {
        height = width * ratioMultiplier;
      }
      if (/^[^a-zA-Z]/.test(this.id())) {
        idClass = 'dimensions-' + this.id();
      } else {
        idClass = this.id() + '-dimensions';
      }
      this.addClass(idClass);
      setTextContent(this.styleEl_, "\n      ." + idClass + " {\n        width: " + width + "px;\n        height: " + height + "px;\n      }\n\n      ." + idClass + ".vjs-fluid {\n        padding-top: " + ratioMultiplier * 100 + "%;\n      }\n    ");
    }
    ;
    _proto.loadTech_ = function loadTech_(techName, source) {
      var _this4 = this;
      if (this.tech_) {
        this.unloadTech_();
      }
      var titleTechName = toTitleCase$1(techName);
      var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
      if (titleTechName !== 'Html5' && this.tag) {
        Tech.getTech('Html5').disposeMediaElement(this.tag);
        this.tag.player = null;
        this.tag = null;
      }
      this.techName_ = titleTechName;
      this.isReady_ = false;
      var autoplay = this.autoplay();
      if (typeof this.autoplay() === 'string' || this.autoplay() === true && this.options_.normalizeAutoplay) {
        autoplay = false;
      }
      var techOptions = {
        source: source,
        autoplay: autoplay,
        'nativeControlsForTouch': this.options_.nativeControlsForTouch,
        'playerId': this.id(),
        'techId': this.id() + "_" + camelTechName + "_api",
        'playsinline': this.options_.playsinline,
        'preload': this.options_.preload,
        'loop': this.options_.loop,
        'disablePictureInPicture': this.options_.disablePictureInPicture,
        'muted': this.options_.muted,
        'poster': this.poster(),
        'language': this.language(),
        'playerElIngest': this.playerElIngest_ || false,
        'vtt.js': this.options_['vtt.js'],
        'canOverridePoster': !!this.options_.techCanOverridePoster,
        'enableSourceset': this.options_.enableSourceset,
        'Promise': this.options_.Promise
      };
      ALL.names.forEach(function (name) {
        var props = ALL[name];
        techOptions[props.getterName] = _this4[props.privateName];
      });
      assign(techOptions, this.options_[titleTechName]);
      assign(techOptions, this.options_[camelTechName]);
      assign(techOptions, this.options_[techName.toLowerCase()]);
      if (this.tag) {
        techOptions.tag = this.tag;
      }
      if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
        techOptions.startTime = this.cache_.currentTime;
      }
      var TechClass = Tech.getTech(techName);
      if (!TechClass) {
        throw new Error("No Tech named '" + titleTechName + "' exists! '" + titleTechName + "' should be registered using videojs.registerTech()'");
      }
      this.tech_ = new TechClass(techOptions);
      this.tech_.ready(bind(this, this.handleTechReady_), true);
      textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);
      TECH_EVENTS_RETRIGGER.forEach(function (event) {
        _this4.on(_this4.tech_, event, function (e) {
          return _this4["handleTech" + toTitleCase$1(event) + "_"](e);
        });
      });
      Object.keys(TECH_EVENTS_QUEUE).forEach(function (event) {
        _this4.on(_this4.tech_, event, function (eventObj) {
          if (_this4.tech_.playbackRate() === 0 && _this4.tech_.seeking()) {
            _this4.queuedCallbacks_.push({
              callback: _this4["handleTech" + TECH_EVENTS_QUEUE[event] + "_"].bind(_this4),
              event: eventObj
            });
            return;
          }
          _this4["handleTech" + TECH_EVENTS_QUEUE[event] + "_"](eventObj);
        });
      });
      this.on(this.tech_, 'loadstart', function (e) {
        return _this4.handleTechLoadStart_(e);
      });
      this.on(this.tech_, 'sourceset', function (e) {
        return _this4.handleTechSourceset_(e);
      });
      this.on(this.tech_, 'waiting', function (e) {
        return _this4.handleTechWaiting_(e);
      });
      this.on(this.tech_, 'ended', function (e) {
        return _this4.handleTechEnded_(e);
      });
      this.on(this.tech_, 'seeking', function (e) {
        return _this4.handleTechSeeking_(e);
      });
      this.on(this.tech_, 'play', function (e) {
        return _this4.handleTechPlay_(e);
      });
      this.on(this.tech_, 'firstplay', function (e) {
        return _this4.handleTechFirstPlay_(e);
      });
      this.on(this.tech_, 'pause', function (e) {
        return _this4.handleTechPause_(e);
      });
      this.on(this.tech_, 'durationchange', function (e) {
        return _this4.handleTechDurationChange_(e);
      });
      this.on(this.tech_, 'fullscreenchange', function (e, data) {
        return _this4.handleTechFullscreenChange_(e, data);
      });
      this.on(this.tech_, 'fullscreenerror', function (e, err) {
        return _this4.handleTechFullscreenError_(e, err);
      });
      this.on(this.tech_, 'enterpictureinpicture', function (e) {
        return _this4.handleTechEnterPictureInPicture_(e);
      });
      this.on(this.tech_, 'leavepictureinpicture', function (e) {
        return _this4.handleTechLeavePictureInPicture_(e);
      });
      this.on(this.tech_, 'error', function (e) {
        return _this4.handleTechError_(e);
      });
      this.on(this.tech_, 'posterchange', function (e) {
        return _this4.handleTechPosterChange_(e);
      });
      this.on(this.tech_, 'textdata', function (e) {
        return _this4.handleTechTextData_(e);
      });
      this.on(this.tech_, 'ratechange', function (e) {
        return _this4.handleTechRateChange_(e);
      });
      this.on(this.tech_, 'loadedmetadata', this.boundUpdateStyleEl_);
      this.usingNativeControls(this.techGet_('controls'));
      if (this.controls() && !this.usingNativeControls()) {
        this.addTechControlsListeners_();
      }
      if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {
        prependTo(this.tech_.el(), this.el());
      }
      if (this.tag) {
        this.tag.player = null;
        this.tag = null;
      }
    }
    ;
    _proto.unloadTech_ = function unloadTech_() {
      var _this5 = this;
      ALL.names.forEach(function (name) {
        var props = ALL[name];
        _this5[props.privateName] = _this5[props.getterName]();
      });
      this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);
      this.isReady_ = false;
      this.tech_.dispose();
      this.tech_ = false;
      if (this.isPosterFromTech_) {
        this.poster_ = '';
        this.trigger('posterchange');
      }
      this.isPosterFromTech_ = false;
    }
    ;
    _proto.tech = function tech(safety) {
      if (safety === undefined) {
        log$1.warn('Using the tech directly can be dangerous. I hope you know what you\'re doing.\n' + 'See https://github.com/videojs/video.js/issues/2617 for more info.\n');
      }
      return this.tech_;
    }
    ;
    _proto.addTechControlsListeners_ = function addTechControlsListeners_() {
      this.removeTechControlsListeners_();
      this.on(this.tech_, 'click', this.boundHandleTechClick_);
      this.on(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_);
      this.on(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);
      this.on(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);
      this.on(this.tech_, 'touchend', this.boundHandleTechTouchEnd_);
      this.on(this.tech_, 'tap', this.boundHandleTechTap_);
    }
    ;
    _proto.removeTechControlsListeners_ = function removeTechControlsListeners_() {
      this.off(this.tech_, 'tap', this.boundHandleTechTap_);
      this.off(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);
      this.off(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);
      this.off(this.tech_, 'touchend', this.boundHandleTechTouchEnd_);
      this.off(this.tech_, 'click', this.boundHandleTechClick_);
      this.off(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_);
    }
    ;
    _proto.handleTechReady_ = function handleTechReady_() {
      this.triggerReady();
      if (this.cache_.volume) {
        this.techCall_('setVolume', this.cache_.volume);
      }
      this.handleTechPosterChange_();
      this.handleTechDurationChange_();
    }
    ;
    _proto.handleTechLoadStart_ = function handleTechLoadStart_() {
      this.removeClass('vjs-ended');
      this.removeClass('vjs-seeking');
      this.error(null);
      this.handleTechDurationChange_();
      if (!this.paused()) {
        this.trigger('loadstart');
        this.trigger('firstplay');
      } else {
        this.hasStarted(false);
        this.trigger('loadstart');
      }
      this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? 'play' : this.autoplay());
    }
    ;
    _proto.manualAutoplay_ = function manualAutoplay_(type) {
      var _this6 = this;
      if (!this.tech_ || typeof type !== 'string') {
        return;
      }
      var resolveMuted = function resolveMuted() {
        var previouslyMuted = _this6.muted();
        _this6.muted(true);
        var restoreMuted = function restoreMuted() {
          _this6.muted(previouslyMuted);
        };
        _this6.playTerminatedQueue_.push(restoreMuted);
        var mutedPromise = _this6.play();
        if (!isPromise(mutedPromise)) {
          return;
        }
        return mutedPromise["catch"](function (err) {
          restoreMuted();
          throw new Error("Rejection at manualAutoplay. Restoring muted value. " + (err ? err : ''));
        });
      };
      var promise;
      if (type === 'any' && !this.muted()) {
        promise = this.play();
        if (isPromise(promise)) {
          promise = promise["catch"](resolveMuted);
        }
      } else if (type === 'muted' && !this.muted()) {
        promise = resolveMuted();
      } else {
        promise = this.play();
      }
      if (!isPromise(promise)) {
        return;
      }
      return promise.then(function () {
        _this6.trigger({
          type: 'autoplay-success',
          autoplay: type
        });
      })["catch"](function () {
        _this6.trigger({
          type: 'autoplay-failure',
          autoplay: type
        });
      });
    }
    ;
    _proto.updateSourceCaches_ = function updateSourceCaches_(srcObj) {
      if (srcObj === void 0) {
        srcObj = '';
      }
      var src = srcObj;
      var type = '';
      if (typeof src !== 'string') {
        src = srcObj.src;
        type = srcObj.type;
      }
      this.cache_.source = this.cache_.source || {};
      this.cache_.sources = this.cache_.sources || [];
      if (src && !type) {
        type = findMimetype(this, src);
      }
      this.cache_.source = mergeOptions$3({}, srcObj, {
        src: src,
        type: type
      });
      var matchingSources = this.cache_.sources.filter(function (s) {
        return s.src && s.src === src;
      });
      var sourceElSources = [];
      var sourceEls = this.$$('source');
      var matchingSourceEls = [];
      for (var i = 0; i < sourceEls.length; i++) {
        var sourceObj = getAttributes(sourceEls[i]);
        sourceElSources.push(sourceObj);
        if (sourceObj.src && sourceObj.src === src) {
          matchingSourceEls.push(sourceObj.src);
        }
      }
      if (matchingSourceEls.length && !matchingSources.length) {
        this.cache_.sources = sourceElSources;
      } else if (!matchingSources.length) {
        this.cache_.sources = [this.cache_.source];
      }
      this.cache_.src = src;
    }
    ;
    _proto.handleTechSourceset_ = function handleTechSourceset_(event) {
      var _this7 = this;
      if (!this.changingSrc_) {
        var updateSourceCaches = function updateSourceCaches(src) {
          return _this7.updateSourceCaches_(src);
        };
        var playerSrc = this.currentSource().src;
        var eventSrc = event.src;
        if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {
          if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {
            updateSourceCaches = function updateSourceCaches() {};
          }
        }
        updateSourceCaches(eventSrc);
        if (!event.src) {
          this.tech_.any(['sourceset', 'loadstart'], function (e) {
            if (e.type === 'sourceset') {
              return;
            }
            var techSrc = _this7.techGet('currentSrc');
            _this7.lastSource_.tech = techSrc;
            _this7.updateSourceCaches_(techSrc);
          });
        }
      }
      this.lastSource_ = {
        player: this.currentSource().src,
        tech: event.src
      };
      this.trigger({
        src: event.src,
        type: 'sourceset'
      });
    }
    ;
    _proto.hasStarted = function hasStarted(request) {
      if (request === undefined) {
        return this.hasStarted_;
      }
      if (request === this.hasStarted_) {
        return;
      }
      this.hasStarted_ = request;
      if (this.hasStarted_) {
        this.addClass('vjs-has-started');
        this.trigger('firstplay');
      } else {
        this.removeClass('vjs-has-started');
      }
    }
    ;
    _proto.handleTechPlay_ = function handleTechPlay_() {
      this.removeClass('vjs-ended');
      this.removeClass('vjs-paused');
      this.addClass('vjs-playing');
      this.hasStarted(true);
      this.trigger('play');
    }
    ;
    _proto.handleTechRateChange_ = function handleTechRateChange_() {
      if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
        this.queuedCallbacks_.forEach(function (queued) {
          return queued.callback(queued.event);
        });
        this.queuedCallbacks_ = [];
      }
      this.cache_.lastPlaybackRate = this.tech_.playbackRate();
      this.trigger('ratechange');
    }
    ;
    _proto.handleTechWaiting_ = function handleTechWaiting_() {
      var _this8 = this;
      this.addClass('vjs-waiting');
      this.trigger('waiting');
      var timeWhenWaiting = this.currentTime();
      var timeUpdateListener = function timeUpdateListener() {
        if (timeWhenWaiting !== _this8.currentTime()) {
          _this8.removeClass('vjs-waiting');
          _this8.off('timeupdate', timeUpdateListener);
        }
      };
      this.on('timeupdate', timeUpdateListener);
    }
    ;
    _proto.handleTechCanPlay_ = function handleTechCanPlay_() {
      this.removeClass('vjs-waiting');
      this.trigger('canplay');
    }
    ;
    _proto.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
      this.removeClass('vjs-waiting');
      this.trigger('canplaythrough');
    }
    ;
    _proto.handleTechPlaying_ = function handleTechPlaying_() {
      this.removeClass('vjs-waiting');
      this.trigger('playing');
    }
    ;
    _proto.handleTechSeeking_ = function handleTechSeeking_() {
      this.addClass('vjs-seeking');
      this.trigger('seeking');
    }
    ;
    _proto.handleTechSeeked_ = function handleTechSeeked_() {
      this.removeClass('vjs-seeking');
      this.removeClass('vjs-ended');
      this.trigger('seeked');
    }
    ;
    _proto.handleTechFirstPlay_ = function handleTechFirstPlay_() {
      if (this.options_.starttime) {
        log$1.warn('Passing the `starttime` option to the player will be deprecated in 6.0');
        this.currentTime(this.options_.starttime);
      }
      this.addClass('vjs-has-started');
      this.trigger('firstplay');
    }
    ;
    _proto.handleTechPause_ = function handleTechPause_() {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
      this.trigger('pause');
    }
    ;
    _proto.handleTechEnded_ = function handleTechEnded_() {
      this.addClass('vjs-ended');
      this.removeClass('vjs-waiting');
      if (this.options_.loop) {
        this.currentTime(0);
        this.play();
      } else if (!this.paused()) {
        this.pause();
      }
      this.trigger('ended');
    }
    ;
    _proto.handleTechDurationChange_ = function handleTechDurationChange_() {
      this.duration(this.techGet_('duration'));
    }
    ;
    _proto.handleTechClick_ = function handleTechClick_(event) {
      if (!this.controls_) {
        return;
      }
      if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.click === undefined || this.options_.userActions.click !== false) {
        if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.click === 'function') {
          this.options_.userActions.click.call(this, event);
        } else if (this.paused()) {
          silencePromise(this.play());
        } else {
          this.pause();
        }
      }
    }
    ;
    _proto.handleTechDoubleClick_ = function handleTechDoubleClick_(event) {
      if (!this.controls_) {
        return;
      }
      var inAllowedEls = Array.prototype.some.call(this.$$('.vjs-control-bar, .vjs-modal-dialog'), function (el) {
        return el.contains(event.target);
      });
      if (!inAllowedEls) {
        if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.doubleClick === undefined || this.options_.userActions.doubleClick !== false) {
          if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.doubleClick === 'function') {
            this.options_.userActions.doubleClick.call(this, event);
          } else if (this.isFullscreen()) {
            this.exitFullscreen();
          } else {
            this.requestFullscreen();
          }
        }
      }
    }
    ;
    _proto.handleTechTap_ = function handleTechTap_() {
      this.userActive(!this.userActive());
    }
    ;
    _proto.handleTechTouchStart_ = function handleTechTouchStart_() {
      this.userWasActive = this.userActive();
    }
    ;
    _proto.handleTechTouchMove_ = function handleTechTouchMove_() {
      if (this.userWasActive) {
        this.reportUserActivity();
      }
    }
    ;
    _proto.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {
      if (event.cancelable) {
        event.preventDefault();
      }
    }
    ;
    _proto.handleStageClick_ = function handleStageClick_() {
      this.reportUserActivity();
    }
    ;
    _proto.toggleFullscreenClass_ = function toggleFullscreenClass_() {
      if (this.isFullscreen()) {
        this.addClass('vjs-fullscreen');
      } else {
        this.removeClass('vjs-fullscreen');
      }
    }
    ;
    _proto.documentFullscreenChange_ = function documentFullscreenChange_(e) {
      var targetPlayer = e.target.player;
      if (targetPlayer && targetPlayer !== this) {
        return;
      }
      var el = this.el();
      var isFs = document[this.fsApi_.fullscreenElement] === el;
      if (!isFs && el.matches) {
        isFs = el.matches(':' + this.fsApi_.fullscreen);
      } else if (!isFs && el.msMatchesSelector) {
        isFs = el.msMatchesSelector(':' + this.fsApi_.fullscreen);
      }
      this.isFullscreen(isFs);
    }
    ;
    _proto.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {
      var _this9 = this;
      if (data) {
        if (data.nativeIOSFullscreen) {
          this.addClass('vjs-ios-native-fs');
          this.tech_.one('webkitendfullscreen', function () {
            _this9.removeClass('vjs-ios-native-fs');
          });
        }
        this.isFullscreen(data.isFullscreen);
      }
    };
    _proto.handleTechFullscreenError_ = function handleTechFullscreenError_(event, err) {
      this.trigger('fullscreenerror', err);
    }
    ;
    _proto.togglePictureInPictureClass_ = function togglePictureInPictureClass_() {
      if (this.isInPictureInPicture()) {
        this.addClass('vjs-picture-in-picture');
      } else {
        this.removeClass('vjs-picture-in-picture');
      }
    }
    ;
    _proto.handleTechEnterPictureInPicture_ = function handleTechEnterPictureInPicture_(event) {
      this.isInPictureInPicture(true);
    }
    ;
    _proto.handleTechLeavePictureInPicture_ = function handleTechLeavePictureInPicture_(event) {
      this.isInPictureInPicture(false);
    }
    ;
    _proto.handleTechError_ = function handleTechError_() {
      var error = this.tech_.error();
      this.error(error);
    }
    ;
    _proto.handleTechTextData_ = function handleTechTextData_() {
      var data = null;
      if (arguments.length > 1) {
        data = arguments[1];
      }
      this.trigger('textdata', data);
    }
    ;
    _proto.getCache = function getCache() {
      return this.cache_;
    }
    ;
    _proto.resetCache_ = function resetCache_() {
      this.cache_ = {
        currentTime: 0,
        initTime: 0,
        inactivityTimeout: this.options_.inactivityTimeout,
        duration: NaN,
        lastVolume: 1,
        lastPlaybackRate: this.defaultPlaybackRate(),
        media: null,
        src: '',
        source: {},
        sources: [],
        playbackRates: [],
        volume: 1
      };
    }
    ;
    _proto.techCall_ = function techCall_(method, arg) {
      this.ready(function () {
        if (method in allowedSetters) {
          return set(this.middleware_, this.tech_, method, arg);
        } else if (method in allowedMediators) {
          return mediate(this.middleware_, this.tech_, method, arg);
        }
        try {
          if (this.tech_) {
            this.tech_[method](arg);
          }
        } catch (e) {
          log$1(e);
          throw e;
        }
      }, true);
    }
    ;
    _proto.techGet_ = function techGet_(method) {
      if (!this.tech_ || !this.tech_.isReady_) {
        return;
      }
      if (method in allowedGetters) {
        return get(this.middleware_, this.tech_, method);
      } else if (method in allowedMediators) {
        return mediate(this.middleware_, this.tech_, method);
      }
      try {
        return this.tech_[method]();
      } catch (e) {
        if (this.tech_[method] === undefined) {
          log$1("Video.js: " + method + " method not defined for " + this.techName_ + " playback technology.", e);
          throw e;
        }
        if (e.name === 'TypeError') {
          log$1("Video.js: " + method + " unavailable on " + this.techName_ + " playback technology element.", e);
          this.tech_.isReady_ = false;
          throw e;
        }
        log$1(e);
        throw e;
      }
    }
    ;
    _proto.play = function play() {
      var _this10 = this;
      var PromiseClass = this.options_.Promise || window.Promise;
      if (PromiseClass) {
        return new PromiseClass(function (resolve) {
          _this10.play_(resolve);
        });
      }
      return this.play_();
    }
    ;
    _proto.play_ = function play_(callback) {
      var _this11 = this;
      if (callback === void 0) {
        callback = silencePromise;
      }
      this.playCallbacks_.push(callback);
      var isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
      if (this.waitToPlay_) {
        this.off(['ready', 'loadstart'], this.waitToPlay_);
        this.waitToPlay_ = null;
      }
      if (!this.isReady_ || !isSrcReady) {
        this.waitToPlay_ = function (e) {
          _this11.play_();
        };
        this.one(['ready', 'loadstart'], this.waitToPlay_);
        if (!isSrcReady && (IS_ANY_SAFARI || IS_IOS)) {
          this.load();
        }
        return;
      }
      var val = this.techGet_('play');
      if (val === null) {
        this.runPlayTerminatedQueue_();
      } else {
        this.runPlayCallbacks_(val);
      }
    }
    ;
    _proto.runPlayTerminatedQueue_ = function runPlayTerminatedQueue_() {
      var queue = this.playTerminatedQueue_.slice(0);
      this.playTerminatedQueue_ = [];
      queue.forEach(function (q) {
        q();
      });
    }
    ;
    _proto.runPlayCallbacks_ = function runPlayCallbacks_(val) {
      var callbacks = this.playCallbacks_.slice(0);
      this.playCallbacks_ = [];
      this.playTerminatedQueue_ = [];
      callbacks.forEach(function (cb) {
        cb(val);
      });
    }
    ;
    _proto.pause = function pause() {
      this.techCall_('pause');
    }
    ;
    _proto.paused = function paused() {
      return this.techGet_('paused') === false ? false : true;
    }
    ;
    _proto.played = function played() {
      return this.techGet_('played') || createTimeRanges(0, 0);
    }
    ;
    _proto.scrubbing = function scrubbing(isScrubbing) {
      if (typeof isScrubbing === 'undefined') {
        return this.scrubbing_;
      }
      this.scrubbing_ = !!isScrubbing;
      this.techCall_('setScrubbing', this.scrubbing_);
      if (isScrubbing) {
        this.addClass('vjs-scrubbing');
      } else {
        this.removeClass('vjs-scrubbing');
      }
    }
    ;
    _proto.currentTime = function currentTime(seconds) {
      if (typeof seconds !== 'undefined') {
        if (seconds < 0) {
          seconds = 0;
        }
        if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
          this.cache_.initTime = seconds;
          this.off('canplay', this.boundApplyInitTime_);
          this.one('canplay', this.boundApplyInitTime_);
          return;
        }
        this.techCall_('setCurrentTime', seconds);
        this.cache_.initTime = 0;
        return;
      }
      this.cache_.currentTime = this.techGet_('currentTime') || 0;
      return this.cache_.currentTime;
    }
    ;
    _proto.applyInitTime_ = function applyInitTime_() {
      this.currentTime(this.cache_.initTime);
    }
    ;
    _proto.duration = function duration(seconds) {
      if (seconds === undefined) {
        return this.cache_.duration !== undefined ? this.cache_.duration : NaN;
      }
      seconds = parseFloat(seconds);
      if (seconds < 0) {
        seconds = Infinity;
      }
      if (seconds !== this.cache_.duration) {
        this.cache_.duration = seconds;
        if (seconds === Infinity) {
          this.addClass('vjs-live');
        } else {
          this.removeClass('vjs-live');
        }
        if (!isNaN(seconds)) {
          this.trigger('durationchange');
        }
      }
    }
    ;
    _proto.remainingTime = function remainingTime() {
      return this.duration() - this.currentTime();
    }
    ;
    _proto.remainingTimeDisplay = function remainingTimeDisplay() {
      return Math.floor(this.duration()) - Math.floor(this.currentTime());
    }
    ;
    _proto.buffered = function buffered() {
      var buffered = this.techGet_('buffered');
      if (!buffered || !buffered.length) {
        buffered = createTimeRanges(0, 0);
      }
      return buffered;
    }
    ;
    _proto.bufferedPercent = function bufferedPercent$1() {
      return bufferedPercent(this.buffered(), this.duration());
    }
    ;
    _proto.bufferedEnd = function bufferedEnd() {
      var buffered = this.buffered();
      var duration = this.duration();
      var end = buffered.end(buffered.length - 1);
      if (end > duration) {
        end = duration;
      }
      return end;
    }
    ;
    _proto.volume = function volume(percentAsDecimal) {
      var vol;
      if (percentAsDecimal !== undefined) {
        vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
        this.cache_.volume = vol;
        this.techCall_('setVolume', vol);
        if (vol > 0) {
          this.lastVolume_(vol);
        }
        return;
      }
      vol = parseFloat(this.techGet_('volume'));
      return isNaN(vol) ? 1 : vol;
    }
    ;
    _proto.muted = function muted(_muted) {
      if (_muted !== undefined) {
        this.techCall_('setMuted', _muted);
        return;
      }
      return this.techGet_('muted') || false;
    }
    ;
    _proto.defaultMuted = function defaultMuted(_defaultMuted) {
      if (_defaultMuted !== undefined) {
        return this.techCall_('setDefaultMuted', _defaultMuted);
      }
      return this.techGet_('defaultMuted') || false;
    }
    ;
    _proto.lastVolume_ = function lastVolume_(percentAsDecimal) {
      if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {
        this.cache_.lastVolume = percentAsDecimal;
        return;
      }
      return this.cache_.lastVolume;
    }
    ;
    _proto.supportsFullScreen = function supportsFullScreen() {
      return this.techGet_('supportsFullScreen') || false;
    }
    ;
    _proto.isFullscreen = function isFullscreen(isFS) {
      if (isFS !== undefined) {
        var oldValue = this.isFullscreen_;
        this.isFullscreen_ = Boolean(isFS);
        if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {
          this.trigger('fullscreenchange');
        }
        this.toggleFullscreenClass_();
        return;
      }
      return this.isFullscreen_;
    }
    ;
    _proto.requestFullscreen = function requestFullscreen(fullscreenOptions) {
      var PromiseClass = this.options_.Promise || window.Promise;
      if (PromiseClass) {
        var self = this;
        return new PromiseClass(function (resolve, reject) {
          function offHandler() {
            self.off('fullscreenerror', errorHandler);
            self.off('fullscreenchange', changeHandler);
          }
          function changeHandler() {
            offHandler();
            resolve();
          }
          function errorHandler(e, err) {
            offHandler();
            reject(err);
          }
          self.one('fullscreenchange', changeHandler);
          self.one('fullscreenerror', errorHandler);
          var promise = self.requestFullscreenHelper_(fullscreenOptions);
          if (promise) {
            promise.then(offHandler, offHandler);
            promise.then(resolve, reject);
          }
        });
      }
      return this.requestFullscreenHelper_();
    };
    _proto.requestFullscreenHelper_ = function requestFullscreenHelper_(fullscreenOptions) {
      var _this12 = this;
      var fsOptions;
      if (!this.fsApi_.prefixed) {
        fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};
        if (fullscreenOptions !== undefined) {
          fsOptions = fullscreenOptions;
        }
      }
      if (this.fsApi_.requestFullscreen) {
        var promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);
        if (promise) {
          promise.then(function () {
            return _this12.isFullscreen(true);
          }, function () {
            return _this12.isFullscreen(false);
          });
        }
        return promise;
      } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
        this.techCall_('enterFullScreen');
      } else {
        this.enterFullWindow();
      }
    }
    ;
    _proto.exitFullscreen = function exitFullscreen() {
      var PromiseClass = this.options_.Promise || window.Promise;
      if (PromiseClass) {
        var self = this;
        return new PromiseClass(function (resolve, reject) {
          function offHandler() {
            self.off('fullscreenerror', errorHandler);
            self.off('fullscreenchange', changeHandler);
          }
          function changeHandler() {
            offHandler();
            resolve();
          }
          function errorHandler(e, err) {
            offHandler();
            reject(err);
          }
          self.one('fullscreenchange', changeHandler);
          self.one('fullscreenerror', errorHandler);
          var promise = self.exitFullscreenHelper_();
          if (promise) {
            promise.then(offHandler, offHandler);
            promise.then(resolve, reject);
          }
        });
      }
      return this.exitFullscreenHelper_();
    };
    _proto.exitFullscreenHelper_ = function exitFullscreenHelper_() {
      var _this13 = this;
      if (this.fsApi_.requestFullscreen) {
        var promise = document[this.fsApi_.exitFullscreen]();
        if (promise) {
          silencePromise(promise.then(function () {
            return _this13.isFullscreen(false);
          }));
        }
        return promise;
      } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
        this.techCall_('exitFullScreen');
      } else {
        this.exitFullWindow();
      }
    }
    ;
    _proto.enterFullWindow = function enterFullWindow() {
      this.isFullscreen(true);
      this.isFullWindow = true;
      this.docOrigOverflow = document.documentElement.style.overflow;
      on(document, 'keydown', this.boundFullWindowOnEscKey_);
      document.documentElement.style.overflow = 'hidden';
      addClass(document.body, 'vjs-full-window');
      this.trigger('enterFullWindow');
    }
    ;
    _proto.fullWindowOnEscKey = function fullWindowOnEscKey(event) {
      if (keycode.isEventKey(event, 'Esc')) {
        if (this.isFullscreen() === true) {
          if (!this.isFullWindow) {
            this.exitFullscreen();
          } else {
            this.exitFullWindow();
          }
        }
      }
    }
    ;
    _proto.exitFullWindow = function exitFullWindow() {
      this.isFullscreen(false);
      this.isFullWindow = false;
      off(document, 'keydown', this.boundFullWindowOnEscKey_);
      document.documentElement.style.overflow = this.docOrigOverflow;
      removeClass(document.body, 'vjs-full-window');
      this.trigger('exitFullWindow');
    }
    ;
    _proto.disablePictureInPicture = function disablePictureInPicture(value) {
      if (value === undefined) {
        return this.techGet_('disablePictureInPicture');
      }
      this.techCall_('setDisablePictureInPicture', value);
      this.options_.disablePictureInPicture = value;
      this.trigger('disablepictureinpicturechanged');
    }
    ;
    _proto.isInPictureInPicture = function isInPictureInPicture(isPiP) {
      if (isPiP !== undefined) {
        this.isInPictureInPicture_ = !!isPiP;
        this.togglePictureInPictureClass_();
        return;
      }
      return !!this.isInPictureInPicture_;
    }
    ;
    _proto.requestPictureInPicture = function requestPictureInPicture() {
      if ('pictureInPictureEnabled' in document && this.disablePictureInPicture() === false) {
        return this.techGet_('requestPictureInPicture');
      }
    }
    ;
    _proto.exitPictureInPicture = function exitPictureInPicture() {
      if ('pictureInPictureEnabled' in document) {
        return document.exitPictureInPicture();
      }
    }
    ;
    _proto.handleKeyDown = function handleKeyDown(event) {
      var userActions = this.options_.userActions;
      if (!userActions || !userActions.hotkeys) {
        return;
      }
      var excludeElement = function excludeElement(el) {
        var tagName = el.tagName.toLowerCase();
        if (el.isContentEditable) {
          return true;
        }
        var allowedInputTypes = ['button', 'checkbox', 'hidden', 'radio', 'reset', 'submit'];
        if (tagName === 'input') {
          return allowedInputTypes.indexOf(el.type) === -1;
        }
        var excludedTags = ['textarea'];
        return excludedTags.indexOf(tagName) !== -1;
      };
      if (excludeElement(this.el_.ownerDocument.activeElement)) {
        return;
      }
      if (typeof userActions.hotkeys === 'function') {
        userActions.hotkeys.call(this, event);
      } else {
        this.handleHotkeys(event);
      }
    }
    ;
    _proto.handleHotkeys = function handleHotkeys(event) {
      var hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};
      var _hotkeys$fullscreenKe = hotkeys.fullscreenKey,
          fullscreenKey = _hotkeys$fullscreenKe === void 0 ? function (keydownEvent) {
        return keycode.isEventKey(keydownEvent, 'f');
      } : _hotkeys$fullscreenKe,
          _hotkeys$muteKey = hotkeys.muteKey,
          muteKey = _hotkeys$muteKey === void 0 ? function (keydownEvent) {
        return keycode.isEventKey(keydownEvent, 'm');
      } : _hotkeys$muteKey,
          _hotkeys$playPauseKey = hotkeys.playPauseKey,
          playPauseKey = _hotkeys$playPauseKey === void 0 ? function (keydownEvent) {
        return keycode.isEventKey(keydownEvent, 'k') || keycode.isEventKey(keydownEvent, 'Space');
      } : _hotkeys$playPauseKey;
      if (fullscreenKey.call(this, event)) {
        event.preventDefault();
        event.stopPropagation();
        var FSToggle = Component$1.getComponent('FullscreenToggle');
        if (document[this.fsApi_.fullscreenEnabled] !== false) {
          FSToggle.prototype.handleClick.call(this, event);
        }
      } else if (muteKey.call(this, event)) {
        event.preventDefault();
        event.stopPropagation();
        var MuteToggle = Component$1.getComponent('MuteToggle');
        MuteToggle.prototype.handleClick.call(this, event);
      } else if (playPauseKey.call(this, event)) {
        event.preventDefault();
        event.stopPropagation();
        var PlayToggle = Component$1.getComponent('PlayToggle');
        PlayToggle.prototype.handleClick.call(this, event);
      }
    }
    ;
    _proto.canPlayType = function canPlayType(type) {
      var can;
      for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {
        var techName = j[i];
        var tech = Tech.getTech(techName);
        if (!tech) {
          tech = Component$1.getComponent(techName);
        }
        if (!tech) {
          log$1.error("The \"" + techName + "\" tech is undefined. Skipped browser support check for that tech.");
          continue;
        }
        if (tech.isSupported()) {
          can = tech.canPlayType(type);
          if (can) {
            return can;
          }
        }
      }
      return '';
    }
    ;
    _proto.selectSource = function selectSource(sources) {
      var _this14 = this;
      var techs = this.options_.techOrder.map(function (techName) {
        return [techName, Tech.getTech(techName)];
      }).filter(function (_ref) {
        var techName = _ref[0],
            tech = _ref[1];
        if (tech) {
          return tech.isSupported();
        }
        log$1.error("The \"" + techName + "\" tech is undefined. Skipped browser support check for that tech.");
        return false;
      });
      var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {
        var found;
        outerArray.some(function (outerChoice) {
          return innerArray.some(function (innerChoice) {
            found = tester(outerChoice, innerChoice);
            if (found) {
              return true;
            }
          });
        });
        return found;
      };
      var foundSourceAndTech;
      var flip = function flip(fn) {
        return function (a, b) {
          return fn(b, a);
        };
      };
      var finder = function finder(_ref2, source) {
        var techName = _ref2[0],
            tech = _ref2[1];
        if (tech.canPlaySource(source, _this14.options_[techName.toLowerCase()])) {
          return {
            source: source,
            tech: techName
          };
        }
      };
      if (this.options_.sourceOrder) {
        foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
      } else {
        foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
      }
      return foundSourceAndTech || false;
    }
    ;
    _proto.handleSrc_ = function handleSrc_(source, isRetry) {
      var _this15 = this;
      if (typeof source === 'undefined') {
        return this.cache_.src || '';
      }
      if (this.resetRetryOnError_) {
        this.resetRetryOnError_();
      }
      var sources = filterSource(source);
      if (!sources.length) {
        this.setTimeout(function () {
          this.error({
            code: 4,
            message: this.localize(this.options_.notSupportedMessage)
          });
        }, 0);
        return;
      }
      this.changingSrc_ = true;
      if (!isRetry) {
        this.cache_.sources = sources;
      }
      this.updateSourceCaches_(sources[0]);
      setSource(this, sources[0], function (middlewareSource, mws) {
        _this15.middleware_ = mws;
        if (!isRetry) {
          _this15.cache_.sources = sources;
        }
        _this15.updateSourceCaches_(middlewareSource);
        var err = _this15.src_(middlewareSource);
        if (err) {
          if (sources.length > 1) {
            return _this15.handleSrc_(sources.slice(1));
          }
          _this15.changingSrc_ = false;
          _this15.setTimeout(function () {
            this.error({
              code: 4,
              message: this.localize(this.options_.notSupportedMessage)
            });
          }, 0);
          _this15.triggerReady();
          return;
        }
        setTech(mws, _this15.tech_);
      });
      if (this.options_.retryOnError && sources.length > 1) {
        var retry = function retry() {
          _this15.error(null);
          _this15.handleSrc_(sources.slice(1), true);
        };
        var stopListeningForErrors = function stopListeningForErrors() {
          _this15.off('error', retry);
        };
        this.one('error', retry);
        this.one('playing', stopListeningForErrors);
        this.resetRetryOnError_ = function () {
          _this15.off('error', retry);
          _this15.off('playing', stopListeningForErrors);
        };
      }
    }
    ;
    _proto.src = function src(source) {
      return this.handleSrc_(source, false);
    }
    ;
    _proto.src_ = function src_(source) {
      var _this16 = this;
      var sourceTech = this.selectSource([source]);
      if (!sourceTech) {
        return true;
      }
      if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
        this.changingSrc_ = true;
        this.loadTech_(sourceTech.tech, sourceTech.source);
        this.tech_.ready(function () {
          _this16.changingSrc_ = false;
        });
        return false;
      }
      this.ready(function () {
        if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {
          this.techCall_('setSource', source);
        } else {
          this.techCall_('src', source.src);
        }
        this.changingSrc_ = false;
      }, true);
      return false;
    }
    ;
    _proto.load = function load() {
      this.techCall_('load');
    }
    ;
    _proto.reset = function reset() {
      var _this17 = this;
      var PromiseClass = this.options_.Promise || window.Promise;
      if (this.paused() || !PromiseClass) {
        this.doReset_();
      } else {
        var playPromise = this.play();
        silencePromise(playPromise.then(function () {
          return _this17.doReset_();
        }));
      }
    };
    _proto.doReset_ = function doReset_() {
      if (this.tech_) {
        this.tech_.clearTracks('text');
      }
      this.resetCache_();
      this.poster('');
      this.loadTech_(this.options_.techOrder[0], null);
      this.techCall_('reset');
      this.resetControlBarUI_();
      if (isEvented(this)) {
        this.trigger('playerreset');
      }
    }
    ;
    _proto.resetControlBarUI_ = function resetControlBarUI_() {
      this.resetProgressBar_();
      this.resetPlaybackRate_();
      this.resetVolumeBar_();
    }
    ;
    _proto.resetProgressBar_ = function resetProgressBar_() {
      this.currentTime(0);
      var _this$controlBar = this.controlBar,
          durationDisplay = _this$controlBar.durationDisplay,
          remainingTimeDisplay = _this$controlBar.remainingTimeDisplay;
      if (durationDisplay) {
        durationDisplay.updateContent();
      }
      if (remainingTimeDisplay) {
        remainingTimeDisplay.updateContent();
      }
    }
    ;
    _proto.resetPlaybackRate_ = function resetPlaybackRate_() {
      this.playbackRate(this.defaultPlaybackRate());
      this.handleTechRateChange_();
    }
    ;
    _proto.resetVolumeBar_ = function resetVolumeBar_() {
      this.volume(1.0);
      this.trigger('volumechange');
    }
    ;
    _proto.currentSources = function currentSources() {
      var source = this.currentSource();
      var sources = [];
      if (Object.keys(source).length !== 0) {
        sources.push(source);
      }
      return this.cache_.sources || sources;
    }
    ;
    _proto.currentSource = function currentSource() {
      return this.cache_.source || {};
    }
    ;
    _proto.currentSrc = function currentSrc() {
      return this.currentSource() && this.currentSource().src || '';
    }
    ;
    _proto.currentType = function currentType() {
      return this.currentSource() && this.currentSource().type || '';
    }
    ;
    _proto.preload = function preload(value) {
      if (value !== undefined) {
        this.techCall_('setPreload', value);
        this.options_.preload = value;
        return;
      }
      return this.techGet_('preload');
    }
    ;
    _proto.autoplay = function autoplay(value) {
      if (value === undefined) {
        return this.options_.autoplay || false;
      }
      var techAutoplay;
      if (typeof value === 'string' && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {
        this.options_.autoplay = value;
        this.manualAutoplay_(typeof value === 'string' ? value : 'play');
        techAutoplay = false;
      } else if (!value) {
        this.options_.autoplay = false;
      } else {
        this.options_.autoplay = true;
      }
      techAutoplay = typeof techAutoplay === 'undefined' ? this.options_.autoplay : techAutoplay;
      if (this.tech_) {
        this.techCall_('setAutoplay', techAutoplay);
      }
    }
    ;
    _proto.playsinline = function playsinline(value) {
      if (value !== undefined) {
        this.techCall_('setPlaysinline', value);
        this.options_.playsinline = value;
        return this;
      }
      return this.techGet_('playsinline');
    }
    ;
    _proto.loop = function loop(value) {
      if (value !== undefined) {
        this.techCall_('setLoop', value);
        this.options_.loop = value;
        return;
      }
      return this.techGet_('loop');
    }
    ;
    _proto.poster = function poster(src) {
      if (src === undefined) {
        return this.poster_;
      }
      if (!src) {
        src = '';
      }
      if (src === this.poster_) {
        return;
      }
      this.poster_ = src;
      this.techCall_('setPoster', src);
      this.isPosterFromTech_ = false;
      this.trigger('posterchange');
    }
    ;
    _proto.handleTechPosterChange_ = function handleTechPosterChange_() {
      if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
        var newPoster = this.tech_.poster() || '';
        if (newPoster !== this.poster_) {
          this.poster_ = newPoster;
          this.isPosterFromTech_ = true;
          this.trigger('posterchange');
        }
      }
    }
    ;
    _proto.controls = function controls(bool) {
      if (bool === undefined) {
        return !!this.controls_;
      }
      bool = !!bool;
      if (this.controls_ === bool) {
        return;
      }
      this.controls_ = bool;
      if (this.usingNativeControls()) {
        this.techCall_('setControls', bool);
      }
      if (this.controls_) {
        this.removeClass('vjs-controls-disabled');
        this.addClass('vjs-controls-enabled');
        this.trigger('controlsenabled');
        if (!this.usingNativeControls()) {
          this.addTechControlsListeners_();
        }
      } else {
        this.removeClass('vjs-controls-enabled');
        this.addClass('vjs-controls-disabled');
        this.trigger('controlsdisabled');
        if (!this.usingNativeControls()) {
          this.removeTechControlsListeners_();
        }
      }
    }
    ;
    _proto.usingNativeControls = function usingNativeControls(bool) {
      if (bool === undefined) {
        return !!this.usingNativeControls_;
      }
      bool = !!bool;
      if (this.usingNativeControls_ === bool) {
        return;
      }
      this.usingNativeControls_ = bool;
      if (this.usingNativeControls_) {
        this.addClass('vjs-using-native-controls');
        this.trigger('usingnativecontrols');
      } else {
        this.removeClass('vjs-using-native-controls');
        this.trigger('usingcustomcontrols');
      }
    }
    ;
    _proto.error = function error(err) {
      var _this18 = this;
      if (err === undefined) {
        return this.error_ || null;
      }
      hooks('beforeerror').forEach(function (hookFunction) {
        var newErr = hookFunction(_this18, err);
        if (!(isObject$1(newErr) && !Array.isArray(newErr) || typeof newErr === 'string' || typeof newErr === 'number' || newErr === null)) {
          _this18.log.error('please return a value that MediaError expects in beforeerror hooks');
          return;
        }
        err = newErr;
      });
      if (this.options_.suppressNotSupportedError && err && err.code === 4) {
        var triggerSuppressedError = function triggerSuppressedError() {
          this.error(err);
        };
        this.options_.suppressNotSupportedError = false;
        this.any(['click', 'touchstart'], triggerSuppressedError);
        this.one('loadstart', function () {
          this.off(['click', 'touchstart'], triggerSuppressedError);
        });
        return;
      }
      if (err === null) {
        this.error_ = err;
        this.removeClass('vjs-error');
        if (this.errorDisplay) {
          this.errorDisplay.close();
        }
        return;
      }
      this.error_ = new MediaError(err);
      this.addClass('vjs-error');
      log$1.error("(CODE:" + this.error_.code + " " + MediaError.errorTypes[this.error_.code] + ")", this.error_.message, this.error_);
      this.trigger('error');
      hooks('error').forEach(function (hookFunction) {
        return hookFunction(_this18, _this18.error_);
      });
      return;
    }
    ;
    _proto.reportUserActivity = function reportUserActivity(event) {
      this.userActivity_ = true;
    }
    ;
    _proto.userActive = function userActive(bool) {
      if (bool === undefined) {
        return this.userActive_;
      }
      bool = !!bool;
      if (bool === this.userActive_) {
        return;
      }
      this.userActive_ = bool;
      if (this.userActive_) {
        this.userActivity_ = true;
        this.removeClass('vjs-user-inactive');
        this.addClass('vjs-user-active');
        this.trigger('useractive');
        return;
      }
      if (this.tech_) {
        this.tech_.one('mousemove', function (e) {
          e.stopPropagation();
          e.preventDefault();
        });
      }
      this.userActivity_ = false;
      this.removeClass('vjs-user-active');
      this.addClass('vjs-user-inactive');
      this.trigger('userinactive');
    }
    ;
    _proto.listenForUserActivity_ = function listenForUserActivity_() {
      var mouseInProgress;
      var lastMoveX;
      var lastMoveY;
      var handleActivity = bind(this, this.reportUserActivity);
      var handleMouseMove = function handleMouseMove(e) {
        if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
          lastMoveX = e.screenX;
          lastMoveY = e.screenY;
          handleActivity();
        }
      };
      var handleMouseDown = function handleMouseDown() {
        handleActivity();
        this.clearInterval(mouseInProgress);
        mouseInProgress = this.setInterval(handleActivity, 250);
      };
      var handleMouseUpAndMouseLeave = function handleMouseUpAndMouseLeave(event) {
        handleActivity();
        this.clearInterval(mouseInProgress);
      };
      this.on('mousedown', handleMouseDown);
      this.on('mousemove', handleMouseMove);
      this.on('mouseup', handleMouseUpAndMouseLeave);
      this.on('mouseleave', handleMouseUpAndMouseLeave);
      var controlBar = this.getChild('controlBar');
      if (controlBar && !IS_IOS && !IS_ANDROID) {
        controlBar.on('mouseenter', function (event) {
          if (this.player().options_.inactivityTimeout !== 0) {
            this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;
          }
          this.player().options_.inactivityTimeout = 0;
        });
        controlBar.on('mouseleave', function (event) {
          this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
        });
      }
      this.on('keydown', handleActivity);
      this.on('keyup', handleActivity);
      var inactivityTimeout;
      this.setInterval(function () {
        if (!this.userActivity_) {
          return;
        }
        this.userActivity_ = false;
        this.userActive(true);
        this.clearTimeout(inactivityTimeout);
        var timeout = this.options_.inactivityTimeout;
        if (timeout <= 0) {
          return;
        }
        inactivityTimeout = this.setTimeout(function () {
          if (!this.userActivity_) {
            this.userActive(false);
          }
        }, timeout);
      }, 250);
    }
    ;
    _proto.playbackRate = function playbackRate(rate) {
      if (rate !== undefined) {
        this.techCall_('setPlaybackRate', rate);
        return;
      }
      if (this.tech_ && this.tech_.featuresPlaybackRate) {
        return this.cache_.lastPlaybackRate || this.techGet_('playbackRate');
      }
      return 1.0;
    }
    ;
    _proto.defaultPlaybackRate = function defaultPlaybackRate(rate) {
      if (rate !== undefined) {
        return this.techCall_('setDefaultPlaybackRate', rate);
      }
      if (this.tech_ && this.tech_.featuresPlaybackRate) {
        return this.techGet_('defaultPlaybackRate');
      }
      return 1.0;
    }
    ;
    _proto.isAudio = function isAudio(bool) {
      if (bool !== undefined) {
        this.isAudio_ = !!bool;
        return;
      }
      return !!this.isAudio_;
    }
    ;
    _proto.addTextTrack = function addTextTrack(kind, label, language) {
      if (this.tech_) {
        return this.tech_.addTextTrack(kind, label, language);
      }
    }
    ;
    _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
      if (this.tech_) {
        return this.tech_.addRemoteTextTrack(options, manualCleanup);
      }
    }
    ;
    _proto.removeRemoteTextTrack = function removeRemoteTextTrack(obj) {
      if (obj === void 0) {
        obj = {};
      }
      var _obj = obj,
          track = _obj.track;
      if (!track) {
        track = obj;
      }
      if (this.tech_) {
        return this.tech_.removeRemoteTextTrack(track);
      }
    }
    ;
    _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
      return this.techGet_('getVideoPlaybackQuality');
    }
    ;
    _proto.videoWidth = function videoWidth() {
      return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
    }
    ;
    _proto.videoHeight = function videoHeight() {
      return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
    }
    ;
    _proto.language = function language(code) {
      if (code === undefined) {
        return this.language_;
      }
      if (this.language_ !== String(code).toLowerCase()) {
        this.language_ = String(code).toLowerCase();
        if (isEvented(this)) {
          this.trigger('languagechange');
        }
      }
    }
    ;
    _proto.languages = function languages() {
      return mergeOptions$3(Player.prototype.options_.languages, this.languages_);
    }
    ;
    _proto.toJSON = function toJSON() {
      var options = mergeOptions$3(this.options_);
      var tracks = options.tracks;
      options.tracks = [];
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        track = mergeOptions$3(track);
        track.player = undefined;
        options.tracks[i] = track;
      }
      return options;
    }
    ;
    _proto.createModal = function createModal(content, options) {
      var _this19 = this;
      options = options || {};
      options.content = content || '';
      var modal = new ModalDialog(this, options);
      this.addChild(modal);
      modal.on('dispose', function () {
        _this19.removeChild(modal);
      });
      modal.open();
      return modal;
    }
    ;
    _proto.updateCurrentBreakpoint_ = function updateCurrentBreakpoint_() {
      if (!this.responsive()) {
        return;
      }
      var currentBreakpoint = this.currentBreakpoint();
      var currentWidth = this.currentWidth();
      for (var i = 0; i < BREAKPOINT_ORDER.length; i++) {
        var candidateBreakpoint = BREAKPOINT_ORDER[i];
        var maxWidth = this.breakpoints_[candidateBreakpoint];
        if (currentWidth <= maxWidth) {
          if (currentBreakpoint === candidateBreakpoint) {
            return;
          }
          if (currentBreakpoint) {
            this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);
          }
          this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);
          this.breakpoint_ = candidateBreakpoint;
          break;
        }
      }
    }
    ;
    _proto.removeCurrentBreakpoint_ = function removeCurrentBreakpoint_() {
      var className = this.currentBreakpointClass();
      this.breakpoint_ = '';
      if (className) {
        this.removeClass(className);
      }
    }
    ;
    _proto.breakpoints = function breakpoints(_breakpoints) {
      if (_breakpoints === undefined) {
        return assign(this.breakpoints_);
      }
      this.breakpoint_ = '';
      this.breakpoints_ = assign({}, DEFAULT_BREAKPOINTS, _breakpoints);
      this.updateCurrentBreakpoint_();
      return assign(this.breakpoints_);
    }
    ;
    _proto.responsive = function responsive(value) {
      if (value === undefined) {
        return this.responsive_;
      }
      value = Boolean(value);
      var current = this.responsive_;
      if (value === current) {
        return;
      }
      this.responsive_ = value;
      if (value) {
        this.on('playerresize', this.boundUpdateCurrentBreakpoint_);
        this.updateCurrentBreakpoint_();
      } else {
        this.off('playerresize', this.boundUpdateCurrentBreakpoint_);
        this.removeCurrentBreakpoint_();
      }
      return value;
    }
    ;
    _proto.currentBreakpoint = function currentBreakpoint() {
      return this.breakpoint_;
    }
    ;
    _proto.currentBreakpointClass = function currentBreakpointClass() {
      return BREAKPOINT_CLASSES[this.breakpoint_] || '';
    }
    ;
    _proto.loadMedia = function loadMedia(media, ready) {
      var _this20 = this;
      if (!media || typeof media !== 'object') {
        return;
      }
      this.reset();
      this.cache_.media = mergeOptions$3(media);
      var _this$cache_$media = this.cache_.media,
          artwork = _this$cache_$media.artwork,
          poster = _this$cache_$media.poster,
          src = _this$cache_$media.src,
          textTracks = _this$cache_$media.textTracks;
      if (!artwork && poster) {
        this.cache_.media.artwork = [{
          src: poster,
          type: getMimetype(poster)
        }];
      }
      if (src) {
        this.src(src);
      }
      if (poster) {
        this.poster(poster);
      }
      if (Array.isArray(textTracks)) {
        textTracks.forEach(function (tt) {
          return _this20.addRemoteTextTrack(tt, false);
        });
      }
      this.ready(ready);
    }
    ;
    _proto.getMedia = function getMedia() {
      if (!this.cache_.media) {
        var poster = this.poster();
        var src = this.currentSources();
        var textTracks = Array.prototype.map.call(this.remoteTextTracks(), function (tt) {
          return {
            kind: tt.kind,
            label: tt.label,
            language: tt.language,
            src: tt.src
          };
        });
        var media = {
          src: src,
          textTracks: textTracks
        };
        if (poster) {
          media.poster = poster;
          media.artwork = [{
            src: media.poster,
            type: getMimetype(media.poster)
          }];
        }
        return media;
      }
      return mergeOptions$3(this.cache_.media);
    }
    ;
    Player.getTagSettings = function getTagSettings(tag) {
      var baseOptions = {
        sources: [],
        tracks: []
      };
      var tagOptions = getAttributes(tag);
      var dataSetup = tagOptions['data-setup'];
      if (hasClass(tag, 'vjs-fill')) {
        tagOptions.fill = true;
      }
      if (hasClass(tag, 'vjs-fluid')) {
        tagOptions.fluid = true;
      }
      if (dataSetup !== null) {
        var _safeParseTuple = tuple(dataSetup || '{}'),
            err = _safeParseTuple[0],
            data = _safeParseTuple[1];
        if (err) {
          log$1.error(err);
        }
        assign(tagOptions, data);
      }
      assign(baseOptions, tagOptions);
      if (tag.hasChildNodes()) {
        var children = tag.childNodes;
        for (var i = 0, j = children.length; i < j; i++) {
          var child = children[i];
          var childName = child.nodeName.toLowerCase();
          if (childName === 'source') {
            baseOptions.sources.push(getAttributes(child));
          } else if (childName === 'track') {
            baseOptions.tracks.push(getAttributes(child));
          }
        }
      }
      return baseOptions;
    }
    ;
    _proto.flexNotSupported_ = function flexNotSupported_() {
      var elem = document.createElement('i');
      return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style ||
      'msFlexOrder' in elem.style);
    }
    ;
    _proto.debug = function debug(enabled) {
      if (enabled === undefined) {
        return this.debugEnabled_;
      }
      if (enabled) {
        this.trigger('debugon');
        this.previousLogLevel_ = this.log.level;
        this.log.level('debug');
        this.debugEnabled_ = true;
      } else {
        this.trigger('debugoff');
        this.log.level(this.previousLogLevel_);
        this.previousLogLevel_ = undefined;
        this.debugEnabled_ = false;
      }
    }
    ;
    _proto.playbackRates = function playbackRates(newRates) {
      if (newRates === undefined) {
        return this.cache_.playbackRates;
      }
      if (!Array.isArray(newRates)) {
        return;
      }
      if (!newRates.every(function (rate) {
        return typeof rate === 'number';
      })) {
        return;
      }
      this.cache_.playbackRates = newRates;
      this.trigger('playbackrateschange');
    };
    return Player;
  }(Component$1);
  ALL.names.forEach(function (name) {
    var props = ALL[name];
    Player.prototype[props.getterName] = function () {
      if (this.tech_) {
        return this.tech_[props.getterName]();
      }
      this[props.privateName] = this[props.privateName] || new props.ListClass();
      return this[props.privateName];
    };
  });
  Player.prototype.crossorigin = Player.prototype.crossOrigin;
  Player.players = {};
  var navigator = window.navigator;
  Player.prototype.options_ = {
    techOrder: Tech.defaultTechOrder_,
    html5: {},
    inactivityTimeout: 2000,
    playbackRates: [],
    liveui: false,
    children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'liveTracker', 'controlBar', 'errorDisplay', 'textTrackSettings', 'resizeManager'],
    language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',
    languages: {},
    notSupportedMessage: 'No compatible source was found for this media.',
    normalizeAutoplay: false,
    fullscreen: {
      options: {
        navigationUI: 'hide'
      }
    },
    breakpoints: {},
    responsive: false
  };
  [
  'ended',
  'seeking',
  'seekable',
  'networkState',
  'readyState'].forEach(function (fn) {
    Player.prototype[fn] = function () {
      return this.techGet_(fn);
    };
  });
  TECH_EVENTS_RETRIGGER.forEach(function (event) {
    Player.prototype["handleTech" + toTitleCase$1(event) + "_"] = function () {
      return this.trigger(event);
    };
  });
  Component$1.registerComponent('Player', Player);
  var setPrototypeOf = createCommonjsModule(function (module) {
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    module.exports = _setPrototypeOf;
  });
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  var isNativeReflectConstruct = _isNativeReflectConstruct;
  var construct = createCommonjsModule(function (module) {
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        module.exports = _construct = Reflect.construct;
      } else {
        module.exports = _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    module.exports = _construct;
  });
  var BASE_PLUGIN_NAME = 'plugin';
  var PLUGIN_CACHE_KEY = 'activePlugins_';
  var pluginStorage = {};
  var pluginExists = function pluginExists(name) {
    return pluginStorage.hasOwnProperty(name);
  };
  var getPlugin = function getPlugin(name) {
    return pluginExists(name) ? pluginStorage[name] : undefined;
  };
  var markPluginAsActive = function markPluginAsActive(player, name) {
    player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
    player[PLUGIN_CACHE_KEY][name] = true;
  };
  var triggerSetupEvent = function triggerSetupEvent(player, hash, before) {
    var eventName = (before ? 'before' : '') + 'pluginsetup';
    player.trigger(eventName, hash);
    player.trigger(eventName + ':' + hash.name, hash);
  };
  var createBasicPlugin = function createBasicPlugin(name, plugin) {
    var basicPluginWrapper = function basicPluginWrapper() {
      triggerSetupEvent(this, {
        name: name,
        plugin: plugin,
        instance: null
      }, true);
      var instance = plugin.apply(this, arguments);
      markPluginAsActive(this, name);
      triggerSetupEvent(this, {
        name: name,
        plugin: plugin,
        instance: instance
      });
      return instance;
    };
    Object.keys(plugin).forEach(function (prop) {
      basicPluginWrapper[prop] = plugin[prop];
    });
    return basicPluginWrapper;
  };
  var createPluginFactory = function createPluginFactory(name, PluginSubClass) {
    PluginSubClass.prototype.name = name;
    return function () {
      triggerSetupEvent(this, {
        name: name,
        plugin: PluginSubClass,
        instance: null
      }, true);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var instance = construct(PluginSubClass, [this].concat(args));
      this[name] = function () {
        return instance;
      };
      triggerSetupEvent(this, instance.getEventHash());
      return instance;
    };
  };
  var Plugin = function () {
    function Plugin(player) {
      if (this.constructor === Plugin) {
        throw new Error('Plugin must be sub-classed; not directly instantiated.');
      }
      this.player = player;
      if (!this.log) {
        this.log = this.player.log.createLogger(this.name);
      }
      evented(this);
      delete this.trigger;
      stateful(this, this.constructor.defaultState);
      markPluginAsActive(player, this.name);
      this.dispose = this.dispose.bind(this);
      player.on('dispose', this.dispose);
    }
    var _proto = Plugin.prototype;
    _proto.version = function version() {
      return this.constructor.VERSION;
    }
    ;
    _proto.getEventHash = function getEventHash(hash) {
      if (hash === void 0) {
        hash = {};
      }
      hash.name = this.name;
      hash.plugin = this.constructor;
      hash.instance = this;
      return hash;
    }
    ;
    _proto.trigger = function trigger$1(event, hash) {
      if (hash === void 0) {
        hash = {};
      }
      return trigger(this.eventBusEl_, event, this.getEventHash(hash));
    }
    ;
    _proto.handleStateChanged = function handleStateChanged(e) {}
    ;
    _proto.dispose = function dispose() {
      var name = this.name,
          player = this.player;
      this.trigger('dispose');
      this.off();
      player.off('dispose', this.dispose);
      player[PLUGIN_CACHE_KEY][name] = false;
      this.player = this.state = null;
      player[name] = createPluginFactory(name, pluginStorage[name]);
    }
    ;
    Plugin.isBasic = function isBasic(plugin) {
      var p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;
      return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);
    }
    ;
    Plugin.registerPlugin = function registerPlugin(name, plugin) {
      if (typeof name !== 'string') {
        throw new Error("Illegal plugin name, \"" + name + "\", must be a string, was " + typeof name + ".");
      }
      if (pluginExists(name)) {
        log$1.warn("A plugin named \"" + name + "\" already exists. You may want to avoid re-registering plugins!");
      } else if (Player.prototype.hasOwnProperty(name)) {
        throw new Error("Illegal plugin name, \"" + name + "\", cannot share a name with an existing player method!");
      }
      if (typeof plugin !== 'function') {
        throw new Error("Illegal plugin for \"" + name + "\", must be a function, was " + typeof plugin + ".");
      }
      pluginStorage[name] = plugin;
      if (name !== BASE_PLUGIN_NAME) {
        if (Plugin.isBasic(plugin)) {
          Player.prototype[name] = createBasicPlugin(name, plugin);
        } else {
          Player.prototype[name] = createPluginFactory(name, plugin);
        }
      }
      return plugin;
    }
    ;
    Plugin.deregisterPlugin = function deregisterPlugin(name) {
      if (name === BASE_PLUGIN_NAME) {
        throw new Error('Cannot de-register base plugin.');
      }
      if (pluginExists(name)) {
        delete pluginStorage[name];
        delete Player.prototype[name];
      }
    }
    ;
    Plugin.getPlugins = function getPlugins(names) {
      if (names === void 0) {
        names = Object.keys(pluginStorage);
      }
      var result;
      names.forEach(function (name) {
        var plugin = getPlugin(name);
        if (plugin) {
          result = result || {};
          result[name] = plugin;
        }
      });
      return result;
    }
    ;
    Plugin.getPluginVersion = function getPluginVersion(name) {
      var plugin = getPlugin(name);
      return plugin && plugin.VERSION || '';
    };
    return Plugin;
  }();
  Plugin.getPlugin = getPlugin;
  Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;
  Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);
  Player.prototype.usingPlugin = function (name) {
    return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
  };
  Player.prototype.hasPlugin = function (name) {
    return !!pluginExists(name);
  };
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
  var inherits = _inherits;
  var extend = function extend(superClass, subClassMethods) {
    if (subClassMethods === void 0) {
      subClassMethods = {};
    }
    var subClass = function subClass() {
      superClass.apply(this, arguments);
    };
    var methods = {};
    if (typeof subClassMethods === 'object') {
      if (subClassMethods.constructor !== Object.prototype.constructor) {
        subClass = subClassMethods.constructor;
      }
      methods = subClassMethods;
    } else if (typeof subClassMethods === 'function') {
      subClass = subClassMethods;
    }
    inherits(subClass, superClass);
    if (superClass) {
      subClass.super_ = superClass;
    }
    for (var name in methods) {
      if (methods.hasOwnProperty(name)) {
        subClass.prototype[name] = methods[name];
      }
    }
    return subClass;
  };
  var normalizeId = function normalizeId(id) {
    return id.indexOf('#') === 0 ? id.slice(1) : id;
  };
  function videojs(id, options, ready) {
    var player = videojs.getPlayer(id);
    if (player) {
      if (options) {
        log$1.warn("Player \"" + id + "\" is already initialised. Options will not be applied.");
      }
      if (ready) {
        player.ready(ready);
      }
      return player;
    }
    var el = typeof id === 'string' ? $('#' + normalizeId(id)) : id;
    if (!isEl(el)) {
      throw new TypeError('The element or ID supplied is not valid. (videojs)');
    }
    if (!el.ownerDocument.defaultView || !el.ownerDocument.body.contains(el)) {
      log$1.warn('The element supplied is not included in the DOM');
    }
    options = options || {};
    hooks('beforesetup').forEach(function (hookFunction) {
      var opts = hookFunction(el, mergeOptions$3(options));
      if (!isObject$1(opts) || Array.isArray(opts)) {
        log$1.error('please return an object in beforesetup hooks');
        return;
      }
      options = mergeOptions$3(options, opts);
    });
    var PlayerComponent = Component$1.getComponent('Player');
    player = new PlayerComponent(el, options, ready);
    hooks('setup').forEach(function (hookFunction) {
      return hookFunction(player);
    });
    return player;
  }
  videojs.hooks_ = hooks_;
  videojs.hooks = hooks;
  videojs.hook = hook;
  videojs.hookOnce = hookOnce;
  videojs.removeHook = removeHook;
  if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
    var style = $('.vjs-styles-defaults');
    if (!style) {
      style = createStyleElement('vjs-styles-defaults');
      var head = $('head');
      if (head) {
        head.insertBefore(style, head.firstChild);
      }
      setTextContent(style, "\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid {\n        padding-top: 56.25%\n      }\n    ");
    }
  }
  autoSetupTimeout(1, videojs);
  videojs.VERSION = version$5;
  videojs.options = Player.prototype.options_;
  videojs.getPlayers = function () {
    return Player.players;
  };
  videojs.getPlayer = function (id) {
    var players = Player.players;
    var tag;
    if (typeof id === 'string') {
      var nId = normalizeId(id);
      var player = players[nId];
      if (player) {
        return player;
      }
      tag = $('#' + nId);
    } else {
      tag = id;
    }
    if (isEl(tag)) {
      var _tag = tag,
          _player = _tag.player,
          playerId = _tag.playerId;
      if (_player || players[playerId]) {
        return _player || players[playerId];
      }
    }
  };
  videojs.getAllPlayers = function () {
    return (
      Object.keys(Player.players).map(function (k) {
        return Player.players[k];
      }).filter(Boolean)
    );
  };
  videojs.players = Player.players;
  videojs.getComponent = Component$1.getComponent;
  videojs.registerComponent = function (name, comp) {
    if (Tech.isTech(comp)) {
      log$1.warn("The " + name + " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)");
    }
    Component$1.registerComponent.call(Component$1, name, comp);
  };
  videojs.getTech = Tech.getTech;
  videojs.registerTech = Tech.registerTech;
  videojs.use = use;
  Object.defineProperty(videojs, 'middleware', {
    value: {},
    writeable: false,
    enumerable: true
  });
  Object.defineProperty(videojs.middleware, 'TERMINATOR', {
    value: TERMINATOR,
    writeable: false,
    enumerable: true
  });
  videojs.browser = browser;
  videojs.TOUCH_ENABLED = TOUCH_ENABLED;
  videojs.extend = extend;
  videojs.mergeOptions = mergeOptions$3;
  videojs.bind = bind;
  videojs.registerPlugin = Plugin.registerPlugin;
  videojs.deregisterPlugin = Plugin.deregisterPlugin;
  videojs.plugin = function (name, plugin) {
    log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');
    return Plugin.registerPlugin(name, plugin);
  };
  videojs.getPlugins = Plugin.getPlugins;
  videojs.getPlugin = Plugin.getPlugin;
  videojs.getPluginVersion = Plugin.getPluginVersion;
  videojs.addLanguage = function (code, data) {
    var _mergeOptions;
    code = ('' + code).toLowerCase();
    videojs.options.languages = mergeOptions$3(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));
    return videojs.options.languages[code];
  };
  videojs.log = log$1;
  videojs.createLogger = createLogger;
  videojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;
  videojs.formatTime = formatTime;
  videojs.setFormatTime = setFormatTime;
  videojs.resetFormatTime = resetFormatTime;
  videojs.parseUrl = parseUrl;
  videojs.isCrossOrigin = isCrossOrigin;
  videojs.EventTarget = EventTarget$2;
  videojs.on = on;
  videojs.one = one;
  videojs.off = off;
  videojs.trigger = trigger;
  videojs.xhr = lib;
  videojs.TextTrack = TextTrack;
  videojs.AudioTrack = AudioTrack;
  videojs.VideoTrack = VideoTrack;
  ['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(function (k) {
    videojs[k] = function () {
      log$1.warn("videojs." + k + "() is deprecated; use videojs.dom." + k + "() instead");
      return Dom[k].apply(null, arguments);
    };
  });
  videojs.computedStyle = computedStyle;
  videojs.dom = Dom;
  videojs.url = Url;
  videojs.defineLazyProperty = defineLazyProperty;
  videojs.addLanguage('en', {
    'Non-Fullscreen': 'Exit Fullscreen'
  });
  var urlToolkit = createCommonjsModule(function (module, exports) {
    (function (root) {
      var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#[^]*)?$/;
      var FIRST_SEGMENT_REGEX = /^([^\/?#]*)([^]*)$/;
      var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
      var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
      var URLToolkit = {
        buildAbsoluteURL: function buildAbsoluteURL(baseURL, relativeURL, opts) {
          opts = opts || {};
          baseURL = baseURL.trim();
          relativeURL = relativeURL.trim();
          if (!relativeURL) {
            if (!opts.alwaysNormalize) {
              return baseURL;
            }
            var basePartsForNormalise = URLToolkit.parseURL(baseURL);
            if (!basePartsForNormalise) {
              throw new Error('Error trying to parse base URL.');
            }
            basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
            return URLToolkit.buildURLFromParts(basePartsForNormalise);
          }
          var relativeParts = URLToolkit.parseURL(relativeURL);
          if (!relativeParts) {
            throw new Error('Error trying to parse relative URL.');
          }
          if (relativeParts.scheme) {
            if (!opts.alwaysNormalize) {
              return relativeURL;
            }
            relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
            return URLToolkit.buildURLFromParts(relativeParts);
          }
          var baseParts = URLToolkit.parseURL(baseURL);
          if (!baseParts) {
            throw new Error('Error trying to parse base URL.');
          }
          if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
            var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
            baseParts.netLoc = pathParts[1];
            baseParts.path = pathParts[2];
          }
          if (baseParts.netLoc && !baseParts.path) {
            baseParts.path = '/';
          }
          var builtParts = {
            scheme: baseParts.scheme,
            netLoc: relativeParts.netLoc,
            path: null,
            params: relativeParts.params,
            query: relativeParts.query,
            fragment: relativeParts.fragment
          };
          if (!relativeParts.netLoc) {
            builtParts.netLoc = baseParts.netLoc;
            if (relativeParts.path[0] !== '/') {
              if (!relativeParts.path) {
                builtParts.path = baseParts.path;
                if (!relativeParts.params) {
                  builtParts.params = baseParts.params;
                  if (!relativeParts.query) {
                    builtParts.query = baseParts.query;
                  }
                }
              } else {
                var baseURLPath = baseParts.path;
                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
                builtParts.path = URLToolkit.normalizePath(newPath);
              }
            }
          }
          if (builtParts.path === null) {
            builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
          }
          return URLToolkit.buildURLFromParts(builtParts);
        },
        parseURL: function parseURL(url) {
          var parts = URL_REGEX.exec(url);
          if (!parts) {
            return null;
          }
          return {
            scheme: parts[1] || '',
            netLoc: parts[2] || '',
            path: parts[3] || '',
            params: parts[4] || '',
            query: parts[5] || '',
            fragment: parts[6] || ''
          };
        },
        normalizePath: function normalizePath(path) {
          path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
          while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {}
          return path.split('').reverse().join('');
        },
        buildURLFromParts: function buildURLFromParts(parts) {
          return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
        }
      };
      module.exports = URLToolkit;
    })();
  });
  var DEFAULT_LOCATION = 'http://example.com';
  var resolveUrl$1 = function resolveUrl(baseUrl, relativeUrl) {
    if (/^[a-z]+:/i.test(relativeUrl)) {
      return relativeUrl;
    }
    if (/^data:/.test(baseUrl)) {
      baseUrl = window.location && window.location.href || '';
    }
    var nativeURL = typeof window.URL === 'function';
    var protocolLess = /^\/\//.test(baseUrl);
    var removeLocation = !window.location && !/\/\//i.test(baseUrl);
    if (nativeURL) {
      baseUrl = new window.URL(baseUrl, window.location || DEFAULT_LOCATION);
    } else if (!/\/\//i.test(baseUrl)) {
      baseUrl = urlToolkit.buildAbsoluteURL(window.location && window.location.href || '', baseUrl);
    }
    if (nativeURL) {
      var newUrl = new URL(relativeUrl, baseUrl);
      if (removeLocation) {
        return newUrl.href.slice(DEFAULT_LOCATION.length);
      } else if (protocolLess) {
        return newUrl.href.slice(newUrl.protocol.length);
      }
      return newUrl.href;
    }
    return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);
  };
  var Stream = function () {
    function Stream() {
      this.listeners = {};
    }
    var _proto = Stream.prototype;
    _proto.on = function on(type, listener) {
      if (!this.listeners[type]) {
        this.listeners[type] = [];
      }
      this.listeners[type].push(listener);
    }
    ;
    _proto.off = function off(type, listener) {
      if (!this.listeners[type]) {
        return false;
      }
      var index = this.listeners[type].indexOf(listener);
      this.listeners[type] = this.listeners[type].slice(0);
      this.listeners[type].splice(index, 1);
      return index > -1;
    }
    ;
    _proto.trigger = function trigger(type) {
      var callbacks = this.listeners[type];
      if (!callbacks) {
        return;
      }
      if (arguments.length === 2) {
        var length = callbacks.length;
        for (var i = 0; i < length; ++i) {
          callbacks[i].call(this, arguments[1]);
        }
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        var _length = callbacks.length;
        for (var _i = 0; _i < _length; ++_i) {
          callbacks[_i].apply(this, args);
        }
      }
    }
    ;
    _proto.dispose = function dispose() {
      this.listeners = {};
    }
    ;
    _proto.pipe = function pipe(destination) {
      this.on('data', function (data) {
        destination.push(data);
      });
    };
    return Stream;
  }();
  var atob = function atob(s) {
    return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');
  };
  function decodeB64ToUint8Array(b64Text) {
    var decodedString = atob(b64Text);
    var array = new Uint8Array(decodedString.length);
    for (var i = 0; i < decodedString.length; i++) {
      array[i] = decodedString.charCodeAt(i);
    }
    return array;
  }
  /*! @name m3u8-parser @version 4.7.0 @license Apache-2.0 */
  var LineStream = function (_Stream) {
    inheritsLoose(LineStream, _Stream);
    function LineStream() {
      var _this;
      _this = _Stream.call(this) || this;
      _this.buffer = '';
      return _this;
    }
    var _proto = LineStream.prototype;
    _proto.push = function push(data) {
      var nextNewline;
      this.buffer += data;
      nextNewline = this.buffer.indexOf('\n');
      for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\n')) {
        this.trigger('data', this.buffer.substring(0, nextNewline));
        this.buffer = this.buffer.substring(nextNewline + 1);
      }
    };
    return LineStream;
  }(Stream);
  var TAB = String.fromCharCode(0x09);
  var parseByterange = function parseByterange(byterangeString) {
    var match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');
    var result = {};
    if (match[1]) {
      result.length = parseInt(match[1], 10);
    }
    if (match[2]) {
      result.offset = parseInt(match[2], 10);
    }
    return result;
  };
  var attributeSeparator = function attributeSeparator() {
    var key = '[^=]*';
    var value = '"[^"]*"|[^,]*';
    var keyvalue = '(?:' + key + ')=(?:' + value + ')';
    return new RegExp('(?:^|,)(' + keyvalue + ')');
  };
  var parseAttributes$1 = function parseAttributes(attributes) {
    var attrs = attributes.split(attributeSeparator());
    var result = {};
    var i = attrs.length;
    var attr;
    while (i--) {
      if (attrs[i] === '') {
        continue;
      }
      attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);
      attr[0] = attr[0].replace(/^\s+|\s+$/g, '');
      attr[1] = attr[1].replace(/^\s+|\s+$/g, '');
      attr[1] = attr[1].replace(/^['"](.*)['"]$/g, '$1');
      result[attr[0]] = attr[1];
    }
    return result;
  };
  var ParseStream = function (_Stream) {
    inheritsLoose(ParseStream, _Stream);
    function ParseStream() {
      var _this;
      _this = _Stream.call(this) || this;
      _this.customParsers = [];
      _this.tagMappers = [];
      return _this;
    }
    var _proto = ParseStream.prototype;
    _proto.push = function push(line) {
      var _this2 = this;
      var match;
      var event;
      line = line.trim();
      if (line.length === 0) {
        return;
      }
      if (line[0] !== '#') {
        this.trigger('data', {
          type: 'uri',
          uri: line
        });
        return;
      }
      var newLines = this.tagMappers.reduce(function (acc, mapper) {
        var mappedLine = mapper(line);
        if (mappedLine === line) {
          return acc;
        }
        return acc.concat([mappedLine]);
      }, [line]);
      newLines.forEach(function (newLine) {
        for (var i = 0; i < _this2.customParsers.length; i++) {
          if (_this2.customParsers[i].call(_this2, newLine)) {
            return;
          }
        }
        if (newLine.indexOf('#EXT') !== 0) {
          _this2.trigger('data', {
            type: 'comment',
            text: newLine.slice(1)
          });
          return;
        }
        newLine = newLine.replace('\r', '');
        match = /^#EXTM3U/.exec(newLine);
        if (match) {
          _this2.trigger('data', {
            type: 'tag',
            tagType: 'm3u'
          });
          return;
        }
        match = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'inf'
          };
          if (match[1]) {
            event.duration = parseFloat(match[1]);
          }
          if (match[2]) {
            event.title = match[2];
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'targetduration'
          };
          if (match[1]) {
            event.duration = parseInt(match[1], 10);
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'version'
          };
          if (match[1]) {
            event.version = parseInt(match[1], 10);
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'media-sequence'
          };
          if (match[1]) {
            event.number = parseInt(match[1], 10);
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'discontinuity-sequence'
          };
          if (match[1]) {
            event.number = parseInt(match[1], 10);
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'playlist-type'
          };
          if (match[1]) {
            event.playlistType = match[1];
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(newLine);
        if (match) {
          event = _extends_1(parseByterange(match[1]), {
            type: 'tag',
            tagType: 'byterange'
          });
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'allow-cache'
          };
          if (match[1]) {
            event.allowed = !/NO/.test(match[1]);
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'map'
          };
          if (match[1]) {
            var attributes = parseAttributes$1(match[1]);
            if (attributes.URI) {
              event.uri = attributes.URI;
            }
            if (attributes.BYTERANGE) {
              event.byterange = parseByterange(attributes.BYTERANGE);
            }
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'stream-inf'
          };
          if (match[1]) {
            event.attributes = parseAttributes$1(match[1]);
            if (event.attributes.RESOLUTION) {
              var split = event.attributes.RESOLUTION.split('x');
              var resolution = {};
              if (split[0]) {
                resolution.width = parseInt(split[0], 10);
              }
              if (split[1]) {
                resolution.height = parseInt(split[1], 10);
              }
              event.attributes.RESOLUTION = resolution;
            }
            if (event.attributes.BANDWIDTH) {
              event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
            }
            if (event.attributes['PROGRAM-ID']) {
              event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);
            }
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'media'
          };
          if (match[1]) {
            event.attributes = parseAttributes$1(match[1]);
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-ENDLIST/.exec(newLine);
        if (match) {
          _this2.trigger('data', {
            type: 'tag',
            tagType: 'endlist'
          });
          return;
        }
        match = /^#EXT-X-DISCONTINUITY/.exec(newLine);
        if (match) {
          _this2.trigger('data', {
            type: 'tag',
            tagType: 'discontinuity'
          });
          return;
        }
        match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'program-date-time'
          };
          if (match[1]) {
            event.dateTimeString = match[1];
            event.dateTimeObject = new Date(match[1]);
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'key'
          };
          if (match[1]) {
            event.attributes = parseAttributes$1(match[1]);
            if (event.attributes.IV) {
              if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {
                event.attributes.IV = event.attributes.IV.substring(2);
              }
              event.attributes.IV = event.attributes.IV.match(/.{8}/g);
              event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
              event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
              event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
              event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
              event.attributes.IV = new Uint32Array(event.attributes.IV);
            }
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-START:?(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'start'
          };
          if (match[1]) {
            event.attributes = parseAttributes$1(match[1]);
            event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);
            event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'cue-out-cont'
          };
          if (match[1]) {
            event.data = match[1];
          } else {
            event.data = '';
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'cue-out'
          };
          if (match[1]) {
            event.data = match[1];
          } else {
            event.data = '';
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);
        if (match) {
          event = {
            type: 'tag',
            tagType: 'cue-in'
          };
          if (match[1]) {
            event.data = match[1];
          } else {
            event.data = '';
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: 'tag',
            tagType: 'skip'
          };
          event.attributes = parseAttributes$1(match[1]);
          if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {
            event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);
          }
          if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {
            event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-PART:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: 'tag',
            tagType: 'part'
          };
          event.attributes = parseAttributes$1(match[1]);
          ['DURATION'].forEach(function (key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = parseFloat(event.attributes[key]);
            }
          });
          ['INDEPENDENT', 'GAP'].forEach(function (key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = /YES/.test(event.attributes[key]);
            }
          });
          if (event.attributes.hasOwnProperty('BYTERANGE')) {
            event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);
          }
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: 'tag',
            tagType: 'server-control'
          };
          event.attributes = parseAttributes$1(match[1]);
          ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = parseFloat(event.attributes[key]);
            }
          });
          ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = /YES/.test(event.attributes[key]);
            }
          });
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: 'tag',
            tagType: 'part-inf'
          };
          event.attributes = parseAttributes$1(match[1]);
          ['PART-TARGET'].forEach(function (key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = parseFloat(event.attributes[key]);
            }
          });
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: 'tag',
            tagType: 'preload-hint'
          };
          event.attributes = parseAttributes$1(match[1]);
          ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = parseInt(event.attributes[key], 10);
              var subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';
              event.attributes.byterange = event.attributes.byterange || {};
              event.attributes.byterange[subkey] = event.attributes[key];
              delete event.attributes[key];
            }
          });
          _this2.trigger('data', event);
          return;
        }
        match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: 'tag',
            tagType: 'rendition-report'
          };
          event.attributes = parseAttributes$1(match[1]);
          ['LAST-MSN', 'LAST-PART'].forEach(function (key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = parseInt(event.attributes[key], 10);
            }
          });
          _this2.trigger('data', event);
          return;
        }
        _this2.trigger('data', {
          type: 'tag',
          data: newLine.slice(4)
        });
      });
    }
    ;
    _proto.addParser = function addParser(_ref) {
      var _this3 = this;
      var expression = _ref.expression,
          customType = _ref.customType,
          dataParser = _ref.dataParser,
          segment = _ref.segment;
      if (typeof dataParser !== 'function') {
        dataParser = function dataParser(line) {
          return line;
        };
      }
      this.customParsers.push(function (line) {
        var match = expression.exec(line);
        if (match) {
          _this3.trigger('data', {
            type: 'custom',
            data: dataParser(line),
            customType: customType,
            segment: segment
          });
          return true;
        }
      });
    }
    ;
    _proto.addTagMapper = function addTagMapper(_ref2) {
      var expression = _ref2.expression,
          map = _ref2.map;
      var mapFn = function mapFn(line) {
        if (expression.test(line)) {
          return map(line);
        }
        return line;
      };
      this.tagMappers.push(mapFn);
    };
    return ParseStream;
  }(Stream);
  var camelCase = function camelCase(str) {
    return str.toLowerCase().replace(/-(\w)/g, function (a) {
      return a[1].toUpperCase();
    });
  };
  var camelCaseKeys = function camelCaseKeys(attributes) {
    var result = {};
    Object.keys(attributes).forEach(function (key) {
      result[camelCase(key)] = attributes[key];
    });
    return result;
  };
  var setHoldBack = function setHoldBack(manifest) {
    var serverControl = manifest.serverControl,
        targetDuration = manifest.targetDuration,
        partTargetDuration = manifest.partTargetDuration;
    if (!serverControl) {
      return;
    }
    var tag = '#EXT-X-SERVER-CONTROL';
    var hb = 'holdBack';
    var phb = 'partHoldBack';
    var minTargetDuration = targetDuration && targetDuration * 3;
    var minPartDuration = partTargetDuration && partTargetDuration * 2;
    if (targetDuration && !serverControl.hasOwnProperty(hb)) {
      serverControl[hb] = minTargetDuration;
      this.trigger('info', {
        message: tag + " defaulting HOLD-BACK to targetDuration * 3 (" + minTargetDuration + ")."
      });
    }
    if (minTargetDuration && serverControl[hb] < minTargetDuration) {
      this.trigger('warn', {
        message: tag + " clamping HOLD-BACK (" + serverControl[hb] + ") to targetDuration * 3 (" + minTargetDuration + ")"
      });
      serverControl[hb] = minTargetDuration;
    }
    if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
      serverControl[phb] = partTargetDuration * 3;
      this.trigger('info', {
        message: tag + " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" + serverControl[phb] + ")."
      });
    }
    if (partTargetDuration && serverControl[phb] < minPartDuration) {
      this.trigger('warn', {
        message: tag + " clamping PART-HOLD-BACK (" + serverControl[phb] + ") to partTargetDuration * 2 (" + minPartDuration + ")."
      });
      serverControl[phb] = minPartDuration;
    }
  };
  var Parser = function (_Stream) {
    inheritsLoose(Parser, _Stream);
    function Parser() {
      var _this;
      _this = _Stream.call(this) || this;
      _this.lineStream = new LineStream();
      _this.parseStream = new ParseStream();
      _this.lineStream.pipe(_this.parseStream);
      var self = assertThisInitialized(_this);
      var uris = [];
      var currentUri = {};
      var currentMap;
      var _key;
      var hasParts = false;
      var noop = function noop() {};
      var defaultMediaGroups = {
        'AUDIO': {},
        'VIDEO': {},
        'CLOSED-CAPTIONS': {},
        'SUBTITLES': {}
      };
      var widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed';
      var currentTimeline = 0;
      _this.manifest = {
        allowCache: true,
        discontinuityStarts: [],
        segments: []
      };
      var lastByterangeEnd = 0;
      var lastPartByterangeEnd = 0;
      _this.on('end', function () {
        if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {
          return;
        }
        if (!currentUri.map && currentMap) {
          currentUri.map = currentMap;
        }
        if (!currentUri.key && _key) {
          currentUri.key = _key;
        }
        if (!currentUri.timeline && typeof currentTimeline === 'number') {
          currentUri.timeline = currentTimeline;
        }
        _this.manifest.preloadSegment = currentUri;
      });
      _this.parseStream.on('data', function (entry) {
        var mediaGroup;
        var rendition;
        ({
          tag: function tag() {
            (({
              version: function version() {
                if (entry.version) {
                  this.manifest.version = entry.version;
                }
              },
              'allow-cache': function allowCache() {
                this.manifest.allowCache = entry.allowed;
                if (!('allowed' in entry)) {
                  this.trigger('info', {
                    message: 'defaulting allowCache to YES'
                  });
                  this.manifest.allowCache = true;
                }
              },
              byterange: function byterange() {
                var byterange = {};
                if ('length' in entry) {
                  currentUri.byterange = byterange;
                  byterange.length = entry.length;
                  if (!('offset' in entry)) {
                    entry.offset = lastByterangeEnd;
                  }
                }
                if ('offset' in entry) {
                  currentUri.byterange = byterange;
                  byterange.offset = entry.offset;
                }
                lastByterangeEnd = byterange.offset + byterange.length;
              },
              endlist: function endlist() {
                this.manifest.endList = true;
              },
              inf: function inf() {
                if (!('mediaSequence' in this.manifest)) {
                  this.manifest.mediaSequence = 0;
                  this.trigger('info', {
                    message: 'defaulting media sequence to zero'
                  });
                }
                if (!('discontinuitySequence' in this.manifest)) {
                  this.manifest.discontinuitySequence = 0;
                  this.trigger('info', {
                    message: 'defaulting discontinuity sequence to zero'
                  });
                }
                if (entry.duration > 0) {
                  currentUri.duration = entry.duration;
                }
                if (entry.duration === 0) {
                  currentUri.duration = 0.01;
                  this.trigger('info', {
                    message: 'updating zero segment duration to a small value'
                  });
                }
                this.manifest.segments = uris;
              },
              key: function key() {
                if (!entry.attributes) {
                  this.trigger('warn', {
                    message: 'ignoring key declaration without attribute list'
                  });
                  return;
                }
                if (entry.attributes.METHOD === 'NONE') {
                  _key = null;
                  return;
                }
                if (!entry.attributes.URI) {
                  this.trigger('warn', {
                    message: 'ignoring key declaration without URI'
                  });
                  return;
                }
                if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {
                  this.manifest.contentProtection = this.manifest.contentProtection || {};
                  this.manifest.contentProtection['com.apple.fps.1_0'] = {
                    attributes: entry.attributes
                  };
                  return;
                }
                if (entry.attributes.KEYFORMAT === widevineUuid) {
                  var VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];
                  if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
                    this.trigger('warn', {
                      message: 'invalid key method provided for Widevine'
                    });
                    return;
                  }
                  if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {
                    this.trigger('warn', {
                      message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'
                    });
                  }
                  if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {
                    this.trigger('warn', {
                      message: 'invalid key URI provided for Widevine'
                    });
                    return;
                  }
                  if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {
                    this.trigger('warn', {
                      message: 'invalid key ID provided for Widevine'
                    });
                    return;
                  }
                  this.manifest.contentProtection = this.manifest.contentProtection || {};
                  this.manifest.contentProtection['com.widevine.alpha'] = {
                    attributes: {
                      schemeIdUri: entry.attributes.KEYFORMAT,
                      keyId: entry.attributes.KEYID.substring(2)
                    },
                    pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])
                  };
                  return;
                }
                if (!entry.attributes.METHOD) {
                  this.trigger('warn', {
                    message: 'defaulting key method to AES-128'
                  });
                }
                _key = {
                  method: entry.attributes.METHOD || 'AES-128',
                  uri: entry.attributes.URI
                };
                if (typeof entry.attributes.IV !== 'undefined') {
                  _key.iv = entry.attributes.IV;
                }
              },
              'media-sequence': function mediaSequence() {
                if (!isFinite(entry.number)) {
                  this.trigger('warn', {
                    message: 'ignoring invalid media sequence: ' + entry.number
                  });
                  return;
                }
                this.manifest.mediaSequence = entry.number;
              },
              'discontinuity-sequence': function discontinuitySequence() {
                if (!isFinite(entry.number)) {
                  this.trigger('warn', {
                    message: 'ignoring invalid discontinuity sequence: ' + entry.number
                  });
                  return;
                }
                this.manifest.discontinuitySequence = entry.number;
                currentTimeline = entry.number;
              },
              'playlist-type': function playlistType() {
                if (!/VOD|EVENT/.test(entry.playlistType)) {
                  this.trigger('warn', {
                    message: 'ignoring unknown playlist type: ' + entry.playlist
                  });
                  return;
                }
                this.manifest.playlistType = entry.playlistType;
              },
              map: function map() {
                currentMap = {};
                if (entry.uri) {
                  currentMap.uri = entry.uri;
                }
                if (entry.byterange) {
                  currentMap.byterange = entry.byterange;
                }
                if (_key) {
                  currentMap.key = _key;
                }
              },
              'stream-inf': function streamInf() {
                this.manifest.playlists = uris;
                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
                if (!entry.attributes) {
                  this.trigger('warn', {
                    message: 'ignoring empty stream-inf attributes'
                  });
                  return;
                }
                if (!currentUri.attributes) {
                  currentUri.attributes = {};
                }
                _extends_1(currentUri.attributes, entry.attributes);
              },
              media: function media() {
                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
                if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {
                  this.trigger('warn', {
                    message: 'ignoring incomplete or missing media group'
                  });
                  return;
                }
                var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
                mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};
                mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']];
                rendition = {
                  "default": /yes/i.test(entry.attributes.DEFAULT)
                };
                if (rendition["default"]) {
                  rendition.autoselect = true;
                } else {
                  rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
                }
                if (entry.attributes.LANGUAGE) {
                  rendition.language = entry.attributes.LANGUAGE;
                }
                if (entry.attributes.URI) {
                  rendition.uri = entry.attributes.URI;
                }
                if (entry.attributes['INSTREAM-ID']) {
                  rendition.instreamId = entry.attributes['INSTREAM-ID'];
                }
                if (entry.attributes.CHARACTERISTICS) {
                  rendition.characteristics = entry.attributes.CHARACTERISTICS;
                }
                if (entry.attributes.FORCED) {
                  rendition.forced = /yes/i.test(entry.attributes.FORCED);
                }
                mediaGroup[entry.attributes.NAME] = rendition;
              },
              discontinuity: function discontinuity() {
                currentTimeline += 1;
                currentUri.discontinuity = true;
                this.manifest.discontinuityStarts.push(uris.length);
              },
              'program-date-time': function programDateTime() {
                if (typeof this.manifest.dateTimeString === 'undefined') {
                  this.manifest.dateTimeString = entry.dateTimeString;
                  this.manifest.dateTimeObject = entry.dateTimeObject;
                }
                currentUri.dateTimeString = entry.dateTimeString;
                currentUri.dateTimeObject = entry.dateTimeObject;
              },
              targetduration: function targetduration() {
                if (!isFinite(entry.duration) || entry.duration < 0) {
                  this.trigger('warn', {
                    message: 'ignoring invalid target duration: ' + entry.duration
                  });
                  return;
                }
                this.manifest.targetDuration = entry.duration;
                setHoldBack.call(this, this.manifest);
              },
              start: function start() {
                if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {
                  this.trigger('warn', {
                    message: 'ignoring start declaration without appropriate attribute list'
                  });
                  return;
                }
                this.manifest.start = {
                  timeOffset: entry.attributes['TIME-OFFSET'],
                  precise: entry.attributes.PRECISE
                };
              },
              'cue-out': function cueOut() {
                currentUri.cueOut = entry.data;
              },
              'cue-out-cont': function cueOutCont() {
                currentUri.cueOutCont = entry.data;
              },
              'cue-in': function cueIn() {
                currentUri.cueIn = entry.data;
              },
              'skip': function skip() {
                this.manifest.skip = camelCaseKeys(entry.attributes);
                this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);
              },
              'part': function part() {
                var _this2 = this;
                hasParts = true;
                var segmentIndex = this.manifest.segments.length;
                var part = camelCaseKeys(entry.attributes);
                currentUri.parts = currentUri.parts || [];
                currentUri.parts.push(part);
                if (part.byterange) {
                  if (!part.byterange.hasOwnProperty('offset')) {
                    part.byterange.offset = lastPartByterangeEnd;
                  }
                  lastPartByterangeEnd = part.byterange.offset + part.byterange.length;
                }
                var partIndex = currentUri.parts.length - 1;
                this.warnOnMissingAttributes_("#EXT-X-PART #" + partIndex + " for segment #" + segmentIndex, entry.attributes, ['URI', 'DURATION']);
                if (this.manifest.renditionReports) {
                  this.manifest.renditionReports.forEach(function (r, i) {
                    if (!r.hasOwnProperty('lastPart')) {
                      _this2.trigger('warn', {
                        message: "#EXT-X-RENDITION-REPORT #" + i + " lacks required attribute(s): LAST-PART"
                      });
                    }
                  });
                }
              },
              'server-control': function serverControl() {
                var attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);
                if (!attrs.hasOwnProperty('canBlockReload')) {
                  attrs.canBlockReload = false;
                  this.trigger('info', {
                    message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'
                  });
                }
                setHoldBack.call(this, this.manifest);
                if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {
                  this.trigger('warn', {
                    message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'
                  });
                }
              },
              'preload-hint': function preloadHint() {
                var segmentIndex = this.manifest.segments.length;
                var hint = camelCaseKeys(entry.attributes);
                var isPart = hint.type && hint.type === 'PART';
                currentUri.preloadHints = currentUri.preloadHints || [];
                currentUri.preloadHints.push(hint);
                if (hint.byterange) {
                  if (!hint.byterange.hasOwnProperty('offset')) {
                    hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;
                    if (isPart) {
                      lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
                    }
                  }
                }
                var index = currentUri.preloadHints.length - 1;
                this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex, entry.attributes, ['TYPE', 'URI']);
                if (!hint.type) {
                  return;
                }
                for (var i = 0; i < currentUri.preloadHints.length - 1; i++) {
                  var otherHint = currentUri.preloadHints[i];
                  if (!otherHint.type) {
                    continue;
                  }
                  if (otherHint.type === hint.type) {
                    this.trigger('warn', {
                      message: "#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex + " has the same TYPE " + hint.type + " as preload hint #" + i
                    });
                  }
                }
              },
              'rendition-report': function renditionReport() {
                var report = camelCaseKeys(entry.attributes);
                this.manifest.renditionReports = this.manifest.renditionReports || [];
                this.manifest.renditionReports.push(report);
                var index = this.manifest.renditionReports.length - 1;
                var required = ['LAST-MSN', 'URI'];
                if (hasParts) {
                  required.push('LAST-PART');
                }
                this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + index, entry.attributes, required);
              },
              'part-inf': function partInf() {
                this.manifest.partInf = camelCaseKeys(entry.attributes);
                this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);
                if (this.manifest.partInf.partTarget) {
                  this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
                }
                setHoldBack.call(this, this.manifest);
              }
            })[entry.tagType] || noop).call(self);
          },
          uri: function uri() {
            currentUri.uri = entry.uri;
            uris.push(currentUri);
            if (this.manifest.targetDuration && !('duration' in currentUri)) {
              this.trigger('warn', {
                message: 'defaulting segment duration to the target duration'
              });
              currentUri.duration = this.manifest.targetDuration;
            }
            if (_key) {
              currentUri.key = _key;
            }
            currentUri.timeline = currentTimeline;
            if (currentMap) {
              currentUri.map = currentMap;
            }
            lastPartByterangeEnd = 0;
            currentUri = {};
          },
          comment: function comment() {
          },
          custom: function custom() {
            if (entry.segment) {
              currentUri.custom = currentUri.custom || {};
              currentUri.custom[entry.customType] = entry.data;
            } else {
              this.manifest.custom = this.manifest.custom || {};
              this.manifest.custom[entry.customType] = entry.data;
            }
          }
        })[entry.type].call(self);
      });
      return _this;
    }
    var _proto = Parser.prototype;
    _proto.warnOnMissingAttributes_ = function warnOnMissingAttributes_(identifier, attributes, required) {
      var missing = [];
      required.forEach(function (key) {
        if (!attributes.hasOwnProperty(key)) {
          missing.push(key);
        }
      });
      if (missing.length) {
        this.trigger('warn', {
          message: identifier + " lacks required attribute(s): " + missing.join(', ')
        });
      }
    }
    ;
    _proto.push = function push(chunk) {
      this.lineStream.push(chunk);
    }
    ;
    _proto.end = function end() {
      this.lineStream.push('\n');
      this.trigger('end');
    }
    ;
    _proto.addParser = function addParser(options) {
      this.parseStream.addParser(options);
    }
    ;
    _proto.addTagMapper = function addTagMapper(options) {
      this.parseStream.addTagMapper(options);
    };
    return Parser;
  }(Stream);
  var regexs = {
    mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
    webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
    ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
    video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
    audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
    text: /^(stpp.ttml.im1t)/,
    muxerVideo: /^(avc0?1)/,
    muxerAudio: /^(mp4a)/,
    muxerText: /a^/
  };
  var mediaTypes = ['video', 'audio', 'text'];
  var upperMediaTypes = ['Video', 'Audio', 'Text'];
  var translateLegacyCodec = function translateLegacyCodec(codec) {
    if (!codec) {
      return codec;
    }
    return codec.replace(/avc1\.(\d+)\.(\d+)/i, function (orig, profile, avcLevel) {
      var profileHex = ('00' + Number(profile).toString(16)).slice(-2);
      var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);
      return 'avc1.' + profileHex + '00' + avcLevelHex;
    });
  };
  var parseCodecs = function parseCodecs(codecString) {
    if (codecString === void 0) {
      codecString = '';
    }
    var codecs = codecString.split(',');
    var result = [];
    codecs.forEach(function (codec) {
      codec = codec.trim();
      var codecType;
      mediaTypes.forEach(function (name) {
        var match = regexs[name].exec(codec.toLowerCase());
        if (!match || match.length <= 1) {
          return;
        }
        codecType = name;
        var type = codec.substring(0, match[1].length);
        var details = codec.replace(type, '');
        result.push({
          type: type,
          details: details,
          mediaType: name
        });
      });
      if (!codecType) {
        result.push({
          type: codec,
          details: '',
          mediaType: 'unknown'
        });
      }
    });
    return result;
  };
  var codecsFromDefault = function codecsFromDefault(master, audioGroupId) {
    if (!master.mediaGroups.AUDIO || !audioGroupId) {
      return null;
    }
    var audioGroup = master.mediaGroups.AUDIO[audioGroupId];
    if (!audioGroup) {
      return null;
    }
    for (var name in audioGroup) {
      var audioType = audioGroup[name];
      if (audioType["default"] && audioType.playlists) {
        return parseCodecs(audioType.playlists[0].attributes.CODECS);
      }
    }
    return null;
  };
  var isAudioCodec = function isAudioCodec(codec) {
    if (codec === void 0) {
      codec = '';
    }
    return regexs.audio.test(codec.trim().toLowerCase());
  };
  var isTextCodec = function isTextCodec(codec) {
    if (codec === void 0) {
      codec = '';
    }
    return regexs.text.test(codec.trim().toLowerCase());
  };
  var getMimeForCodec = function getMimeForCodec(codecString) {
    if (!codecString || typeof codecString !== 'string') {
      return;
    }
    var codecs = codecString.toLowerCase().split(',').map(function (c) {
      return translateLegacyCodec(c.trim());
    });
    var type = 'video';
    if (codecs.length === 1 && isAudioCodec(codecs[0])) {
      type = 'audio';
    } else if (codecs.length === 1 && isTextCodec(codecs[0])) {
      type = 'application';
    }
    var container = 'mp4';
    if (codecs.every(function (c) {
      return regexs.mp4.test(c);
    })) {
      container = 'mp4';
    } else if (codecs.every(function (c) {
      return regexs.webm.test(c);
    })) {
      container = 'webm';
    } else if (codecs.every(function (c) {
      return regexs.ogg.test(c);
    })) {
      container = 'ogg';
    }
    return type + "/" + container + ";codecs=\"" + codecString + "\"";
  };
  var browserSupportsCodec = function browserSupportsCodec(codecString) {
    if (codecString === void 0) {
      codecString = '';
    }
    return window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;
  };
  var muxerSupportsCodec = function muxerSupportsCodec(codecString) {
    if (codecString === void 0) {
      codecString = '';
    }
    return codecString.toLowerCase().split(',').every(function (codec) {
      codec = codec.trim();
      for (var i = 0; i < upperMediaTypes.length; i++) {
        var type = upperMediaTypes[i];
        if (regexs["muxer" + type].test(codec)) {
          return true;
        }
      }
      return false;
    });
  };
  var DEFAULT_AUDIO_CODEC = 'mp4a.40.2';
  var DEFAULT_VIDEO_CODEC = 'avc1.4d400d';
  var MPEGURL_REGEX = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i;
  var DASH_REGEX = /^application\/dash\+xml/i;
  var simpleTypeFromSourceType = function simpleTypeFromSourceType(type) {
    if (MPEGURL_REGEX.test(type)) {
      return 'hls';
    }
    if (DASH_REGEX.test(type)) {
      return 'dash';
    }
    if (type === 'application/vnd.videojs.vhs+json') {
      return 'vhs-json';
    }
    return null;
  };
  var forEachMediaGroup$1 = function forEachMediaGroup(master, groups, callback) {
    groups.forEach(function (mediaType) {
      for (var groupKey in master.mediaGroups[mediaType]) {
        for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
          var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
          callback(mediaProperties, mediaType, groupKey, labelKey);
        }
      }
    });
  };
  function freeze(object, oc) {
    if (oc === undefined) {
      oc = Object;
    }
    return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object;
  }
  var MIME_TYPE = freeze({
    HTML: 'text/html',
    isHTML: function isHTML(value) {
      return value === MIME_TYPE.HTML;
    },
    XML_APPLICATION: 'application/xml',
    XML_TEXT: 'text/xml',
    XML_XHTML_APPLICATION: 'application/xhtml+xml',
    XML_SVG_IMAGE: 'image/svg+xml'
  });
  var NAMESPACE$3 = freeze({
    HTML: 'http://www.w3.org/1999/xhtml',
    isHTML: function isHTML(uri) {
      return uri === NAMESPACE$3.HTML;
    },
    SVG: 'http://www.w3.org/2000/svg',
    XML: 'http://www.w3.org/XML/1998/namespace',
    XMLNS: 'http://www.w3.org/2000/xmlns/'
  });
  var freeze_1 = freeze;
  var MIME_TYPE_1 = MIME_TYPE;
  var NAMESPACE_1 = NAMESPACE$3;
  var conventions = {
    freeze: freeze_1,
    MIME_TYPE: MIME_TYPE_1,
    NAMESPACE: NAMESPACE_1
  };
  var NAMESPACE$2 = conventions.NAMESPACE;
  function notEmptyString(input) {
    return input !== '';
  }
  function splitOnASCIIWhitespace(input) {
    return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
  }
  function orderedSetReducer(current, element) {
    if (!current.hasOwnProperty(element)) {
      current[element] = true;
    }
    return current;
  }
  function toOrderedSet(input) {
    if (!input) return [];
    var list = splitOnASCIIWhitespace(input);
    return Object.keys(list.reduce(orderedSetReducer, {}));
  }
  function arrayIncludes(list) {
    return function (element) {
      return list && list.indexOf(element) !== -1;
    };
  }
  function copy(src, dest) {
    for (var p in src) {
      dest[p] = src[p];
    }
  }
  function _extends(Class, Super) {
    var pt = Class.prototype;
    if (!(pt instanceof Super)) {
      var t = function t() {};
      t.prototype = Super.prototype;
      t = new t();
      copy(pt, t);
      Class.prototype = pt = t;
    }
    if (pt.constructor != Class) {
      if (typeof Class != 'function') {
        console.error("unknown Class:" + Class);
      }
      pt.constructor = Class;
    }
  }
  var NodeType = {};
  var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
  var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
  var TEXT_NODE = NodeType.TEXT_NODE = 3;
  var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
  var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
  var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
  var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
  var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
  var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
  var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
  var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
  var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
  var ExceptionCode = {};
  var ExceptionMessage = {};
  ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
  ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
  var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
  ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
  ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
  ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
  ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
  var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
  ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
  var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
  ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
  ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
  ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
  ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
  ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
  function DOMException(code, message) {
    if (message instanceof Error) {
      var error = message;
    } else {
      error = this;
      Error.call(this, ExceptionMessage[code]);
      this.message = ExceptionMessage[code];
      if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
    }
    error.code = code;
    if (message) this.message = this.message + ": " + message;
    return error;
  }
  DOMException.prototype = Error.prototype;
  copy(ExceptionCode, DOMException);
  function NodeList() {}
  NodeList.prototype = {
    length: 0,
    item: function item(index) {
      return this[index] || null;
    },
    toString: function toString(isHTML, nodeFilter) {
      for (var buf = [], i = 0; i < this.length; i++) {
        serializeToString(this[i], buf, isHTML, nodeFilter);
      }
      return buf.join('');
    }
  };
  function LiveNodeList(node, refresh) {
    this._node = node;
    this._refresh = refresh;
    _updateLiveList(this);
  }
  function _updateLiveList(list) {
    var inc = list._node._inc || list._node.ownerDocument._inc;
    if (list._inc != inc) {
      var ls = list._refresh(list._node);
      __set__(list, 'length', ls.length);
      copy(ls, list);
      list._inc = inc;
    }
  }
  LiveNodeList.prototype.item = function (i) {
    _updateLiveList(this);
    return this[i];
  };
  _extends(LiveNodeList, NodeList);
  function NamedNodeMap() {}
  function _findNodeIndex(list, node) {
    var i = list.length;
    while (i--) {
      if (list[i] === node) {
        return i;
      }
    }
  }
  function _addNamedNode(el, list, newAttr, oldAttr) {
    if (oldAttr) {
      list[_findNodeIndex(list, oldAttr)] = newAttr;
    } else {
      list[list.length++] = newAttr;
    }
    if (el) {
      newAttr.ownerElement = el;
      var doc = el.ownerDocument;
      if (doc) {
        oldAttr && _onRemoveAttribute(doc, el, oldAttr);
        _onAddAttribute(doc, el, newAttr);
      }
    }
  }
  function _removeNamedNode(el, list, attr) {
    var i = _findNodeIndex(list, attr);
    if (i >= 0) {
      var lastIndex = list.length - 1;
      while (i < lastIndex) {
        list[i] = list[++i];
      }
      list.length = lastIndex;
      if (el) {
        var doc = el.ownerDocument;
        if (doc) {
          _onRemoveAttribute(doc, el, attr);
          attr.ownerElement = null;
        }
      }
    } else {
      throw DOMException(NOT_FOUND_ERR, new Error(el.tagName + '@' + attr));
    }
  }
  NamedNodeMap.prototype = {
    length: 0,
    item: NodeList.prototype.item,
    getNamedItem: function getNamedItem(key) {
      var i = this.length;
      while (i--) {
        var attr = this[i];
        if (attr.nodeName == key) {
          return attr;
        }
      }
    },
    setNamedItem: function setNamedItem(attr) {
      var el = attr.ownerElement;
      if (el && el != this._ownerElement) {
        throw new DOMException(INUSE_ATTRIBUTE_ERR);
      }
      var oldAttr = this.getNamedItem(attr.nodeName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    setNamedItemNS: function setNamedItemNS(attr) {
      var el = attr.ownerElement,
          oldAttr;
      if (el && el != this._ownerElement) {
        throw new DOMException(INUSE_ATTRIBUTE_ERR);
      }
      oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    removeNamedItem: function removeNamedItem(key) {
      var attr = this.getNamedItem(key);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    removeNamedItemNS: function removeNamedItemNS(namespaceURI, localName) {
      var attr = this.getNamedItemNS(namespaceURI, localName);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    getNamedItemNS: function getNamedItemNS(namespaceURI, localName) {
      var i = this.length;
      while (i--) {
        var node = this[i];
        if (node.localName == localName && node.namespaceURI == namespaceURI) {
          return node;
        }
      }
      return null;
    }
  };
  function DOMImplementation$1() {}
  DOMImplementation$1.prototype = {
    hasFeature: function hasFeature(feature, version) {
      return true;
    },
    createDocument: function createDocument(namespaceURI, qualifiedName, doctype) {
      var doc = new Document();
      doc.implementation = this;
      doc.childNodes = new NodeList();
      doc.doctype = doctype || null;
      if (doctype) {
        doc.appendChild(doctype);
      }
      if (qualifiedName) {
        var root = doc.createElementNS(namespaceURI, qualifiedName);
        doc.appendChild(root);
      }
      return doc;
    },
    createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {
      var node = new DocumentType();
      node.name = qualifiedName;
      node.nodeName = qualifiedName;
      node.publicId = publicId || '';
      node.systemId = systemId || '';
      return node;
    }
  };
  function Node() {}
  Node.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    insertBefore: function insertBefore(newChild, refChild) {
      return _insertBefore(this, newChild, refChild);
    },
    replaceChild: function replaceChild(newChild, oldChild) {
      this.insertBefore(newChild, oldChild);
      if (oldChild) {
        this.removeChild(oldChild);
      }
    },
    removeChild: function removeChild(oldChild) {
      return _removeChild(this, oldChild);
    },
    appendChild: function appendChild(newChild) {
      return this.insertBefore(newChild, null);
    },
    hasChildNodes: function hasChildNodes() {
      return this.firstChild != null;
    },
    cloneNode: function cloneNode(deep) {
      return _cloneNode(this.ownerDocument || this, this, deep);
    },
    normalize: function normalize() {
      var child = this.firstChild;
      while (child) {
        var next = child.nextSibling;
        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
          this.removeChild(next);
          child.appendData(next.data);
        } else {
          child.normalize();
          child = next;
        }
      }
    },
    isSupported: function isSupported(feature, version) {
      return this.ownerDocument.implementation.hasFeature(feature, version);
    },
    hasAttributes: function hasAttributes() {
      return this.attributes.length > 0;
    },
    lookupPrefix: function lookupPrefix(namespaceURI) {
      var el = this;
      while (el) {
        var map = el._nsMap;
        if (map) {
          for (var n in map) {
            if (map[n] == namespaceURI) {
              return n;
            }
          }
        }
        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
      }
      return null;
    },
    lookupNamespaceURI: function lookupNamespaceURI(prefix) {
      var el = this;
      while (el) {
        var map = el._nsMap;
        if (map) {
          if (prefix in map) {
            return map[prefix];
          }
        }
        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
      }
      return null;
    },
    isDefaultNamespace: function isDefaultNamespace(namespaceURI) {
      var prefix = this.lookupPrefix(namespaceURI);
      return prefix == null;
    }
  };
  function _xmlEncoder(c) {
    return c == '<' && '&lt;' || c == '>' && '&gt;' || c == '&' && '&amp;' || c == '"' && '&quot;' || '&#' + c.charCodeAt() + ';';
  }
  copy(NodeType, Node);
  copy(NodeType, Node.prototype);
  function _visitNode(node, callback) {
    if (callback(node)) {
      return true;
    }
    if (node = node.firstChild) {
      do {
        if (_visitNode(node, callback)) {
          return true;
        }
      } while (node = node.nextSibling);
    }
  }
  function Document() {}
  function _onAddAttribute(doc, el, newAttr) {
    doc && doc._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE$2.XMLNS) {
      el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;
    }
  }
  function _onRemoveAttribute(doc, el, newAttr, remove) {
    doc && doc._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE$2.XMLNS) {
      delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];
    }
  }
  function _onUpdateChild(doc, el, newChild) {
    if (doc && doc._inc) {
      doc._inc++;
      var cs = el.childNodes;
      if (newChild) {
        cs[cs.length++] = newChild;
      } else {
        var child = el.firstChild;
        var i = 0;
        while (child) {
          cs[i++] = child;
          child = child.nextSibling;
        }
        cs.length = i;
      }
    }
  }
  function _removeChild(parentNode, child) {
    var previous = child.previousSibling;
    var next = child.nextSibling;
    if (previous) {
      previous.nextSibling = next;
    } else {
      parentNode.firstChild = next;
    }
    if (next) {
      next.previousSibling = previous;
    } else {
      parentNode.lastChild = previous;
    }
    _onUpdateChild(parentNode.ownerDocument, parentNode);
    return child;
  }
  function _insertBefore(parentNode, newChild, nextChild) {
    var cp = newChild.parentNode;
    if (cp) {
      cp.removeChild(newChild);
    }
    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
      var newFirst = newChild.firstChild;
      if (newFirst == null) {
        return newChild;
      }
      var newLast = newChild.lastChild;
    } else {
      newFirst = newLast = newChild;
    }
    var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;
    newFirst.previousSibling = pre;
    newLast.nextSibling = nextChild;
    if (pre) {
      pre.nextSibling = newFirst;
    } else {
      parentNode.firstChild = newFirst;
    }
    if (nextChild == null) {
      parentNode.lastChild = newLast;
    } else {
      nextChild.previousSibling = newLast;
    }
    do {
      newFirst.parentNode = parentNode;
    } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
    _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);
    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
      newChild.firstChild = newChild.lastChild = null;
    }
    return newChild;
  }
  function _appendSingleChild(parentNode, newChild) {
    var cp = newChild.parentNode;
    if (cp) {
      var pre = parentNode.lastChild;
      cp.removeChild(newChild);
      var pre = parentNode.lastChild;
    }
    var pre = parentNode.lastChild;
    newChild.parentNode = parentNode;
    newChild.previousSibling = pre;
    newChild.nextSibling = null;
    if (pre) {
      pre.nextSibling = newChild;
    } else {
      parentNode.firstChild = newChild;
    }
    parentNode.lastChild = newChild;
    _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
    return newChild;
  }
  Document.prototype = {
    nodeName: '#document',
    nodeType: DOCUMENT_NODE,
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function insertBefore(newChild, refChild) {
      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
        var child = newChild.firstChild;
        while (child) {
          var next = child.nextSibling;
          this.insertBefore(child, refChild);
          child = next;
        }
        return newChild;
      }
      if (this.documentElement == null && newChild.nodeType == ELEMENT_NODE) {
        this.documentElement = newChild;
      }
      return _insertBefore(this, newChild, refChild), newChild.ownerDocument = this, newChild;
    },
    removeChild: function removeChild(oldChild) {
      if (this.documentElement == oldChild) {
        this.documentElement = null;
      }
      return _removeChild(this, oldChild);
    },
    importNode: function importNode(importedNode, deep) {
      return _importNode(this, importedNode, deep);
    },
    getElementById: function getElementById(id) {
      var rtv = null;
      _visitNode(this.documentElement, function (node) {
        if (node.nodeType == ELEMENT_NODE) {
          if (node.getAttribute('id') == id) {
            rtv = node;
            return true;
          }
        }
      });
      return rtv;
    },
    getElementsByClassName: function getElementsByClassName(classNames) {
      var classNamesSet = toOrderedSet(classNames);
      return new LiveNodeList(this, function (base) {
        var ls = [];
        if (classNamesSet.length > 0) {
          _visitNode(base.documentElement, function (node) {
            if (node !== base && node.nodeType === ELEMENT_NODE) {
              var nodeClassNames = node.getAttribute('class');
              if (nodeClassNames) {
                var matches = classNames === nodeClassNames;
                if (!matches) {
                  var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                  matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                }
                if (matches) {
                  ls.push(node);
                }
              }
            }
          });
        }
        return ls;
      });
    },
    createElement: function createElement(tagName) {
      var node = new Element();
      node.ownerDocument = this;
      node.nodeName = tagName;
      node.tagName = tagName;
      node.localName = tagName;
      node.childNodes = new NodeList();
      var attrs = node.attributes = new NamedNodeMap();
      attrs._ownerElement = node;
      return node;
    },
    createDocumentFragment: function createDocumentFragment() {
      var node = new DocumentFragment();
      node.ownerDocument = this;
      node.childNodes = new NodeList();
      return node;
    },
    createTextNode: function createTextNode(data) {
      var node = new Text();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createComment: function createComment(data) {
      var node = new Comment();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createCDATASection: function createCDATASection(data) {
      var node = new CDATASection();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createProcessingInstruction: function createProcessingInstruction(target, data) {
      var node = new ProcessingInstruction();
      node.ownerDocument = this;
      node.tagName = node.target = target;
      node.nodeValue = node.data = data;
      return node;
    },
    createAttribute: function createAttribute(name) {
      var node = new Attr();
      node.ownerDocument = this;
      node.name = name;
      node.nodeName = name;
      node.localName = name;
      node.specified = true;
      return node;
    },
    createEntityReference: function createEntityReference(name) {
      var node = new EntityReference();
      node.ownerDocument = this;
      node.nodeName = name;
      return node;
    },
    createElementNS: function createElementNS(namespaceURI, qualifiedName) {
      var node = new Element();
      var pl = qualifiedName.split(':');
      var attrs = node.attributes = new NamedNodeMap();
      node.childNodes = new NodeList();
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.tagName = qualifiedName;
      node.namespaceURI = namespaceURI;
      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }
      attrs._ownerElement = node;
      return node;
    },
    createAttributeNS: function createAttributeNS(namespaceURI, qualifiedName) {
      var node = new Attr();
      var pl = qualifiedName.split(':');
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.name = qualifiedName;
      node.namespaceURI = namespaceURI;
      node.specified = true;
      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }
      return node;
    }
  };
  _extends(Document, Node);
  function Element() {
    this._nsMap = {};
  }
  Element.prototype = {
    nodeType: ELEMENT_NODE,
    hasAttribute: function hasAttribute(name) {
      return this.getAttributeNode(name) != null;
    },
    getAttribute: function getAttribute(name) {
      var attr = this.getAttributeNode(name);
      return attr && attr.value || '';
    },
    getAttributeNode: function getAttributeNode(name) {
      return this.attributes.getNamedItem(name);
    },
    setAttribute: function setAttribute(name, value) {
      var attr = this.ownerDocument.createAttribute(name);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    removeAttribute: function removeAttribute(name) {
      var attr = this.getAttributeNode(name);
      attr && this.removeAttributeNode(attr);
    },
    appendChild: function appendChild(newChild) {
      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
        return this.insertBefore(newChild, null);
      } else {
        return _appendSingleChild(this, newChild);
      }
    },
    setAttributeNode: function setAttributeNode(newAttr) {
      return this.attributes.setNamedItem(newAttr);
    },
    setAttributeNodeNS: function setAttributeNodeNS(newAttr) {
      return this.attributes.setNamedItemNS(newAttr);
    },
    removeAttributeNode: function removeAttributeNode(oldAttr) {
      return this.attributes.removeNamedItem(oldAttr.nodeName);
    },
    removeAttributeNS: function removeAttributeNS(namespaceURI, localName) {
      var old = this.getAttributeNodeNS(namespaceURI, localName);
      old && this.removeAttributeNode(old);
    },
    hasAttributeNS: function hasAttributeNS(namespaceURI, localName) {
      return this.getAttributeNodeNS(namespaceURI, localName) != null;
    },
    getAttributeNS: function getAttributeNS(namespaceURI, localName) {
      var attr = this.getAttributeNodeNS(namespaceURI, localName);
      return attr && attr.value || '';
    },
    setAttributeNS: function setAttributeNS(namespaceURI, qualifiedName, value) {
      var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    getAttributeNodeNS: function getAttributeNodeNS(namespaceURI, localName) {
      return this.attributes.getNamedItemNS(namespaceURI, localName);
    },
    getElementsByTagName: function getElementsByTagName(tagName) {
      return new LiveNodeList(this, function (base) {
        var ls = [];
        _visitNode(base, function (node) {
          if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {
            ls.push(node);
          }
        });
        return ls;
      });
    },
    getElementsByTagNameNS: function getElementsByTagNameNS(namespaceURI, localName) {
      return new LiveNodeList(this, function (base) {
        var ls = [];
        _visitNode(base, function (node) {
          if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {
            ls.push(node);
          }
        });
        return ls;
      });
    }
  };
  Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
  Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
  _extends(Element, Node);
  function Attr() {}
  Attr.prototype.nodeType = ATTRIBUTE_NODE;
  _extends(Attr, Node);
  function CharacterData() {}
  CharacterData.prototype = {
    data: '',
    substringData: function substringData(offset, count) {
      return this.data.substring(offset, offset + count);
    },
    appendData: function appendData(text) {
      text = this.data + text;
      this.nodeValue = this.data = text;
      this.length = text.length;
    },
    insertData: function insertData(offset, text) {
      this.replaceData(offset, 0, text);
    },
    appendChild: function appendChild(newChild) {
      throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
    },
    deleteData: function deleteData(offset, count) {
      this.replaceData(offset, count, "");
    },
    replaceData: function replaceData(offset, count, text) {
      var start = this.data.substring(0, offset);
      var end = this.data.substring(offset + count);
      text = start + text + end;
      this.nodeValue = this.data = text;
      this.length = text.length;
    }
  };
  _extends(CharacterData, Node);
  function Text() {}
  Text.prototype = {
    nodeName: "#text",
    nodeType: TEXT_NODE,
    splitText: function splitText(offset) {
      var text = this.data;
      var newText = text.substring(offset);
      text = text.substring(0, offset);
      this.data = this.nodeValue = text;
      this.length = text.length;
      var newNode = this.ownerDocument.createTextNode(newText);
      if (this.parentNode) {
        this.parentNode.insertBefore(newNode, this.nextSibling);
      }
      return newNode;
    }
  };
  _extends(Text, CharacterData);
  function Comment() {}
  Comment.prototype = {
    nodeName: "#comment",
    nodeType: COMMENT_NODE
  };
  _extends(Comment, CharacterData);
  function CDATASection() {}
  CDATASection.prototype = {
    nodeName: "#cdata-section",
    nodeType: CDATA_SECTION_NODE
  };
  _extends(CDATASection, CharacterData);
  function DocumentType() {}
  DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
  _extends(DocumentType, Node);
  function Notation() {}
  Notation.prototype.nodeType = NOTATION_NODE;
  _extends(Notation, Node);
  function Entity() {}
  Entity.prototype.nodeType = ENTITY_NODE;
  _extends(Entity, Node);
  function EntityReference() {}
  EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
  _extends(EntityReference, Node);
  function DocumentFragment() {}
  DocumentFragment.prototype.nodeName = "#document-fragment";
  DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
  _extends(DocumentFragment, Node);
  function ProcessingInstruction() {}
  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
  _extends(ProcessingInstruction, Node);
  function XMLSerializer$1() {}
  XMLSerializer$1.prototype.serializeToString = function (node, isHtml, nodeFilter) {
    return nodeSerializeToString.call(node, isHtml, nodeFilter);
  };
  Node.prototype.toString = nodeSerializeToString;
  function nodeSerializeToString(isHtml, nodeFilter) {
    var buf = [];
    var refNode = this.nodeType == 9 && this.documentElement || this;
    var prefix = refNode.prefix;
    var uri = refNode.namespaceURI;
    if (uri && prefix == null) {
      var prefix = refNode.lookupPrefix(uri);
      if (prefix == null) {
        var visibleNamespaces = [{
          namespace: uri,
          prefix: null
        }
        ];
      }
    }
    serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
    return buf.join('');
  }
  function needNamespaceDefine(node, isHTML, visibleNamespaces) {
    var prefix = node.prefix || '';
    var uri = node.namespaceURI;
    if (!uri) {
      return false;
    }
    if (prefix === "xml" && uri === NAMESPACE$2.XML || uri === NAMESPACE$2.XMLNS) {
      return false;
    }
    var i = visibleNamespaces.length;
    while (i--) {
      var ns = visibleNamespaces[i];
      if (ns.prefix === prefix) {
        return ns.namespace !== uri;
      }
    }
    return true;
  }
  function addSerializedAttribute(buf, qualifiedName, value) {
    buf.push(' ', qualifiedName, '="', value.replace(/[<&"]/g, _xmlEncoder), '"');
  }
  function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
    if (!visibleNamespaces) {
      visibleNamespaces = [];
    }
    if (nodeFilter) {
      node = nodeFilter(node);
      if (node) {
        if (typeof node == 'string') {
          buf.push(node);
          return;
        }
      } else {
        return;
      }
    }
    switch (node.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes;
        var len = attrs.length;
        var child = node.firstChild;
        var nodeName = node.tagName;
        isHTML = NAMESPACE$2.isHTML(node.namespaceURI) || isHTML;
        var prefixedNodeName = nodeName;
        if (!isHTML && !node.prefix && node.namespaceURI) {
          var defaultNS;
          for (var ai = 0; ai < attrs.length; ai++) {
            if (attrs.item(ai).name === 'xmlns') {
              defaultNS = attrs.item(ai).value;
              break;
            }
          }
          if (!defaultNS) {
            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
              var namespace = visibleNamespaces[nsi];
              if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {
                defaultNS = namespace.namespace;
                break;
              }
            }
          }
          if (defaultNS !== node.namespaceURI) {
            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
              var namespace = visibleNamespaces[nsi];
              if (namespace.namespace === node.namespaceURI) {
                if (namespace.prefix) {
                  prefixedNodeName = namespace.prefix + ':' + nodeName;
                }
                break;
              }
            }
          }
        }
        buf.push('<', prefixedNodeName);
        for (var i = 0; i < len; i++) {
          var attr = attrs.item(i);
          if (attr.prefix == 'xmlns') {
            visibleNamespaces.push({
              prefix: attr.localName,
              namespace: attr.value
            });
          } else if (attr.nodeName == 'xmlns') {
            visibleNamespaces.push({
              prefix: '',
              namespace: attr.value
            });
          }
        }
        for (var i = 0; i < len; i++) {
          var attr = attrs.item(i);
          if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
            var prefix = attr.prefix || '';
            var uri = attr.namespaceURI;
            addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
            visibleNamespaces.push({
              prefix: prefix,
              namespace: uri
            });
          }
          serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
        }
        if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
          var prefix = node.prefix || '';
          var uri = node.namespaceURI;
          addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
          visibleNamespaces.push({
            prefix: prefix,
            namespace: uri
          });
        }
        if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
          buf.push('>');
          if (isHTML && /^script$/i.test(nodeName)) {
            while (child) {
              if (child.data) {
                buf.push(child.data);
              } else {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              }
              child = child.nextSibling;
            }
          } else {
            while (child) {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              child = child.nextSibling;
            }
          }
          buf.push('</', prefixedNodeName, '>');
        } else {
          buf.push('/>');
        }
        return;
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        var child = node.firstChild;
        while (child) {
          serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
          child = child.nextSibling;
        }
        return;
      case ATTRIBUTE_NODE:
        return addSerializedAttribute(buf, node.name, node.value);
      case TEXT_NODE:
        return buf.push(node.data.replace(/[<&]/g, _xmlEncoder).replace(/]]>/g, ']]&gt;'));
      case CDATA_SECTION_NODE:
        return buf.push('<![CDATA[', node.data, ']]>');
      case COMMENT_NODE:
        return buf.push("<!--", node.data, "-->");
      case DOCUMENT_TYPE_NODE:
        var pubid = node.publicId;
        var sysid = node.systemId;
        buf.push('<!DOCTYPE ', node.name);
        if (pubid) {
          buf.push(' PUBLIC ', pubid);
          if (sysid && sysid != '.') {
            buf.push(' ', sysid);
          }
          buf.push('>');
        } else if (sysid && sysid != '.') {
          buf.push(' SYSTEM ', sysid, '>');
        } else {
          var sub = node.internalSubset;
          if (sub) {
            buf.push(" [", sub, "]");
          }
          buf.push(">");
        }
        return;
      case PROCESSING_INSTRUCTION_NODE:
        return buf.push("<?", node.target, " ", node.data, "?>");
      case ENTITY_REFERENCE_NODE:
        return buf.push('&', node.nodeName, ';');
      default:
        buf.push('??', node.nodeName);
    }
  }
  function _importNode(doc, node, deep) {
    var node2;
    switch (node.nodeType) {
      case ELEMENT_NODE:
        node2 = node.cloneNode(false);
        node2.ownerDocument = doc;
      case DOCUMENT_FRAGMENT_NODE:
        break;
      case ATTRIBUTE_NODE:
        deep = true;
        break;
    }
    if (!node2) {
      node2 = node.cloneNode(false);
    }
    node2.ownerDocument = doc;
    node2.parentNode = null;
    if (deep) {
      var child = node.firstChild;
      while (child) {
        node2.appendChild(_importNode(doc, child, deep));
        child = child.nextSibling;
      }
    }
    return node2;
  }
  function _cloneNode(doc, node, deep) {
    var node2 = new node.constructor();
    for (var n in node) {
      var v = node[n];
      if (typeof v != 'object') {
        if (v != node2[n]) {
          node2[n] = v;
        }
      }
    }
    if (node.childNodes) {
      node2.childNodes = new NodeList();
    }
    node2.ownerDocument = doc;
    switch (node2.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes;
        var attrs2 = node2.attributes = new NamedNodeMap();
        var len = attrs.length;
        attrs2._ownerElement = node2;
        for (var i = 0; i < len; i++) {
          node2.setAttributeNode(_cloneNode(doc, attrs.item(i), true));
        }
        break;
      case ATTRIBUTE_NODE:
        deep = true;
    }
    if (deep) {
      var child = node.firstChild;
      while (child) {
        node2.appendChild(_cloneNode(doc, child, deep));
        child = child.nextSibling;
      }
    }
    return node2;
  }
  function __set__(object, key, value) {
    object[key] = value;
  }
  try {
    if (Object.defineProperty) {
      var getTextContent = function getTextContent(node) {
        switch (node.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            var buf = [];
            node = node.firstChild;
            while (node) {
              if (node.nodeType !== 7 && node.nodeType !== 8) {
                buf.push(getTextContent(node));
              }
              node = node.nextSibling;
            }
            return buf.join('');
          default:
            return node.nodeValue;
        }
      };
      Object.defineProperty(LiveNodeList.prototype, 'length', {
        get: function get() {
          _updateLiveList(this);
          return this.$$length;
        }
      });
      Object.defineProperty(Node.prototype, 'textContent', {
        get: function get() {
          return getTextContent(this);
        },
        set: function set(data) {
          switch (this.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              while (this.firstChild) {
                this.removeChild(this.firstChild);
              }
              if (data || String(data)) {
                this.appendChild(this.ownerDocument.createTextNode(data));
              }
              break;
            default:
              this.data = data;
              this.value = data;
              this.nodeValue = data;
          }
        }
      });
      __set__ = function __set__(object, key, value) {
        object['$$' + key] = value;
      };
    }
  } catch (e) {
  }
  var DocumentType_1 = DocumentType;
  var DOMException_1 = DOMException;
  var DOMImplementation_1$1 = DOMImplementation$1;
  var Element_1 = Element;
  var Node_1 = Node;
  var NodeList_1 = NodeList;
  var XMLSerializer_1 = XMLSerializer$1;
  var dom = {
    DocumentType: DocumentType_1,
    DOMException: DOMException_1,
    DOMImplementation: DOMImplementation_1$1,
    Element: Element_1,
    Node: Node_1,
    NodeList: NodeList_1,
    XMLSerializer: XMLSerializer_1
  };
  var entities = createCommonjsModule(function (module, exports) {
    var freeze = conventions.freeze;
    exports.XML_ENTITIES = freeze({
      amp: '&',
      apos: "'",
      gt: '>',
      lt: '<',
      quot: '"'
    });
    exports.HTML_ENTITIES = freeze({
      lt: '<',
      gt: '>',
      amp: '&',
      quot: '"',
      apos: "'",
      Agrave: "",
      Aacute: "",
      Acirc: "",
      Atilde: "",
      Auml: "",
      Aring: "",
      AElig: "",
      Ccedil: "",
      Egrave: "",
      Eacute: "",
      Ecirc: "",
      Euml: "",
      Igrave: "",
      Iacute: "",
      Icirc: "",
      Iuml: "",
      ETH: "",
      Ntilde: "",
      Ograve: "",
      Oacute: "",
      Ocirc: "",
      Otilde: "",
      Ouml: "",
      Oslash: "",
      Ugrave: "",
      Uacute: "",
      Ucirc: "",
      Uuml: "",
      Yacute: "",
      THORN: "",
      szlig: "",
      agrave: "",
      aacute: "",
      acirc: "",
      atilde: "",
      auml: "",
      aring: "",
      aelig: "",
      ccedil: "",
      egrave: "",
      eacute: "",
      ecirc: "",
      euml: "",
      igrave: "",
      iacute: "",
      icirc: "",
      iuml: "",
      eth: "",
      ntilde: "",
      ograve: "",
      oacute: "",
      ocirc: "",
      otilde: "",
      ouml: "",
      oslash: "",
      ugrave: "",
      uacute: "",
      ucirc: "",
      uuml: "",
      yacute: "",
      thorn: "",
      yuml: "",
      nbsp: "\xA0",
      iexcl: "",
      cent: "",
      pound: "",
      curren: "",
      yen: "",
      brvbar: "",
      sect: "",
      uml: "",
      copy: "",
      ordf: "",
      laquo: "",
      not: "",
      shy: "",
      reg: "",
      macr: "",
      deg: "",
      plusmn: "",
      sup2: "",
      sup3: "",
      acute: "",
      micro: "",
      para: "",
      middot: "",
      cedil: "",
      sup1: "",
      ordm: "",
      raquo: "",
      frac14: "",
      frac12: "",
      frac34: "",
      iquest: "",
      times: "",
      divide: "",
      forall: "",
      part: "",
      exist: "",
      empty: "",
      nabla: "",
      isin: "",
      notin: "",
      ni: "",
      prod: "",
      sum: "",
      minus: "",
      lowast: "",
      radic: "",
      prop: "",
      infin: "",
      ang: "",
      and: "",
      or: "",
      cap: "",
      cup: "",
      'int': "",
      there4: "",
      sim: "",
      cong: "",
      asymp: "",
      ne: "",
      equiv: "",
      le: "",
      ge: "",
      sub: "",
      sup: "",
      nsub: "",
      sube: "",
      supe: "",
      oplus: "",
      otimes: "",
      perp: "",
      sdot: "",
      Alpha: "",
      Beta: "",
      Gamma: "",
      Delta: "",
      Epsilon: "",
      Zeta: "",
      Eta: "",
      Theta: "",
      Iota: "",
      Kappa: "",
      Lambda: "",
      Mu: "",
      Nu: "",
      Xi: "",
      Omicron: "",
      Pi: "",
      Rho: "",
      Sigma: "",
      Tau: "",
      Upsilon: "",
      Phi: "",
      Chi: "",
      Psi: "",
      Omega: "",
      alpha: "",
      beta: "",
      gamma: "",
      delta: "",
      epsilon: "",
      zeta: "",
      eta: "",
      theta: "",
      iota: "",
      kappa: "",
      lambda: "",
      mu: "",
      nu: "",
      xi: "",
      omicron: "",
      pi: "",
      rho: "",
      sigmaf: "",
      sigma: "",
      tau: "",
      upsilon: "",
      phi: "",
      chi: "",
      psi: "",
      omega: "",
      thetasym: "",
      upsih: "",
      piv: "",
      OElig: "",
      oelig: "",
      Scaron: "",
      scaron: "",
      Yuml: "",
      fnof: "",
      circ: "",
      tilde: "",
      ensp: "",
      emsp: "",
      thinsp: "",
      zwnj: "",
      zwj: "",
      lrm: "",
      rlm: "",
      ndash: "",
      mdash: "",
      lsquo: "",
      rsquo: "",
      sbquo: "",
      ldquo: "",
      rdquo: "",
      bdquo: "",
      dagger: "",
      Dagger: "",
      bull: "",
      hellip: "",
      permil: "",
      prime: "",
      Prime: "",
      lsaquo: "",
      rsaquo: "",
      oline: "",
      euro: "",
      trade: "",
      larr: "",
      uarr: "",
      rarr: "",
      darr: "",
      harr: "",
      crarr: "",
      lceil: "",
      rceil: "",
      lfloor: "",
      rfloor: "",
      loz: "",
      spades: "",
      clubs: "",
      hearts: "",
      diams: ""
    });
    exports.entityMap = exports.HTML_ENTITIES;
  });
  entities.XML_ENTITIES;
  entities.HTML_ENTITIES;
  entities.entityMap;
  var NAMESPACE$1 = conventions.NAMESPACE;
  var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
  var tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\:' + nameStartChar.source + nameChar.source + '*)?$');
  var S_TAG = 0;
  var S_ATTR = 1;
  var S_ATTR_SPACE = 2;
  var S_EQ = 3;
  var S_ATTR_NOQUOT_VALUE = 4;
  var S_ATTR_END = 5;
  var S_TAG_SPACE = 6;
  var S_TAG_CLOSE = 7;
  function ParseError$1(message, locator) {
    this.message = message;
    this.locator = locator;
    if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError$1);
  }
  ParseError$1.prototype = new Error();
  ParseError$1.prototype.name = ParseError$1.name;
  function XMLReader$1() {}
  XMLReader$1.prototype = {
    parse: function parse(source, defaultNSMap, entityMap) {
      var domBuilder = this.domBuilder;
      domBuilder.startDocument();
      _copy(defaultNSMap, defaultNSMap = {});
      _parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
      domBuilder.endDocument();
    }
  };
  function _parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
    function fixedFromCharCode(code) {
      if (code > 0xffff) {
        code -= 0x10000;
        var surrogate1 = 0xd800 + (code >> 10),
            surrogate2 = 0xdc00 + (code & 0x3ff);
        return String.fromCharCode(surrogate1, surrogate2);
      } else {
        return String.fromCharCode(code);
      }
    }
    function entityReplacer(a) {
      var k = a.slice(1, -1);
      if (k in entityMap) {
        return entityMap[k];
      } else if (k.charAt(0) === '#') {
        return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')));
      } else {
        errorHandler.error('entity not found:' + a);
        return a;
      }
    }
    function appendText(end) {
      if (end > start) {
        var xt = source.substring(start, end).replace(/&#?\w+;/g, entityReplacer);
        locator && position(start);
        domBuilder.characters(xt, 0, end - start);
        start = end;
      }
    }
    function position(p, m) {
      while (p >= lineEnd && (m = linePattern.exec(source))) {
        lineStart = m.index;
        lineEnd = lineStart + m[0].length;
        locator.lineNumber++;
      }
      locator.columnNumber = p - lineStart + 1;
    }
    var lineStart = 0;
    var lineEnd = 0;
    var linePattern = /.*(?:\r\n?|\n)|.*$/g;
    var locator = domBuilder.locator;
    var parseStack = [{
      currentNSMap: defaultNSMapCopy
    }];
    var closeMap = {};
    var start = 0;
    while (true) {
      try {
        var tagStart = source.indexOf('<', start);
        if (tagStart < 0) {
          if (!source.substr(start).match(/^\s*$/)) {
            var doc = domBuilder.doc;
            var text = doc.createTextNode(source.substr(start));
            doc.appendChild(text);
            domBuilder.currentElement = text;
          }
          return;
        }
        if (tagStart > start) {
          appendText(tagStart);
        }
        switch (source.charAt(tagStart + 1)) {
          case '/':
            var end = source.indexOf('>', tagStart + 3);
            var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, '');
            var config = parseStack.pop();
            if (end < 0) {
              tagName = source.substring(tagStart + 2).replace(/[\s<].*/, '');
              errorHandler.error("end tag name: " + tagName + ' is not complete:' + config.tagName);
              end = tagStart + 1 + tagName.length;
            } else if (tagName.match(/\s</)) {
              tagName = tagName.replace(/[\s<].*/, '');
              errorHandler.error("end tag name: " + tagName + ' maybe not complete');
              end = tagStart + 1 + tagName.length;
            }
            var localNSMap = config.localNSMap;
            var endMatch = config.tagName == tagName;
            var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
            if (endIgnoreCaseMach) {
              domBuilder.endElement(config.uri, config.localName, tagName);
              if (localNSMap) {
                for (var prefix in localNSMap) {
                  domBuilder.endPrefixMapping(prefix);
                }
              }
              if (!endMatch) {
                errorHandler.fatalError("end tag name: " + tagName + ' is not match the current start tagName:' + config.tagName);
              }
            } else {
              parseStack.push(config);
            }
            end++;
            break;
          case '?':
            locator && position(tagStart);
            end = parseInstruction(source, tagStart, domBuilder);
            break;
          case '!':
            locator && position(tagStart);
            end = parseDCC(source, tagStart, domBuilder, errorHandler);
            break;
          default:
            locator && position(tagStart);
            var el = new ElementAttributes();
            var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
            var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
            var len = el.length;
            if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
              el.closed = true;
              if (!entityMap.nbsp) {
                errorHandler.warning('unclosed xml attribute');
              }
            }
            if (locator && len) {
              var locator2 = copyLocator(locator, {});
              for (var i = 0; i < len; i++) {
                var a = el[i];
                position(a.offset);
                a.locator = copyLocator(locator, {});
              }
              domBuilder.locator = locator2;
              if (appendElement$1(el, domBuilder, currentNSMap)) {
                parseStack.push(el);
              }
              domBuilder.locator = locator;
            } else {
              if (appendElement$1(el, domBuilder, currentNSMap)) {
                parseStack.push(el);
              }
            }
            if (NAMESPACE$1.isHTML(el.uri) && !el.closed) {
              end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
            } else {
              end++;
            }
        }
      } catch (e) {
        if (e instanceof ParseError$1) {
          throw e;
        }
        errorHandler.error('element parse error: ' + e);
        end = -1;
      }
      if (end > start) {
        start = end;
      } else {
        appendText(Math.max(tagStart, start) + 1);
      }
    }
  }
  function copyLocator(f, t) {
    t.lineNumber = f.lineNumber;
    t.columnNumber = f.columnNumber;
    return t;
  }
  function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
    function addAttribute(qname, value, startIndex) {
      if (el.attributeNames.hasOwnProperty(qname)) {
        errorHandler.fatalError('Attribute ' + qname + ' redefined');
      }
      el.addValue(qname, value, startIndex);
    }
    var attrName;
    var value;
    var p = ++start;
    var s = S_TAG;
    while (true) {
      var c = source.charAt(p);
      switch (c) {
        case '=':
          if (s === S_ATTR) {
            attrName = source.slice(start, p);
            s = S_EQ;
          } else if (s === S_ATTR_SPACE) {
            s = S_EQ;
          } else {
            throw new Error('attribute equal must after attrName');
          }
          break;
        case '\'':
        case '"':
          if (s === S_EQ || s === S_ATTR
          ) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p);
              }
              start = p + 1;
              p = source.indexOf(c, start);
              if (p > 0) {
                value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                throw new Error('attribute value no end \'' + c + '\' match');
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
            value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
            addAttribute(attrName, value, start);
            errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ')!!');
            start = p + 1;
            s = S_ATTR_END;
          } else {
            throw new Error('attribute value must after "="');
          }
          break;
        case '/':
          switch (s) {
            case S_TAG:
              el.setTagName(source.slice(start, p));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              s = S_TAG_CLOSE;
              el.closed = true;
            case S_ATTR_NOQUOT_VALUE:
            case S_ATTR:
            case S_ATTR_SPACE:
              break;
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case '':
          errorHandler.error('unexpected end of input');
          if (s == S_TAG) {
            el.setTagName(source.slice(start, p));
          }
          return p;
        case '>':
          switch (s) {
            case S_TAG:
              el.setTagName(source.slice(start, p));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              break;
            case S_ATTR_NOQUOT_VALUE:
            case S_ATTR:
              value = source.slice(start, p);
              if (value.slice(-1) === '/') {
                el.closed = true;
                value = value.slice(0, -1);
              }
            case S_ATTR_SPACE:
              if (s === S_ATTR_SPACE) {
                value = attrName;
              }
              if (s == S_ATTR_NOQUOT_VALUE) {
                errorHandler.warning('attribute "' + value + '" missed quot(")!');
                addAttribute(attrName, value.replace(/&#?\w+;/g, entityReplacer), start);
              } else {
                if (!NAMESPACE$1.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                }
                addAttribute(value, value, start);
              }
              break;
            case S_EQ:
              throw new Error('attribute value missed!!');
          }
          return p;
        case "\x80":
          c = ' ';
        default:
          if (c <= ' ') {
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
                s = S_TAG_SPACE;
                break;
              case S_ATTR:
                attrName = source.slice(start, p);
                s = S_ATTR_SPACE;
                break;
              case S_ATTR_NOQUOT_VALUE:
                var value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                addAttribute(attrName, value, start);
              case S_ATTR_END:
                s = S_TAG_SPACE;
                break;
            }
          } else {
            switch (s) {
              case S_ATTR_SPACE:
                el.tagName;
                if (!NAMESPACE$1.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                }
                addAttribute(attrName, attrName, start);
                start = p;
                s = S_ATTR;
                break;
              case S_ATTR_END:
                errorHandler.warning('attribute space is required"' + attrName + '"!!');
              case S_TAG_SPACE:
                s = S_ATTR;
                start = p;
                break;
              case S_EQ:
                s = S_ATTR_NOQUOT_VALUE;
                start = p;
                break;
              case S_TAG_CLOSE:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
          }
      }
      p++;
    }
  }
  function appendElement$1(el, domBuilder, currentNSMap) {
    var tagName = el.tagName;
    var localNSMap = null;
    var i = el.length;
    while (i--) {
      var a = el[i];
      var qName = a.qName;
      var value = a.value;
      var nsp = qName.indexOf(':');
      if (nsp > 0) {
        var prefix = a.prefix = qName.slice(0, nsp);
        var localName = qName.slice(nsp + 1);
        var nsPrefix = prefix === 'xmlns' && localName;
      } else {
        localName = qName;
        prefix = null;
        nsPrefix = qName === 'xmlns' && '';
      }
      a.localName = localName;
      if (nsPrefix !== false) {
        if (localNSMap == null) {
          localNSMap = {};
          _copy(currentNSMap, currentNSMap = {});
        }
        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
        a.uri = NAMESPACE$1.XMLNS;
        domBuilder.startPrefixMapping(nsPrefix, value);
      }
    }
    var i = el.length;
    while (i--) {
      a = el[i];
      var prefix = a.prefix;
      if (prefix) {
        if (prefix === 'xml') {
          a.uri = NAMESPACE$1.XML;
        }
        if (prefix !== 'xmlns') {
          a.uri = currentNSMap[prefix || ''];
        }
      }
    }
    var nsp = tagName.indexOf(':');
    if (nsp > 0) {
      prefix = el.prefix = tagName.slice(0, nsp);
      localName = el.localName = tagName.slice(nsp + 1);
    } else {
      prefix = null;
      localName = el.localName = tagName;
    }
    var ns = el.uri = currentNSMap[prefix || ''];
    domBuilder.startElement(ns, localName, tagName, el);
    if (el.closed) {
      domBuilder.endElement(ns, localName, tagName);
      if (localNSMap) {
        for (prefix in localNSMap) {
          domBuilder.endPrefixMapping(prefix);
        }
      }
    } else {
      el.currentNSMap = currentNSMap;
      el.localNSMap = localNSMap;
      return true;
    }
  }
  function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
    if (/^(?:script|textarea)$/i.test(tagName)) {
      var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);
      var text = source.substring(elStartEnd + 1, elEndStart);
      if (/[&<]/.test(text)) {
        if (/^script$/i.test(tagName)) {
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
        text = text.replace(/&#?\w+;/g, entityReplacer);
        domBuilder.characters(text, 0, text.length);
        return elEndStart;
      }
    }
    return elStartEnd + 1;
  }
  function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
    var pos = closeMap[tagName];
    if (pos == null) {
      pos = source.lastIndexOf('</' + tagName + '>');
      if (pos < elStartEnd) {
        pos = source.lastIndexOf('</' + tagName);
      }
      closeMap[tagName] = pos;
    }
    return pos < elStartEnd;
  }
  function _copy(source, target) {
    for (var n in source) {
      target[n] = source[n];
    }
  }
  function parseDCC(source, start, domBuilder, errorHandler) {
    var next = source.charAt(start + 2);
    switch (next) {
      case '-':
        if (source.charAt(start + 3) === '-') {
          var end = source.indexOf('-->', start + 4);
          if (end > start) {
            domBuilder.comment(source, start + 4, end - start - 4);
            return end + 3;
          } else {
            errorHandler.error("Unclosed comment");
            return -1;
          }
        } else {
          return -1;
        }
      default:
        if (source.substr(start + 3, 6) == 'CDATA[') {
          var end = source.indexOf(']]>', start + 9);
          domBuilder.startCDATA();
          domBuilder.characters(source, start + 9, end - start - 9);
          domBuilder.endCDATA();
          return end + 3;
        }
        var matchs = split(source, start);
        var len = matchs.length;
        if (len > 1 && /!doctype/i.test(matchs[0][0])) {
          var name = matchs[1][0];
          var pubid = false;
          var sysid = false;
          if (len > 3) {
            if (/^public$/i.test(matchs[2][0])) {
              pubid = matchs[3][0];
              sysid = len > 4 && matchs[4][0];
            } else if (/^system$/i.test(matchs[2][0])) {
              sysid = matchs[3][0];
            }
          }
          var lastMatch = matchs[len - 1];
          domBuilder.startDTD(name, pubid, sysid);
          domBuilder.endDTD();
          return lastMatch.index + lastMatch[0].length;
        }
    }
    return -1;
  }
  function parseInstruction(source, start, domBuilder) {
    var end = source.indexOf('?>', start);
    if (end) {
      var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
      if (match) {
        match[0].length;
        domBuilder.processingInstruction(match[1], match[2]);
        return end + 2;
      } else {
        return -1;
      }
    }
    return -1;
  }
  function ElementAttributes() {
    this.attributeNames = {};
  }
  ElementAttributes.prototype = {
    setTagName: function setTagName(tagName) {
      if (!tagNamePattern.test(tagName)) {
        throw new Error('invalid tagName:' + tagName);
      }
      this.tagName = tagName;
    },
    addValue: function addValue(qName, value, offset) {
      if (!tagNamePattern.test(qName)) {
        throw new Error('invalid attribute:' + qName);
      }
      this.attributeNames[qName] = this.length;
      this[this.length++] = {
        qName: qName,
        value: value,
        offset: offset
      };
    },
    length: 0,
    getLocalName: function getLocalName(i) {
      return this[i].localName;
    },
    getLocator: function getLocator(i) {
      return this[i].locator;
    },
    getQName: function getQName(i) {
      return this[i].qName;
    },
    getURI: function getURI(i) {
      return this[i].uri;
    },
    getValue: function getValue(i) {
      return this[i].value;
    }
  };
  function split(source, start) {
    var match;
    var buf = [];
    var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
    reg.lastIndex = start;
    reg.exec(source);
    while (match = reg.exec(source)) {
      buf.push(match);
      if (match[1]) return buf;
    }
  }
  var XMLReader_1 = XMLReader$1;
  var ParseError_1 = ParseError$1;
  var sax = {
    XMLReader: XMLReader_1,
    ParseError: ParseError_1
  };
  var DOMImplementation = dom.DOMImplementation;
  var NAMESPACE = conventions.NAMESPACE;
  var ParseError = sax.ParseError;
  var XMLReader = sax.XMLReader;
  function DOMParser$1(options) {
    this.options = options || {
      locator: {}
    };
  }
  DOMParser$1.prototype.parseFromString = function (source, mimeType) {
    var options = this.options;
    var sax = new XMLReader();
    var domBuilder = options.domBuilder || new DOMHandler();
    var errorHandler = options.errorHandler;
    var locator = options.locator;
    var defaultNSMap = options.xmlns || {};
    var isHTML = /\/x?html?$/.test(mimeType);
    var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
    if (locator) {
      domBuilder.setDocumentLocator(locator);
    }
    sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
    sax.domBuilder = options.domBuilder || domBuilder;
    if (isHTML) {
      defaultNSMap[''] = NAMESPACE.HTML;
    }
    defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
    if (source && typeof source === 'string') {
      sax.parse(source, defaultNSMap, entityMap);
    } else {
      sax.errorHandler.error("invalid doc source");
    }
    return domBuilder.doc;
  };
  function buildErrorHandler(errorImpl, domBuilder, locator) {
    if (!errorImpl) {
      if (domBuilder instanceof DOMHandler) {
        return domBuilder;
      }
      errorImpl = domBuilder;
    }
    var errorHandler = {};
    var isCallback = errorImpl instanceof Function;
    locator = locator || {};
    function build(key) {
      var fn = errorImpl[key];
      if (!fn && isCallback) {
        fn = errorImpl.length == 2 ? function (msg) {
          errorImpl(key, msg);
        } : errorImpl;
      }
      errorHandler[key] = fn && function (msg) {
        fn('[xmldom ' + key + ']\t' + msg + _locator(locator));
      } || function () {};
    }
    build('warning');
    build('error');
    build('fatalError');
    return errorHandler;
  }
  function DOMHandler() {
    this.cdata = false;
  }
  function position(locator, node) {
    node.lineNumber = locator.lineNumber;
    node.columnNumber = locator.columnNumber;
  }
  DOMHandler.prototype = {
    startDocument: function startDocument() {
      this.doc = new DOMImplementation().createDocument(null, null, null);
      if (this.locator) {
        this.doc.documentURI = this.locator.systemId;
      }
    },
    startElement: function startElement(namespaceURI, localName, qName, attrs) {
      var doc = this.doc;
      var el = doc.createElementNS(namespaceURI, qName || localName);
      var len = attrs.length;
      appendElement(this, el);
      this.currentElement = el;
      this.locator && position(this.locator, el);
      for (var i = 0; i < len; i++) {
        var namespaceURI = attrs.getURI(i);
        var value = attrs.getValue(i);
        var qName = attrs.getQName(i);
        var attr = doc.createAttributeNS(namespaceURI, qName);
        this.locator && position(attrs.getLocator(i), attr);
        attr.value = attr.nodeValue = value;
        el.setAttributeNode(attr);
      }
    },
    endElement: function endElement(namespaceURI, localName, qName) {
      var current = this.currentElement;
      current.tagName;
      this.currentElement = current.parentNode;
    },
    startPrefixMapping: function startPrefixMapping(prefix, uri) {},
    endPrefixMapping: function endPrefixMapping(prefix) {},
    processingInstruction: function processingInstruction(target, data) {
      var ins = this.doc.createProcessingInstruction(target, data);
      this.locator && position(this.locator, ins);
      appendElement(this, ins);
    },
    ignorableWhitespace: function ignorableWhitespace(ch, start, length) {},
    characters: function characters(chars, start, length) {
      chars = _toString.apply(this, arguments);
      if (chars) {
        if (this.cdata) {
          var charNode = this.doc.createCDATASection(chars);
        } else {
          var charNode = this.doc.createTextNode(chars);
        }
        if (this.currentElement) {
          this.currentElement.appendChild(charNode);
        } else if (/^\s*$/.test(chars)) {
          this.doc.appendChild(charNode);
        }
        this.locator && position(this.locator, charNode);
      }
    },
    skippedEntity: function skippedEntity(name) {},
    endDocument: function endDocument() {
      this.doc.normalize();
    },
    setDocumentLocator: function setDocumentLocator(locator) {
      if (this.locator = locator) {
        locator.lineNumber = 0;
      }
    },
    comment: function comment(chars, start, length) {
      chars = _toString.apply(this, arguments);
      var comm = this.doc.createComment(chars);
      this.locator && position(this.locator, comm);
      appendElement(this, comm);
    },
    startCDATA: function startCDATA() {
      this.cdata = true;
    },
    endCDATA: function endCDATA() {
      this.cdata = false;
    },
    startDTD: function startDTD(name, publicId, systemId) {
      var impl = this.doc.implementation;
      if (impl && impl.createDocumentType) {
        var dt = impl.createDocumentType(name, publicId, systemId);
        this.locator && position(this.locator, dt);
        appendElement(this, dt);
        this.doc.doctype = dt;
      }
    },
    warning: function warning(error) {
      console.warn('[xmldom warning]\t' + error, _locator(this.locator));
    },
    error: function error(_error) {
      console.error('[xmldom error]\t' + _error, _locator(this.locator));
    },
    fatalError: function fatalError(error) {
      throw new ParseError(error, this.locator);
    }
  };
  function _locator(l) {
    if (l) {
      return '\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';
    }
  }
  function _toString(chars, start, length) {
    if (typeof chars == 'string') {
      return chars.substr(start, length);
    } else {
      if (chars.length >= start + length || start) {
        return new java.lang.String(chars, start, length) + '';
      }
      return chars;
    }
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function (key) {
    DOMHandler.prototype[key] = function () {
      return null;
    };
  });
  function appendElement(hander, node) {
    if (!hander.currentElement) {
      hander.doc.appendChild(node);
    } else {
      hander.currentElement.appendChild(node);
    }
  }
  var __DOMHandler = DOMHandler;
  var DOMParser_1 = DOMParser$1;
  var DOMImplementation_1 = dom.DOMImplementation;
  var XMLSerializer = dom.XMLSerializer;
  var domParser = {
    __DOMHandler: __DOMHandler,
    DOMParser: DOMParser_1,
    DOMImplementation: DOMImplementation_1,
    XMLSerializer: XMLSerializer
  };
  var DOMParser = domParser.DOMParser;
  /*! @name mpd-parser @version 0.21.0 @license Apache-2.0 */
  var isObject = function isObject(obj) {
    return !!obj && typeof obj === 'object';
  };
  var merge = function merge() {
    for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
      objects[_key] = arguments[_key];
    }
    return objects.reduce(function (result, source) {
      if (typeof source !== 'object') {
        return result;
      }
      Object.keys(source).forEach(function (key) {
        if (Array.isArray(result[key]) && Array.isArray(source[key])) {
          result[key] = result[key].concat(source[key]);
        } else if (isObject(result[key]) && isObject(source[key])) {
          result[key] = merge(result[key], source[key]);
        } else {
          result[key] = source[key];
        }
      });
      return result;
    }, {});
  };
  var values = function values(o) {
    return Object.keys(o).map(function (k) {
      return o[k];
    });
  };
  var range = function range(start, end) {
    var result = [];
    for (var i = start; i < end; i++) {
      result.push(i);
    }
    return result;
  };
  var flatten = function flatten(lists) {
    return lists.reduce(function (x, y) {
      return x.concat(y);
    }, []);
  };
  var from = function from(list) {
    if (!list.length) {
      return [];
    }
    var result = [];
    for (var i = 0; i < list.length; i++) {
      result.push(list[i]);
    }
    return result;
  };
  var findIndexes = function findIndexes(l, key) {
    return l.reduce(function (a, e, i) {
      if (e[key]) {
        a.push(i);
      }
      return a;
    }, []);
  };
  var findIndex = function findIndex(list, matchingFunction) {
    for (var i = 0; i < list.length; i++) {
      if (matchingFunction(list[i])) {
        return i;
      }
    }
    return -1;
  };
  var union = function union(lists, keyFunction) {
    return values(lists.reduce(function (acc, list) {
      list.forEach(function (el) {
        acc[keyFunction(el)] = el;
      });
      return acc;
    }, {}));
  };
  var errors = {
    INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',
    DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',
    DASH_INVALID_XML: 'DASH_INVALID_XML',
    NO_BASE_URL: 'NO_BASE_URL',
    MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',
    SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',
    UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'
  };
  var urlTypeToSegment = function urlTypeToSegment(_ref) {
    var _ref$baseUrl = _ref.baseUrl,
        baseUrl = _ref$baseUrl === void 0 ? '' : _ref$baseUrl,
        _ref$source = _ref.source,
        source = _ref$source === void 0 ? '' : _ref$source,
        _ref$range = _ref.range,
        range = _ref$range === void 0 ? '' : _ref$range,
        _ref$indexRange = _ref.indexRange,
        indexRange = _ref$indexRange === void 0 ? '' : _ref$indexRange;
    var segment = {
      uri: source,
      resolvedUri: resolveUrl$1(baseUrl || '', source)
    };
    if (range || indexRange) {
      var rangeStr = range ? range : indexRange;
      var ranges = rangeStr.split('-');
      var startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);
      var endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10);
      if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {
        startRange = Number(startRange);
      }
      if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {
        endRange = Number(endRange);
      }
      var length;
      if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {
        length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);
      } else {
        length = endRange - startRange + 1;
      }
      if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {
        length = Number(length);
      }
      segment.byterange = {
        length: length,
        offset: startRange
      };
    }
    return segment;
  };
  var byteRangeToString = function byteRangeToString(byterange) {
    var endRange;
    if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {
      endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);
    } else {
      endRange = byterange.offset + byterange.length - 1;
    }
    return byterange.offset + "-" + endRange;
  };
  var parseEndNumber = function parseEndNumber(endNumber) {
    if (endNumber && typeof endNumber !== 'number') {
      endNumber = parseInt(endNumber, 10);
    }
    if (isNaN(endNumber)) {
      return null;
    }
    return endNumber;
  };
  var segmentRange = {
    "static": function _static(attributes) {
      var duration = attributes.duration,
          _attributes$timescale = attributes.timescale,
          timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,
          sourceDuration = attributes.sourceDuration,
          periodDuration = attributes.periodDuration;
      var endNumber = parseEndNumber(attributes.endNumber);
      var segmentDuration = duration / timescale;
      if (typeof endNumber === 'number') {
        return {
          start: 0,
          end: endNumber
        };
      }
      if (typeof periodDuration === 'number') {
        return {
          start: 0,
          end: periodDuration / segmentDuration
        };
      }
      return {
        start: 0,
        end: sourceDuration / segmentDuration
      };
    },
    dynamic: function dynamic(attributes) {
      var NOW = attributes.NOW,
          clientOffset = attributes.clientOffset,
          availabilityStartTime = attributes.availabilityStartTime,
          _attributes$timescale2 = attributes.timescale,
          timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,
          duration = attributes.duration,
          _attributes$periodSta = attributes.periodStart,
          periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta,
          _attributes$minimumUp = attributes.minimumUpdatePeriod,
          minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp,
          _attributes$timeShift = attributes.timeShiftBufferDepth,
          timeShiftBufferDepth = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;
      var endNumber = parseEndNumber(attributes.endNumber);
      var now = (NOW + clientOffset) / 1000;
      var periodStartWC = availabilityStartTime + periodStart;
      var periodEndWC = now + minimumUpdatePeriod;
      var periodDuration = periodEndWC - periodStartWC;
      var segmentCount = Math.ceil(periodDuration * timescale / duration);
      var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);
      var availableEnd = Math.floor((now - periodStartWC) * timescale / duration);
      return {
        start: Math.max(0, availableStart),
        end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)
      };
    }
  };
  var toSegments = function toSegments(attributes) {
    return function (number) {
      var duration = attributes.duration,
          _attributes$timescale3 = attributes.timescale,
          timescale = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3,
          periodStart = attributes.periodStart,
          _attributes$startNumb = attributes.startNumber,
          startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;
      return {
        number: startNumber + number,
        duration: duration / timescale,
        timeline: periodStart,
        time: number * duration
      };
    };
  };
  var parseByDuration = function parseByDuration(attributes) {
    var type = attributes.type,
        duration = attributes.duration,
        _attributes$timescale4 = attributes.timescale,
        timescale = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4,
        periodDuration = attributes.periodDuration,
        sourceDuration = attributes.sourceDuration;
    var _segmentRange$type = segmentRange[type](attributes),
        start = _segmentRange$type.start,
        end = _segmentRange$type.end;
    var segments = range(start, end).map(toSegments(attributes));
    if (type === 'static') {
      var index = segments.length - 1;
      var sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration;
      segments[index].duration = sectionDuration - duration / timescale * index;
    }
    return segments;
  };
  var segmentsFromBase = function segmentsFromBase(attributes) {
    var baseUrl = attributes.baseUrl,
        _attributes$initializ = attributes.initialization,
        initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ,
        sourceDuration = attributes.sourceDuration,
        _attributes$indexRang = attributes.indexRange,
        indexRange = _attributes$indexRang === void 0 ? '' : _attributes$indexRang,
        periodStart = attributes.periodStart,
        presentationTime = attributes.presentationTime,
        _attributes$number = attributes.number,
        number = _attributes$number === void 0 ? 0 : _attributes$number,
        duration = attributes.duration;
    if (!baseUrl) {
      throw new Error(errors.NO_BASE_URL);
    }
    var initSegment = urlTypeToSegment({
      baseUrl: baseUrl,
      source: initialization.sourceURL,
      range: initialization.range
    });
    var segment = urlTypeToSegment({
      baseUrl: baseUrl,
      source: baseUrl,
      indexRange: indexRange
    });
    segment.map = initSegment;
    if (duration) {
      var segmentTimeInfo = parseByDuration(attributes);
      if (segmentTimeInfo.length) {
        segment.duration = segmentTimeInfo[0].duration;
        segment.timeline = segmentTimeInfo[0].timeline;
      }
    } else if (sourceDuration) {
      segment.duration = sourceDuration;
      segment.timeline = periodStart;
    }
    segment.presentationTime = presentationTime || periodStart;
    segment.number = number;
    return [segment];
  };
  var addSidxSegmentsToPlaylist$1 = function addSidxSegmentsToPlaylist(playlist, sidx, baseUrl) {
    var initSegment = playlist.sidx.map ? playlist.sidx.map : null;
    var sourceDuration = playlist.sidx.duration;
    var timeline = playlist.timeline || 0;
    var sidxByteRange = playlist.sidx.byterange;
    var sidxEnd = sidxByteRange.offset + sidxByteRange.length;
    var timescale = sidx.timescale;
    var mediaReferences = sidx.references.filter(function (r) {
      return r.referenceType !== 1;
    });
    var segments = [];
    var type = playlist.endList ? 'static' : 'dynamic';
    var periodStart = playlist.sidx.timeline;
    var presentationTime = periodStart;
    var number = playlist.mediaSequence || 0;
    var startIndex;
    if (typeof sidx.firstOffset === 'bigint') {
      startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;
    } else {
      startIndex = sidxEnd + sidx.firstOffset;
    }
    for (var i = 0; i < mediaReferences.length; i++) {
      var reference = sidx.references[i];
      var size = reference.referencedSize;
      var duration = reference.subsegmentDuration;
      var endIndex = void 0;
      if (typeof startIndex === 'bigint') {
        endIndex = startIndex + window.BigInt(size) - window.BigInt(1);
      } else {
        endIndex = startIndex + size - 1;
      }
      var indexRange = startIndex + "-" + endIndex;
      var attributes = {
        baseUrl: baseUrl,
        timescale: timescale,
        timeline: timeline,
        periodStart: periodStart,
        presentationTime: presentationTime,
        number: number,
        duration: duration,
        sourceDuration: sourceDuration,
        indexRange: indexRange,
        type: type
      };
      var segment = segmentsFromBase(attributes)[0];
      if (initSegment) {
        segment.map = initSegment;
      }
      segments.push(segment);
      if (typeof startIndex === 'bigint') {
        startIndex += window.BigInt(size);
      } else {
        startIndex += size;
      }
      presentationTime += duration / timescale;
      number++;
    }
    playlist.segments = segments;
    return playlist;
  };
  var SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES'];
  var TIME_FUDGE = 1 / 60;
  var getUniqueTimelineStarts = function getUniqueTimelineStarts(timelineStarts) {
    return union(timelineStarts, function (_ref) {
      var timeline = _ref.timeline;
      return timeline;
    }).sort(function (a, b) {
      return a.timeline > b.timeline ? 1 : -1;
    });
  };
  var findPlaylistWithName = function findPlaylistWithName(playlists, name) {
    for (var i = 0; i < playlists.length; i++) {
      if (playlists[i].attributes.NAME === name) {
        return playlists[i];
      }
    }
    return null;
  };
  var getMediaGroupPlaylists = function getMediaGroupPlaylists(manifest) {
    var mediaGroupPlaylists = [];
    forEachMediaGroup$1(manifest, SUPPORTED_MEDIA_TYPES, function (properties, type, group, label) {
      mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);
    });
    return mediaGroupPlaylists;
  };
  var updateMediaSequenceForPlaylist = function updateMediaSequenceForPlaylist(_ref2) {
    var playlist = _ref2.playlist,
        mediaSequence = _ref2.mediaSequence;
    playlist.mediaSequence = mediaSequence;
    playlist.segments.forEach(function (segment, index) {
      segment.number = playlist.mediaSequence + index;
    });
  };
  var updateSequenceNumbers = function updateSequenceNumbers(_ref3) {
    var oldPlaylists = _ref3.oldPlaylists,
        newPlaylists = _ref3.newPlaylists,
        timelineStarts = _ref3.timelineStarts;
    newPlaylists.forEach(function (playlist) {
      playlist.discontinuitySequence = findIndex(timelineStarts, function (_ref4) {
        var timeline = _ref4.timeline;
        return timeline === playlist.timeline;
      });
      var oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);
      if (!oldPlaylist) {
        return;
      }
      if (playlist.sidx) {
        return;
      }
      var firstNewSegment = playlist.segments[0];
      var oldMatchingSegmentIndex = findIndex(oldPlaylist.segments, function (oldSegment) {
        return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;
      });
      if (oldMatchingSegmentIndex === -1) {
        updateMediaSequenceForPlaylist({
          playlist: playlist,
          mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length
        });
        playlist.segments[0].discontinuity = true;
        playlist.discontinuityStarts.unshift(0);
        if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {
          playlist.discontinuitySequence--;
        }
        return;
      }
      var oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];
      if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {
        firstNewSegment.discontinuity = true;
        playlist.discontinuityStarts.unshift(0);
        playlist.discontinuitySequence--;
      }
      updateMediaSequenceForPlaylist({
        playlist: playlist,
        mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number
      });
    });
  };
  var positionManifestOnTimeline = function positionManifestOnTimeline(_ref5) {
    var oldManifest = _ref5.oldManifest,
        newManifest = _ref5.newManifest;
    var oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));
    var newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest));
    newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);
    updateSequenceNumbers({
      oldPlaylists: oldPlaylists,
      newPlaylists: newPlaylists,
      timelineStarts: newManifest.timelineStarts
    });
    return newManifest;
  };
  var generateSidxKey = function generateSidxKey(sidx) {
    return sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);
  };
  var mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists(playlists) {
    var mergedPlaylists = values(playlists.reduce(function (acc, playlist) {
      var name = playlist.attributes.id + (playlist.attributes.lang || '');
      if (!acc[name]) {
        acc[name] = playlist;
        acc[name].attributes.timelineStarts = [];
      } else {
        if (playlist.segments) {
          var _acc$name$segments;
          if (playlist.segments[0]) {
            playlist.segments[0].discontinuity = true;
          }
          (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments);
        }
        if (playlist.attributes.contentProtection) {
          acc[name].attributes.contentProtection = playlist.attributes.contentProtection;
        }
      }
      acc[name].attributes.timelineStarts.push({
        start: playlist.attributes.periodStart,
        timeline: playlist.attributes.periodStart
      });
      return acc;
    }, {}));
    return mergedPlaylists.map(function (playlist) {
      playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');
      return playlist;
    });
  };
  var addSidxSegmentsToPlaylist = function addSidxSegmentsToPlaylist(playlist, sidxMapping) {
    var sidxKey = generateSidxKey(playlist.sidx);
    var sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;
    if (sidxMatch) {
      addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);
    }
    return playlist;
  };
  var addSidxSegmentsToPlaylists = function addSidxSegmentsToPlaylists(playlists, sidxMapping) {
    if (sidxMapping === void 0) {
      sidxMapping = {};
    }
    if (!Object.keys(sidxMapping).length) {
      return playlists;
    }
    for (var i in playlists) {
      playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);
    }
    return playlists;
  };
  var formatAudioPlaylist = function formatAudioPlaylist(_ref, isAudioOnly) {
    var _attributes;
    var attributes = _ref.attributes,
        segments = _ref.segments,
        sidx = _ref.sidx,
        mediaSequence = _ref.mediaSequence,
        discontinuitySequence = _ref.discontinuitySequence,
        discontinuityStarts = _ref.discontinuityStarts;
    var playlist = {
      attributes: (_attributes = {
        NAME: attributes.id,
        BANDWIDTH: attributes.bandwidth,
        CODECS: attributes.codecs
      }, _attributes['PROGRAM-ID'] = 1, _attributes),
      uri: '',
      endList: attributes.type === 'static',
      timeline: attributes.periodStart,
      resolvedUri: '',
      targetDuration: attributes.duration,
      discontinuitySequence: discontinuitySequence,
      discontinuityStarts: discontinuityStarts,
      timelineStarts: attributes.timelineStarts,
      mediaSequence: mediaSequence,
      segments: segments
    };
    if (attributes.contentProtection) {
      playlist.contentProtection = attributes.contentProtection;
    }
    if (sidx) {
      playlist.sidx = sidx;
    }
    if (isAudioOnly) {
      playlist.attributes.AUDIO = 'audio';
      playlist.attributes.SUBTITLES = 'subs';
    }
    return playlist;
  };
  var formatVttPlaylist = function formatVttPlaylist(_ref2) {
    var _m3u8Attributes;
    var attributes = _ref2.attributes,
        segments = _ref2.segments,
        mediaSequence = _ref2.mediaSequence,
        discontinuityStarts = _ref2.discontinuityStarts,
        discontinuitySequence = _ref2.discontinuitySequence;
    if (typeof segments === 'undefined') {
      segments = [{
        uri: attributes.baseUrl,
        timeline: attributes.periodStart,
        resolvedUri: attributes.baseUrl || '',
        duration: attributes.sourceDuration,
        number: 0
      }];
      attributes.duration = attributes.sourceDuration;
    }
    var m3u8Attributes = (_m3u8Attributes = {
      NAME: attributes.id,
      BANDWIDTH: attributes.bandwidth
    }, _m3u8Attributes['PROGRAM-ID'] = 1, _m3u8Attributes);
    if (attributes.codecs) {
      m3u8Attributes.CODECS = attributes.codecs;
    }
    return {
      attributes: m3u8Attributes,
      uri: '',
      endList: attributes.type === 'static',
      timeline: attributes.periodStart,
      resolvedUri: attributes.baseUrl || '',
      targetDuration: attributes.duration,
      timelineStarts: attributes.timelineStarts,
      discontinuityStarts: discontinuityStarts,
      discontinuitySequence: discontinuitySequence,
      mediaSequence: mediaSequence,
      segments: segments
    };
  };
  var organizeAudioPlaylists = function organizeAudioPlaylists(playlists, sidxMapping, isAudioOnly) {
    if (sidxMapping === void 0) {
      sidxMapping = {};
    }
    if (isAudioOnly === void 0) {
      isAudioOnly = false;
    }
    var mainPlaylist;
    var formattedPlaylists = playlists.reduce(function (a, playlist) {
      var role = playlist.attributes.role && playlist.attributes.role.value || '';
      var language = playlist.attributes.lang || '';
      var label = playlist.attributes.label || 'main';
      if (language && !playlist.attributes.label) {
        var roleLabel = role ? " (" + role + ")" : '';
        label = "" + playlist.attributes.lang + roleLabel;
      }
      if (!a[label]) {
        a[label] = {
          language: language,
          autoselect: true,
          "default": role === 'main',
          playlists: [],
          uri: ''
        };
      }
      var formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);
      a[label].playlists.push(formatted);
      if (typeof mainPlaylist === 'undefined' && role === 'main') {
        mainPlaylist = playlist;
        mainPlaylist["default"] = true;
      }
      return a;
    }, {});
    if (!mainPlaylist) {
      var firstLabel = Object.keys(formattedPlaylists)[0];
      formattedPlaylists[firstLabel]["default"] = true;
    }
    return formattedPlaylists;
  };
  var organizeVttPlaylists = function organizeVttPlaylists(playlists, sidxMapping) {
    if (sidxMapping === void 0) {
      sidxMapping = {};
    }
    return playlists.reduce(function (a, playlist) {
      var label = playlist.attributes.lang || 'text';
      if (!a[label]) {
        a[label] = {
          language: label,
          "default": false,
          autoselect: false,
          playlists: [],
          uri: ''
        };
      }
      a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));
      return a;
    }, {});
  };
  var organizeCaptionServices = function organizeCaptionServices(captionServices) {
    return captionServices.reduce(function (svcObj, svc) {
      if (!svc) {
        return svcObj;
      }
      svc.forEach(function (service) {
        var channel = service.channel,
            language = service.language;
        svcObj[language] = {
          autoselect: false,
          "default": false,
          instreamId: channel,
          language: language
        };
        if (service.hasOwnProperty('aspectRatio')) {
          svcObj[language].aspectRatio = service.aspectRatio;
        }
        if (service.hasOwnProperty('easyReader')) {
          svcObj[language].easyReader = service.easyReader;
        }
        if (service.hasOwnProperty('3D')) {
          svcObj[language]['3D'] = service['3D'];
        }
      });
      return svcObj;
    }, {});
  };
  var formatVideoPlaylist = function formatVideoPlaylist(_ref3) {
    var _attributes2;
    var attributes = _ref3.attributes,
        segments = _ref3.segments,
        sidx = _ref3.sidx,
        discontinuityStarts = _ref3.discontinuityStarts;
    var playlist = {
      attributes: (_attributes2 = {
        NAME: attributes.id,
        AUDIO: 'audio',
        SUBTITLES: 'subs',
        RESOLUTION: {
          width: attributes.width,
          height: attributes.height
        },
        CODECS: attributes.codecs,
        BANDWIDTH: attributes.bandwidth
      }, _attributes2['PROGRAM-ID'] = 1, _attributes2),
      uri: '',
      endList: attributes.type === 'static',
      timeline: attributes.periodStart,
      resolvedUri: '',
      targetDuration: attributes.duration,
      discontinuityStarts: discontinuityStarts,
      timelineStarts: attributes.timelineStarts,
      segments: segments
    };
    if (attributes.contentProtection) {
      playlist.contentProtection = attributes.contentProtection;
    }
    if (sidx) {
      playlist.sidx = sidx;
    }
    return playlist;
  };
  var videoOnly = function videoOnly(_ref4) {
    var attributes = _ref4.attributes;
    return attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';
  };
  var audioOnly = function audioOnly(_ref5) {
    var attributes = _ref5.attributes;
    return attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';
  };
  var vttOnly = function vttOnly(_ref6) {
    var attributes = _ref6.attributes;
    return attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';
  };
  var addMediaSequenceValues = function addMediaSequenceValues(playlists, timelineStarts) {
    playlists.forEach(function (playlist) {
      playlist.mediaSequence = 0;
      playlist.discontinuitySequence = findIndex(timelineStarts, function (_ref7) {
        var timeline = _ref7.timeline;
        return timeline === playlist.timeline;
      });
      if (!playlist.segments) {
        return;
      }
      playlist.segments.forEach(function (segment, index) {
        segment.number = index;
      });
    });
  };
  var flattenMediaGroupPlaylists = function flattenMediaGroupPlaylists(mediaGroupObject) {
    if (!mediaGroupObject) {
      return [];
    }
    return Object.keys(mediaGroupObject).reduce(function (acc, label) {
      var labelContents = mediaGroupObject[label];
      return acc.concat(labelContents.playlists);
    }, []);
  };
  var toM3u8 = function toM3u8(_ref8) {
    var _mediaGroups;
    var dashPlaylists = _ref8.dashPlaylists,
        locations = _ref8.locations,
        _ref8$sidxMapping = _ref8.sidxMapping,
        sidxMapping = _ref8$sidxMapping === void 0 ? {} : _ref8$sidxMapping,
        previousManifest = _ref8.previousManifest;
    if (!dashPlaylists.length) {
      return {};
    }
    var _dashPlaylists$0$attr = dashPlaylists[0].attributes,
        duration = _dashPlaylists$0$attr.sourceDuration,
        type = _dashPlaylists$0$attr.type,
        suggestedPresentationDelay = _dashPlaylists$0$attr.suggestedPresentationDelay,
        minimumUpdatePeriod = _dashPlaylists$0$attr.minimumUpdatePeriod;
    var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);
    var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));
    var vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));
    var captions = dashPlaylists.map(function (playlist) {
      return playlist.attributes.captionServices;
    }).filter(Boolean);
    var manifest = {
      allowCache: true,
      discontinuityStarts: [],
      segments: [],
      endList: true,
      mediaGroups: (_mediaGroups = {
        AUDIO: {},
        VIDEO: {}
      }, _mediaGroups['CLOSED-CAPTIONS'] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),
      uri: '',
      duration: duration,
      playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)
    };
    if (minimumUpdatePeriod >= 0) {
      manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;
    }
    if (locations) {
      manifest.locations = locations;
    }
    if (type === 'dynamic') {
      manifest.suggestedPresentationDelay = suggestedPresentationDelay;
    }
    var isAudioOnly = manifest.playlists.length === 0;
    var organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;
    var organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;
    var formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));
    var playlistTimelineStarts = formattedPlaylists.map(function (_ref9) {
      var timelineStarts = _ref9.timelineStarts;
      return timelineStarts;
    });
    manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);
    addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);
    if (organizedAudioGroup) {
      manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;
    }
    if (organizedVttGroup) {
      manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;
    }
    if (captions.length) {
      manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);
    }
    if (previousManifest) {
      return positionManifestOnTimeline({
        oldManifest: previousManifest,
        newManifest: manifest
      });
    }
    return manifest;
  };
  var getLiveRValue = function getLiveRValue(attributes, time, duration) {
    var NOW = attributes.NOW,
        clientOffset = attributes.clientOffset,
        availabilityStartTime = attributes.availabilityStartTime,
        _attributes$timescale = attributes.timescale,
        timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,
        _attributes$periodSta = attributes.periodStart,
        periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta,
        _attributes$minimumUp = attributes.minimumUpdatePeriod,
        minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;
    var now = (NOW + clientOffset) / 1000;
    var periodStartWC = availabilityStartTime + periodStart;
    var periodEndWC = now + minimumUpdatePeriod;
    var periodDuration = periodEndWC - periodStartWC;
    return Math.ceil((periodDuration * timescale - time) / duration);
  };
  var parseByTimeline = function parseByTimeline(attributes, segmentTimeline) {
    var type = attributes.type,
        _attributes$minimumUp2 = attributes.minimumUpdatePeriod,
        minimumUpdatePeriod = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2,
        _attributes$media = attributes.media,
        media = _attributes$media === void 0 ? '' : _attributes$media,
        sourceDuration = attributes.sourceDuration,
        _attributes$timescale2 = attributes.timescale,
        timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,
        _attributes$startNumb = attributes.startNumber,
        startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb,
        timeline = attributes.periodStart;
    var segments = [];
    var time = -1;
    for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {
      var S = segmentTimeline[sIndex];
      var duration = S.d;
      var repeat = S.r || 0;
      var segmentTime = S.t || 0;
      if (time < 0) {
        time = segmentTime;
      }
      if (segmentTime && segmentTime > time) {
        time = segmentTime;
      }
      var count = void 0;
      if (repeat < 0) {
        var nextS = sIndex + 1;
        if (nextS === segmentTimeline.length) {
          if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {
            count = getLiveRValue(attributes, time, duration);
          } else {
            count = (sourceDuration * timescale - time) / duration;
          }
        } else {
          count = (segmentTimeline[nextS].t - time) / duration;
        }
      } else {
        count = repeat + 1;
      }
      var end = startNumber + segments.length + count;
      var number = startNumber + segments.length;
      while (number < end) {
        segments.push({
          number: number,
          duration: duration / timescale,
          time: time,
          timeline: timeline
        });
        time += duration;
        number++;
      }
    }
    return segments;
  };
  var identifierPattern = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g;
  var identifierReplacement = function identifierReplacement(values) {
    return function (match, identifier, format, width) {
      if (match === '$$') {
        return '$';
      }
      if (typeof values[identifier] === 'undefined') {
        return match;
      }
      var value = '' + values[identifier];
      if (identifier === 'RepresentationID') {
        return value;
      }
      if (!format) {
        width = 1;
      } else {
        width = parseInt(width, 10);
      }
      if (value.length >= width) {
        return value;
      }
      return "" + new Array(width - value.length + 1).join('0') + value;
    };
  };
  var constructTemplateUrl = function constructTemplateUrl(url, values) {
    return url.replace(identifierPattern, identifierReplacement(values));
  };
  var parseTemplateInfo = function parseTemplateInfo(attributes, segmentTimeline) {
    if (!attributes.duration && !segmentTimeline) {
      return [{
        number: attributes.startNumber || 1,
        duration: attributes.sourceDuration,
        time: 0,
        timeline: attributes.periodStart
      }];
    }
    if (attributes.duration) {
      return parseByDuration(attributes);
    }
    return parseByTimeline(attributes, segmentTimeline);
  };
  var segmentsFromTemplate = function segmentsFromTemplate(attributes, segmentTimeline) {
    var templateValues = {
      RepresentationID: attributes.id,
      Bandwidth: attributes.bandwidth || 0
    };
    var _attributes$initializ = attributes.initialization,
        initialization = _attributes$initializ === void 0 ? {
      sourceURL: '',
      range: ''
    } : _attributes$initializ;
    var mapSegment = urlTypeToSegment({
      baseUrl: attributes.baseUrl,
      source: constructTemplateUrl(initialization.sourceURL, templateValues),
      range: initialization.range
    });
    var segments = parseTemplateInfo(attributes, segmentTimeline);
    return segments.map(function (segment) {
      templateValues.Number = segment.number;
      templateValues.Time = segment.time;
      var uri = constructTemplateUrl(attributes.media || '', templateValues);
      var timescale = attributes.timescale || 1;
      var presentationTimeOffset = attributes.presentationTimeOffset || 0;
      var presentationTime =
      attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;
      var map = {
        uri: uri,
        timeline: segment.timeline,
        duration: segment.duration,
        resolvedUri: resolveUrl$1(attributes.baseUrl || '', uri),
        map: mapSegment,
        number: segment.number,
        presentationTime: presentationTime
      };
      return map;
    });
  };
  var SegmentURLToSegmentObject = function SegmentURLToSegmentObject(attributes, segmentUrl) {
    var baseUrl = attributes.baseUrl,
        _attributes$initializ = attributes.initialization,
        initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;
    var initSegment = urlTypeToSegment({
      baseUrl: baseUrl,
      source: initialization.sourceURL,
      range: initialization.range
    });
    var segment = urlTypeToSegment({
      baseUrl: baseUrl,
      source: segmentUrl.media,
      range: segmentUrl.mediaRange
    });
    segment.map = initSegment;
    return segment;
  };
  var segmentsFromList = function segmentsFromList(attributes, segmentTimeline) {
    var duration = attributes.duration,
        _attributes$segmentUr = attributes.segmentUrls,
        segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr,
        periodStart = attributes.periodStart;
    if (!duration && !segmentTimeline || duration && segmentTimeline) {
      throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);
    }
    var segmentUrlMap = segmentUrls.map(function (segmentUrlObject) {
      return SegmentURLToSegmentObject(attributes, segmentUrlObject);
    });
    var segmentTimeInfo;
    if (duration) {
      segmentTimeInfo = parseByDuration(attributes);
    }
    if (segmentTimeline) {
      segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);
    }
    var segments = segmentTimeInfo.map(function (segmentTime, index) {
      if (segmentUrlMap[index]) {
        var segment = segmentUrlMap[index];
        var timescale = attributes.timescale || 1;
        var presentationTimeOffset = attributes.presentationTimeOffset || 0;
        segment.timeline = segmentTime.timeline;
        segment.duration = segmentTime.duration;
        segment.number = segmentTime.number;
        segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;
        return segment;
      }
    }).filter(function (segment) {
      return segment;
    });
    return segments;
  };
  var generateSegments = function generateSegments(_ref) {
    var attributes = _ref.attributes,
        segmentInfo = _ref.segmentInfo;
    var segmentAttributes;
    var segmentsFn;
    if (segmentInfo.template) {
      segmentsFn = segmentsFromTemplate;
      segmentAttributes = merge(attributes, segmentInfo.template);
    } else if (segmentInfo.base) {
      segmentsFn = segmentsFromBase;
      segmentAttributes = merge(attributes, segmentInfo.base);
    } else if (segmentInfo.list) {
      segmentsFn = segmentsFromList;
      segmentAttributes = merge(attributes, segmentInfo.list);
    }
    var segmentsInfo = {
      attributes: attributes
    };
    if (!segmentsFn) {
      return segmentsInfo;
    }
    var segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline);
    if (segmentAttributes.duration) {
      var _segmentAttributes = segmentAttributes,
          duration = _segmentAttributes.duration,
          _segmentAttributes$ti = _segmentAttributes.timescale,
          timescale = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;
      segmentAttributes.duration = duration / timescale;
    } else if (segments.length) {
      segmentAttributes.duration = segments.reduce(function (max, segment) {
        return Math.max(max, Math.ceil(segment.duration));
      }, 0);
    } else {
      segmentAttributes.duration = 0;
    }
    segmentsInfo.attributes = segmentAttributes;
    segmentsInfo.segments = segments;
    if (segmentInfo.base && segmentAttributes.indexRange) {
      segmentsInfo.sidx = segments[0];
      segmentsInfo.segments = [];
    }
    return segmentsInfo;
  };
  var toPlaylists = function toPlaylists(representations) {
    return representations.map(generateSegments);
  };
  var findChildren = function findChildren(element, name) {
    return from(element.childNodes).filter(function (_ref) {
      var tagName = _ref.tagName;
      return tagName === name;
    });
  };
  var getContent = function getContent(element) {
    return element.textContent.trim();
  };
  var parseDuration = function parseDuration(str) {
    var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
    var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;
    var SECONDS_IN_DAY = 24 * 60 * 60;
    var SECONDS_IN_HOUR = 60 * 60;
    var SECONDS_IN_MIN = 60;
    var durationRegex = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/;
    var match = durationRegex.exec(str);
    if (!match) {
      return 0;
    }
    var _match$slice = match.slice(1),
        year = _match$slice[0],
        month = _match$slice[1],
        day = _match$slice[2],
        hour = _match$slice[3],
        minute = _match$slice[4],
        second = _match$slice[5];
    return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);
  };
  var parseDate = function parseDate(str) {
    var dateRegex = /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/;
    if (dateRegex.test(str)) {
      str += 'Z';
    }
    return Date.parse(str);
  };
  var parsers = {
    mediaPresentationDuration: function mediaPresentationDuration(value) {
      return parseDuration(value);
    },
    availabilityStartTime: function availabilityStartTime(value) {
      return parseDate(value) / 1000;
    },
    minimumUpdatePeriod: function minimumUpdatePeriod(value) {
      return parseDuration(value);
    },
    suggestedPresentationDelay: function suggestedPresentationDelay(value) {
      return parseDuration(value);
    },
    type: function type(value) {
      return value;
    },
    timeShiftBufferDepth: function timeShiftBufferDepth(value) {
      return parseDuration(value);
    },
    start: function start(value) {
      return parseDuration(value);
    },
    width: function width(value) {
      return parseInt(value, 10);
    },
    height: function height(value) {
      return parseInt(value, 10);
    },
    bandwidth: function bandwidth(value) {
      return parseInt(value, 10);
    },
    startNumber: function startNumber(value) {
      return parseInt(value, 10);
    },
    timescale: function timescale(value) {
      return parseInt(value, 10);
    },
    presentationTimeOffset: function presentationTimeOffset(value) {
      return parseInt(value, 10);
    },
    duration: function duration(value) {
      var parsedValue = parseInt(value, 10);
      if (isNaN(parsedValue)) {
        return parseDuration(value);
      }
      return parsedValue;
    },
    d: function d(value) {
      return parseInt(value, 10);
    },
    t: function t(value) {
      return parseInt(value, 10);
    },
    r: function r(value) {
      return parseInt(value, 10);
    },
    DEFAULT: function DEFAULT(value) {
      return value;
    }
  };
  var parseAttributes = function parseAttributes(el) {
    if (!(el && el.attributes)) {
      return {};
    }
    return from(el.attributes).reduce(function (a, e) {
      var parseFn = parsers[e.name] || parsers.DEFAULT;
      a[e.name] = parseFn(e.value);
      return a;
    }, {});
  };
  var keySystemsMap = {
    'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',
    'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',
    'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',
    'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'
  };
  var buildBaseUrls = function buildBaseUrls(referenceUrls, baseUrlElements) {
    if (!baseUrlElements.length) {
      return referenceUrls;
    }
    return flatten(referenceUrls.map(function (reference) {
      return baseUrlElements.map(function (baseUrlElement) {
        return resolveUrl$1(reference, getContent(baseUrlElement));
      });
    }));
  };
  var getSegmentInformation = function getSegmentInformation(adaptationSet) {
    var segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];
    var segmentList = findChildren(adaptationSet, 'SegmentList')[0];
    var segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(function (s) {
      return merge({
        tag: 'SegmentURL'
      }, parseAttributes(s));
    });
    var segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];
    var segmentTimelineParentNode = segmentList || segmentTemplate;
    var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];
    var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;
    var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0];
    var template = segmentTemplate && parseAttributes(segmentTemplate);
    if (template && segmentInitialization) {
      template.initialization = segmentInitialization && parseAttributes(segmentInitialization);
    } else if (template && template.initialization) {
      template.initialization = {
        sourceURL: template.initialization
      };
    }
    var segmentInfo = {
      template: template,
      segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(function (s) {
        return parseAttributes(s);
      }),
      list: segmentList && merge(parseAttributes(segmentList), {
        segmentUrls: segmentUrls,
        initialization: parseAttributes(segmentInitialization)
      }),
      base: segmentBase && merge(parseAttributes(segmentBase), {
        initialization: parseAttributes(segmentInitialization)
      })
    };
    Object.keys(segmentInfo).forEach(function (key) {
      if (!segmentInfo[key]) {
        delete segmentInfo[key];
      }
    });
    return segmentInfo;
  };
  var inheritBaseUrls = function inheritBaseUrls(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {
    return function (representation) {
      var repBaseUrlElements = findChildren(representation, 'BaseURL');
      var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);
      var attributes = merge(adaptationSetAttributes, parseAttributes(representation));
      var representationSegmentInfo = getSegmentInformation(representation);
      return repBaseUrls.map(function (baseUrl) {
        return {
          segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),
          attributes: merge(attributes, {
            baseUrl: baseUrl
          })
        };
      });
    };
  };
  var generateKeySystemInformation = function generateKeySystemInformation(contentProtectionNodes) {
    return contentProtectionNodes.reduce(function (acc, node) {
      var attributes = parseAttributes(node);
      var keySystem = keySystemsMap[attributes.schemeIdUri];
      if (keySystem) {
        acc[keySystem] = {
          attributes: attributes
        };
        var psshNode = findChildren(node, 'cenc:pssh')[0];
        if (psshNode) {
          var pssh = getContent(psshNode);
          var psshBuffer = pssh && decodeB64ToUint8Array(pssh);
          acc[keySystem].pssh = psshBuffer;
        }
      }
      return acc;
    }, {});
  };
  var parseCaptionServiceMetadata = function parseCaptionServiceMetadata(service) {
    if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {
      var values = typeof service.value !== 'string' ? [] : service.value.split(';');
      return values.map(function (value) {
        var channel;
        var language;
        language = value;
        if (/^CC\d=/.test(value)) {
          var _value$split = value.split('=');
          channel = _value$split[0];
          language = _value$split[1];
        } else if (/^CC\d$/.test(value)) {
          channel = value;
        }
        return {
          channel: channel,
          language: language
        };
      });
    } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {
      var _values = typeof service.value !== 'string' ? [] : service.value.split(';');
      return _values.map(function (value) {
        var flags = {
          'channel': undefined,
          'language': undefined,
          'aspectRatio': 1,
          'easyReader': 0,
          '3D': 0
        };
        if (/=/.test(value)) {
          var _value$split2 = value.split('='),
              channel = _value$split2[0],
              _value$split2$ = _value$split2[1],
              opts = _value$split2$ === void 0 ? '' : _value$split2$;
          flags.channel = channel;
          flags.language = value;
          opts.split(',').forEach(function (opt) {
            var _opt$split = opt.split(':'),
                name = _opt$split[0],
                val = _opt$split[1];
            if (name === 'lang') {
              flags.language = val;
            } else if (name === 'er') {
              flags.easyReader = Number(val);
            } else if (name === 'war') {
              flags.aspectRatio = Number(val);
            } else if (name === '3D') {
              flags['3D'] = Number(val);
            }
          });
        } else {
          flags.language = value;
        }
        if (flags.channel) {
          flags.channel = 'SERVICE' + flags.channel;
        }
        return flags;
      });
    }
  };
  var toRepresentations = function toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo) {
    return function (adaptationSet) {
      var adaptationSetAttributes = parseAttributes(adaptationSet);
      var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));
      var role = findChildren(adaptationSet, 'Role')[0];
      var roleAttributes = {
        role: parseAttributes(role)
      };
      var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);
      var accessibility = findChildren(adaptationSet, 'Accessibility')[0];
      var captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));
      if (captionServices) {
        attrs = merge(attrs, {
          captionServices: captionServices
        });
      }
      var label = findChildren(adaptationSet, 'Label')[0];
      if (label && label.childNodes.length) {
        var labelVal = label.childNodes[0].nodeValue.trim();
        attrs = merge(attrs, {
          label: labelVal
        });
      }
      var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));
      if (Object.keys(contentProtection).length) {
        attrs = merge(attrs, {
          contentProtection: contentProtection
        });
      }
      var segmentInfo = getSegmentInformation(adaptationSet);
      var representations = findChildren(adaptationSet, 'Representation');
      var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);
      return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));
    };
  };
  var toAdaptationSets = function toAdaptationSets(mpdAttributes, mpdBaseUrls) {
    return function (period, index) {
      var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));
      var periodAttributes = merge(mpdAttributes, {
        periodStart: period.attributes.start
      });
      if (typeof period.attributes.duration === 'number') {
        periodAttributes.periodDuration = period.attributes.duration;
      }
      var adaptationSets = findChildren(period.node, 'AdaptationSet');
      var periodSegmentInfo = getSegmentInformation(period.node);
      return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));
    };
  };
  var getPeriodStart = function getPeriodStart(_ref) {
    var attributes = _ref.attributes,
        priorPeriodAttributes = _ref.priorPeriodAttributes,
        mpdType = _ref.mpdType;
    if (typeof attributes.start === 'number') {
      return attributes.start;
    }
    if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {
      return priorPeriodAttributes.start + priorPeriodAttributes.duration;
    }
    if (!priorPeriodAttributes && mpdType === 'static') {
      return 0;
    }
    return null;
  };
  var inheritAttributes = function inheritAttributes(mpd, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options,
        _options$manifestUri = _options.manifestUri,
        manifestUri = _options$manifestUri === void 0 ? '' : _options$manifestUri,
        _options$NOW = _options.NOW,
        NOW = _options$NOW === void 0 ? Date.now() : _options$NOW,
        _options$clientOffset = _options.clientOffset,
        clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;
    var periodNodes = findChildren(mpd, 'Period');
    if (!periodNodes.length) {
      throw new Error(errors.INVALID_NUMBER_OF_PERIOD);
    }
    var locations = findChildren(mpd, 'Location');
    var mpdAttributes = parseAttributes(mpd);
    var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL'));
    mpdAttributes.type = mpdAttributes.type || 'static';
    mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;
    mpdAttributes.NOW = NOW;
    mpdAttributes.clientOffset = clientOffset;
    if (locations.length) {
      mpdAttributes.locations = locations.map(getContent);
    }
    var periods = [];
    periodNodes.forEach(function (node, index) {
      var attributes = parseAttributes(node);
      var priorPeriod = periods[index - 1];
      attributes.start = getPeriodStart({
        attributes: attributes,
        priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,
        mpdType: mpdAttributes.type
      });
      periods.push({
        node: node,
        attributes: attributes
      });
    });
    return {
      locations: mpdAttributes.locations,
      representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))
    };
  };
  var stringToMpdXml = function stringToMpdXml(manifestString) {
    if (manifestString === '') {
      throw new Error(errors.DASH_EMPTY_MANIFEST);
    }
    var parser = new DOMParser();
    var xml;
    var mpd;
    try {
      xml = parser.parseFromString(manifestString, 'application/xml');
      mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;
    } catch (e) {
    }
    if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {
      throw new Error(errors.DASH_INVALID_XML);
    }
    return mpd;
  };
  var parseUTCTimingScheme = function parseUTCTimingScheme(mpd) {
    var UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];
    if (!UTCTimingNode) {
      return null;
    }
    var attributes = parseAttributes(UTCTimingNode);
    switch (attributes.schemeIdUri) {
      case 'urn:mpeg:dash:utc:http-head:2014':
      case 'urn:mpeg:dash:utc:http-head:2012':
        attributes.method = 'HEAD';
        break;
      case 'urn:mpeg:dash:utc:http-xsdate:2014':
      case 'urn:mpeg:dash:utc:http-iso:2014':
      case 'urn:mpeg:dash:utc:http-xsdate:2012':
      case 'urn:mpeg:dash:utc:http-iso:2012':
        attributes.method = 'GET';
        break;
      case 'urn:mpeg:dash:utc:direct:2014':
      case 'urn:mpeg:dash:utc:direct:2012':
        attributes.method = 'DIRECT';
        attributes.value = Date.parse(attributes.value);
        break;
      case 'urn:mpeg:dash:utc:http-ntp:2014':
      case 'urn:mpeg:dash:utc:ntp:2014':
      case 'urn:mpeg:dash:utc:sntp:2014':
      default:
        throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);
    }
    return attributes;
  };
  var parse = function parse(manifestString, options) {
    if (options === void 0) {
      options = {};
    }
    var parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);
    var playlists = toPlaylists(parsedManifestInfo.representationInfo);
    return toM3u8({
      dashPlaylists: playlists,
      locations: parsedManifestInfo.locations,
      sidxMapping: options.sidxMapping,
      previousManifest: options.previousManifest
    });
  };
  var parseUTCTiming = function parseUTCTiming(manifestString) {
    return parseUTCTimingScheme(stringToMpdXml(manifestString));
  };
  var MAX_UINT32 = Math.pow(2, 32);
  var getUint64$1 = function getUint64(uint8) {
    var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
    var value;
    if (dv.getBigUint64) {
      value = dv.getBigUint64(0);
      if (value < Number.MAX_SAFE_INTEGER) {
        return Number(value);
      }
      return value;
    }
    return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);
  };
  var numbers = {
    getUint64: getUint64$1,
    MAX_UINT32: MAX_UINT32
  };
  var getUint64 = numbers.getUint64;
  var parseSidx = function parseSidx(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      references: [],
      referenceId: view.getUint32(4),
      timescale: view.getUint32(8)
    },
        i = 12;
    if (result.version === 0) {
      result.earliestPresentationTime = view.getUint32(i);
      result.firstOffset = view.getUint32(i + 4);
      i += 8;
    } else {
      result.earliestPresentationTime = getUint64(data.subarray(i));
      result.firstOffset = getUint64(data.subarray(i + 8));
      i += 16;
    }
    i += 2;
    var referenceCount = view.getUint16(i);
    i += 2;
    for (; referenceCount > 0; i += 12, referenceCount--) {
      result.references.push({
        referenceType: (data[i] & 0x80) >>> 7,
        referencedSize: view.getUint32(i) & 0x7FFFFFFF,
        subsegmentDuration: view.getUint32(i + 4),
        startsWithSap: !!(data[i + 8] & 0x80),
        sapType: (data[i + 8] & 0x70) >>> 4,
        sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF
      });
    }
    return result;
  };
  var parseSidx_1 = parseSidx;
  var countBits = function countBits(x) {
    return x.toString(2).length;
  };
  var countBytes = function countBytes(x) {
    return Math.ceil(countBits(x) / 8);
  };
  var isTypedArray = function isTypedArray(obj) {
    return ArrayBuffer.isView(obj);
  };
  var toUint8 = function toUint8(bytes) {
    if (bytes instanceof Uint8Array) {
      return bytes;
    }
    if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {
      if (typeof bytes !== 'number' || typeof bytes === 'number' && bytes !== bytes) {
        bytes = 0;
      } else {
        bytes = [bytes];
      }
    }
    return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);
  };
  var BigInt = window.BigInt || Number;
  var BYTE_TABLE = [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];
  var bytesToNumber = function bytesToNumber(bytes, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$signed = _ref.signed,
        signed = _ref$signed === void 0 ? false : _ref$signed,
        _ref$le = _ref.le,
        le = _ref$le === void 0 ? false : _ref$le;
    bytes = toUint8(bytes);
    var fn = le ? 'reduce' : 'reduceRight';
    var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];
    var number = obj.call(bytes, function (total, _byte, i) {
      var exponent = le ? i : Math.abs(i + 1 - bytes.length);
      return total + BigInt(_byte) * BYTE_TABLE[exponent];
    }, BigInt(0));
    if (signed) {
      var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);
      number = BigInt(number);
      if (number > max) {
        number -= max;
        number -= max;
        number -= BigInt(2);
      }
    }
    return Number(number);
  };
  var numberToBytes = function numberToBytes(number, _temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        _ref2$le = _ref2.le,
        le = _ref2$le === void 0 ? false : _ref2$le;
    if (typeof number !== 'bigint' && typeof number !== 'number' || typeof number === 'number' && number !== number) {
      number = 0;
    }
    number = BigInt(number);
    var byteCount = countBytes(number);
    var bytes = new Uint8Array(new ArrayBuffer(byteCount));
    for (var i = 0; i < byteCount; i++) {
      var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);
      bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(0xFF));
      if (number < 0) {
        bytes[byteIndex] = Math.abs(~bytes[byteIndex]);
        bytes[byteIndex] -= i === 0 ? 1 : 2;
      }
    }
    return bytes;
  };
  var stringToBytes = function stringToBytes(string, stringIsBytes) {
    if (typeof string !== 'string' && string && typeof string.toString === 'function') {
      string = string.toString();
    }
    if (typeof string !== 'string') {
      return new Uint8Array();
    }
    if (!stringIsBytes) {
      string = unescape(encodeURIComponent(string));
    }
    var view = new Uint8Array(string.length);
    for (var i = 0; i < string.length; i++) {
      view[i] = string.charCodeAt(i);
    }
    return view;
  };
  var concatTypedArrays = function concatTypedArrays() {
    for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {
      buffers[_key] = arguments[_key];
    }
    buffers = buffers.filter(function (b) {
      return b && (b.byteLength || b.length) && typeof b !== 'string';
    });
    if (buffers.length <= 1) {
      return toUint8(buffers[0]);
    }
    var totalLen = buffers.reduce(function (total, buf, i) {
      return total + (buf.byteLength || buf.length);
    }, 0);
    var tempBuffer = new Uint8Array(totalLen);
    var offset = 0;
    buffers.forEach(function (buf) {
      buf = toUint8(buf);
      tempBuffer.set(buf, offset);
      offset += buf.byteLength;
    });
    return tempBuffer;
  };
  var bytesMatch = function bytesMatch(a, b, _temp3) {
    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        _ref3$offset = _ref3.offset,
        offset = _ref3$offset === void 0 ? 0 : _ref3$offset,
        _ref3$mask = _ref3.mask,
        mask = _ref3$mask === void 0 ? [] : _ref3$mask;
    a = toUint8(a);
    b = toUint8(b);
    var fn = b.every ? b.every : Array.prototype.every;
    return b.length && a.length - offset >= b.length &&
    fn.call(b, function (bByte, i) {
      var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];
      return bByte === aByte;
    });
  };
  var ID3 = toUint8([0x49, 0x44, 0x33]);
  var getId3Size = function getId3Size(bytes, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    bytes = toUint8(bytes);
    var flags = bytes[offset + 5];
    var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];
    var footerPresent = (flags & 16) >> 4;
    if (footerPresent) {
      return returnSize + 20;
    }
    return returnSize + 10;
  };
  var getId3Offset = function getId3Offset(bytes, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    bytes = toUint8(bytes);
    if (bytes.length - offset < 10 || !bytesMatch(bytes, ID3, {
      offset: offset
    })) {
      return offset;
    }
    offset += getId3Size(bytes, offset);
    return getId3Offset(bytes, offset);
  };
  var normalizePath$1 = function normalizePath(path) {
    if (typeof path === 'string') {
      return stringToBytes(path);
    }
    if (typeof path === 'number') {
      return path;
    }
    return path;
  };
  var normalizePaths$1 = function normalizePaths(paths) {
    if (!Array.isArray(paths)) {
      return [normalizePath$1(paths)];
    }
    return paths.map(function (p) {
      return normalizePath$1(p);
    });
  };
  var findBox = function findBox(bytes, paths, complete) {
    if (complete === void 0) {
      complete = false;
    }
    paths = normalizePaths$1(paths);
    bytes = toUint8(bytes);
    var results = [];
    if (!paths.length) {
      return results;
    }
    var i = 0;
    while (i < bytes.length) {
      var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;
      var type = bytes.subarray(i + 4, i + 8);
      if (size === 0) {
        break;
      }
      var end = i + size;
      if (end > bytes.length) {
        if (complete) {
          break;
        }
        end = bytes.length;
      }
      var data = bytes.subarray(i + 8, end);
      if (bytesMatch(type, paths[0])) {
        if (paths.length === 1) {
          results.push(data);
        } else {
          results.push.apply(results, findBox(data, paths.slice(1), complete));
        }
      }
      i = end;
    }
    return results;
  };
  var EBML_TAGS = {
    EBML: toUint8([0x1A, 0x45, 0xDF, 0xA3]),
    DocType: toUint8([0x42, 0x82]),
    Segment: toUint8([0x18, 0x53, 0x80, 0x67]),
    SegmentInfo: toUint8([0x15, 0x49, 0xA9, 0x66]),
    Tracks: toUint8([0x16, 0x54, 0xAE, 0x6B]),
    Track: toUint8([0xAE]),
    TrackNumber: toUint8([0xd7]),
    DefaultDuration: toUint8([0x23, 0xe3, 0x83]),
    TrackEntry: toUint8([0xAE]),
    TrackType: toUint8([0x83]),
    FlagDefault: toUint8([0x88]),
    CodecID: toUint8([0x86]),
    CodecPrivate: toUint8([0x63, 0xA2]),
    VideoTrack: toUint8([0xe0]),
    AudioTrack: toUint8([0xe1]),
    Cluster: toUint8([0x1F, 0x43, 0xB6, 0x75]),
    Timestamp: toUint8([0xE7]),
    TimestampScale: toUint8([0x2A, 0xD7, 0xB1]),
    BlockGroup: toUint8([0xA0]),
    BlockDuration: toUint8([0x9B]),
    Block: toUint8([0xA1]),
    SimpleBlock: toUint8([0xA3])
  };
  var LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];
  var getLength = function getLength(_byte) {
    var len = 1;
    for (var i = 0; i < LENGTH_TABLE.length; i++) {
      if (_byte & LENGTH_TABLE[i]) {
        break;
      }
      len++;
    }
    return len;
  };
  var getvint = function getvint(bytes, offset, removeLength, signed) {
    if (removeLength === void 0) {
      removeLength = true;
    }
    if (signed === void 0) {
      signed = false;
    }
    var length = getLength(bytes[offset]);
    var valueBytes = bytes.subarray(offset, offset + length);
    if (removeLength) {
      valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);
      valueBytes[0] ^= LENGTH_TABLE[length - 1];
    }
    return {
      length: length,
      value: bytesToNumber(valueBytes, {
        signed: signed
      }),
      bytes: valueBytes
    };
  };
  var normalizePath = function normalizePath(path) {
    if (typeof path === 'string') {
      return path.match(/.{1,2}/g).map(function (p) {
        return normalizePath(p);
      });
    }
    if (typeof path === 'number') {
      return numberToBytes(path);
    }
    return path;
  };
  var normalizePaths = function normalizePaths(paths) {
    if (!Array.isArray(paths)) {
      return [normalizePath(paths)];
    }
    return paths.map(function (p) {
      return normalizePath(p);
    });
  };
  var getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {
    if (offset >= bytes.length) {
      return bytes.length;
    }
    var innerid = getvint(bytes, offset, false);
    if (bytesMatch(id.bytes, innerid.bytes)) {
      return offset;
    }
    var dataHeader = getvint(bytes, offset + innerid.length);
    return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);
  };
  var findEbml = function findEbml(bytes, paths) {
    paths = normalizePaths(paths);
    bytes = toUint8(bytes);
    var results = [];
    if (!paths.length) {
      return results;
    }
    var i = 0;
    while (i < bytes.length) {
      var id = getvint(bytes, i, false);
      var dataHeader = getvint(bytes, i + id.length);
      var dataStart = i + id.length + dataHeader.length;
      if (dataHeader.value === 0x7f) {
        dataHeader.value = getInfinityDataSize(id, bytes, dataStart);
        if (dataHeader.value !== bytes.length) {
          dataHeader.value -= dataStart;
        }
      }
      var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;
      var data = bytes.subarray(dataStart, dataEnd);
      if (bytesMatch(paths[0], id.bytes)) {
        if (paths.length === 1) {
          results.push(data);
        } else {
          results = results.concat(findEbml(data, paths.slice(1)));
        }
      }
      var totalLength = id.length + dataHeader.length + data.length;
      i += totalLength;
    }
    return results;
  };
  var NAL_TYPE_ONE = toUint8([0x00, 0x00, 0x00, 0x01]);
  var NAL_TYPE_TWO = toUint8([0x00, 0x00, 0x01]);
  var EMULATION_PREVENTION = toUint8([0x00, 0x00, 0x03]);
  var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {
    var positions = [];
    var i = 1;
    while (i < bytes.length - 2) {
      if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {
        positions.push(i + 2);
        i++;
      }
      i++;
    }
    if (positions.length === 0) {
      return bytes;
    }
    var newLength = bytes.length - positions.length;
    var newData = new Uint8Array(newLength);
    var sourceIndex = 0;
    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === positions[0]) {
        sourceIndex++;
        positions.shift();
      }
      newData[i] = bytes[sourceIndex];
    }
    return newData;
  };
  var findNal = function findNal(bytes, dataType, types, nalLimit) {
    if (nalLimit === void 0) {
      nalLimit = Infinity;
    }
    bytes = toUint8(bytes);
    types = [].concat(types);
    var i = 0;
    var nalStart;
    var nalsFound = 0;
    while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {
      var nalOffset = void 0;
      if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {
        nalOffset = 4;
      } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {
        nalOffset = 3;
      }
      if (!nalOffset) {
        i++;
        continue;
      }
      nalsFound++;
      if (nalStart) {
        return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));
      }
      var nalType = void 0;
      if (dataType === 'h264') {
        nalType = bytes[i + nalOffset] & 0x1f;
      } else if (dataType === 'h265') {
        nalType = bytes[i + nalOffset] >> 1 & 0x3f;
      }
      if (types.indexOf(nalType) !== -1) {
        nalStart = i + nalOffset;
      }
      i += nalOffset + (dataType === 'h264' ? 1 : 2);
    }
    return bytes.subarray(0, 0);
  };
  var findH264Nal = function findH264Nal(bytes, type, nalLimit) {
    return findNal(bytes, 'h264', type, nalLimit);
  };
  var findH265Nal = function findH265Nal(bytes, type, nalLimit) {
    return findNal(bytes, 'h265', type, nalLimit);
  };
  var CONSTANTS = {
    'webm': toUint8([0x77, 0x65, 0x62, 0x6d]),
    'matroska': toUint8([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),
    'flac': toUint8([0x66, 0x4c, 0x61, 0x43]),
    'ogg': toUint8([0x4f, 0x67, 0x67, 0x53]),
    'ac3': toUint8([0x0b, 0x77]),
    'riff': toUint8([0x52, 0x49, 0x46, 0x46]),
    'avi': toUint8([0x41, 0x56, 0x49]),
    'wav': toUint8([0x57, 0x41, 0x56, 0x45]),
    '3gp': toUint8([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),
    'mp4': toUint8([0x66, 0x74, 0x79, 0x70]),
    'fmp4': toUint8([0x73, 0x74, 0x79, 0x70]),
    'mov': toUint8([0x66, 0x74, 0x79, 0x70, 0x71, 0x74]),
    'moov': toUint8([0x6D, 0x6F, 0x6F, 0x76]),
    'moof': toUint8([0x6D, 0x6F, 0x6F, 0x66])
  };
  var _isLikely = {
    aac: function aac(bytes) {
      var offset = getId3Offset(bytes);
      return bytesMatch(bytes, [0xFF, 0x10], {
        offset: offset,
        mask: [0xFF, 0x16]
      });
    },
    mp3: function mp3(bytes) {
      var offset = getId3Offset(bytes);
      return bytesMatch(bytes, [0xFF, 0x02], {
        offset: offset,
        mask: [0xFF, 0x06]
      });
    },
    webm: function webm(bytes) {
      var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
      return bytesMatch(docType, CONSTANTS.webm);
    },
    mkv: function mkv(bytes) {
      var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
      return bytesMatch(docType, CONSTANTS.matroska);
    },
    mp4: function mp4(bytes) {
      if (_isLikely['3gp'](bytes) || _isLikely.mov(bytes)) {
        return false;
      }
      if (bytesMatch(bytes, CONSTANTS.mp4, {
        offset: 4
      }) || bytesMatch(bytes, CONSTANTS.fmp4, {
        offset: 4
      })) {
        return true;
      }
      if (bytesMatch(bytes, CONSTANTS.moof, {
        offset: 4
      }) || bytesMatch(bytes, CONSTANTS.moov, {
        offset: 4
      })) {
        return true;
      }
    },
    mov: function mov(bytes) {
      return bytesMatch(bytes, CONSTANTS.mov, {
        offset: 4
      });
    },
    '3gp': function gp(bytes) {
      return bytesMatch(bytes, CONSTANTS['3gp'], {
        offset: 4
      });
    },
    ac3: function ac3(bytes) {
      var offset = getId3Offset(bytes);
      return bytesMatch(bytes, CONSTANTS.ac3, {
        offset: offset
      });
    },
    ts: function ts(bytes) {
      if (bytes.length < 189 && bytes.length >= 1) {
        return bytes[0] === 0x47;
      }
      var i = 0;
      while (i + 188 < bytes.length && i < 188) {
        if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {
          return true;
        }
        i += 1;
      }
      return false;
    },
    flac: function flac(bytes) {
      var offset = getId3Offset(bytes);
      return bytesMatch(bytes, CONSTANTS.flac, {
        offset: offset
      });
    },
    ogg: function ogg(bytes) {
      return bytesMatch(bytes, CONSTANTS.ogg);
    },
    avi: function avi(bytes) {
      return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {
        offset: 8
      });
    },
    wav: function wav(bytes) {
      return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {
        offset: 8
      });
    },
    'h264': function h264(bytes) {
      return findH264Nal(bytes, 7, 3).length;
    },
    'h265': function h265(bytes) {
      return findH265Nal(bytes, [32, 33], 3).length;
    }
  };
  var isLikelyTypes = Object.keys(_isLikely)
  .filter(function (t) {
    return t !== 'ts' && t !== 'h264' && t !== 'h265';
  })
  .concat(['ts', 'h264', 'h265']);
  isLikelyTypes.forEach(function (type) {
    var isLikelyFn = _isLikely[type];
    _isLikely[type] = function (bytes) {
      return isLikelyFn(toUint8(bytes));
    };
  });
  var isLikely = _isLikely;
  var detectContainerForBytes = function detectContainerForBytes(bytes) {
    bytes = toUint8(bytes);
    for (var i = 0; i < isLikelyTypes.length; i++) {
      var type = isLikelyTypes[i];
      if (isLikely[type](bytes)) {
        return type;
      }
    }
    return '';
  };
  var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {
    return findBox(bytes, ['moof']).length > 0;
  };
  var ONE_SECOND_IN_TS = 90000,
  secondsToVideoTs,
      secondsToAudioTs,
      videoTsToSeconds,
      audioTsToSeconds,
      audioTsToVideoTs,
      videoTsToAudioTs,
      metadataTsToSeconds;
  secondsToVideoTs = function secondsToVideoTs(seconds) {
    return seconds * ONE_SECOND_IN_TS;
  };
  secondsToAudioTs = function secondsToAudioTs(seconds, sampleRate) {
    return seconds * sampleRate;
  };
  videoTsToSeconds = function videoTsToSeconds(timestamp) {
    return timestamp / ONE_SECOND_IN_TS;
  };
  audioTsToSeconds = function audioTsToSeconds(timestamp, sampleRate) {
    return timestamp / sampleRate;
  };
  audioTsToVideoTs = function audioTsToVideoTs(timestamp, sampleRate) {
    return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
  };
  videoTsToAudioTs = function videoTsToAudioTs(timestamp, sampleRate) {
    return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
  };
  metadataTsToSeconds = function metadataTsToSeconds(timestamp, timelineStartPts, keepOriginalTimestamps) {
    return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
  };
  var clock = {
    ONE_SECOND_IN_TS: ONE_SECOND_IN_TS,
    secondsToVideoTs: secondsToVideoTs,
    secondsToAudioTs: secondsToAudioTs,
    videoTsToSeconds: videoTsToSeconds,
    audioTsToSeconds: audioTsToSeconds,
    audioTsToVideoTs: audioTsToVideoTs,
    videoTsToAudioTs: videoTsToAudioTs,
    metadataTsToSeconds: metadataTsToSeconds
  };
  var clock_1 = clock.ONE_SECOND_IN_TS;
  /*! @name @videojs/http-streaming @version 2.13.1 @license Apache-2.0 */
  var resolveUrl = resolveUrl$1;
  var resolveManifestRedirect = function resolveManifestRedirect(handleManifestRedirect, url, req) {
    if (handleManifestRedirect && req && req.responseURL && url !== req.responseURL) {
      return req.responseURL;
    }
    return url;
  };
  var logger = function logger(source) {
    if (videojs.log.debug) {
      return videojs.log.debug.bind(videojs, 'VHS:', source + " >");
    }
    return function () {};
  };
  var TIME_FUDGE_FACTOR = 1 / 30;
  var SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;
  var filterRanges = function filterRanges(timeRanges, predicate) {
    var results = [];
    var i;
    if (timeRanges && timeRanges.length) {
      for (i = 0; i < timeRanges.length; i++) {
        if (predicate(timeRanges.start(i), timeRanges.end(i))) {
          results.push([timeRanges.start(i), timeRanges.end(i)]);
        }
      }
    }
    return videojs.createTimeRanges(results);
  };
  var findRange = function findRange(buffered, time) {
    return filterRanges(buffered, function (start, end) {
      return start - SAFE_TIME_DELTA <= time && end + SAFE_TIME_DELTA >= time;
    });
  };
  var findNextRange = function findNextRange(timeRanges, time) {
    return filterRanges(timeRanges, function (start) {
      return start - TIME_FUDGE_FACTOR >= time;
    });
  };
  var findGaps = function findGaps(buffered) {
    if (buffered.length < 2) {
      return videojs.createTimeRanges();
    }
    var ranges = [];
    for (var i = 1; i < buffered.length; i++) {
      var start = buffered.end(i - 1);
      var end = buffered.start(i);
      ranges.push([start, end]);
    }
    return videojs.createTimeRanges(ranges);
  };
  var bufferIntersection = function bufferIntersection(bufferA, bufferB) {
    var start = null;
    var end = null;
    var arity = 0;
    var extents = [];
    var ranges = [];
    if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {
      return videojs.createTimeRange();
    }
    var count = bufferA.length;
    while (count--) {
      extents.push({
        time: bufferA.start(count),
        type: 'start'
      });
      extents.push({
        time: bufferA.end(count),
        type: 'end'
      });
    }
    count = bufferB.length;
    while (count--) {
      extents.push({
        time: bufferB.start(count),
        type: 'start'
      });
      extents.push({
        time: bufferB.end(count),
        type: 'end'
      });
    }
    extents.sort(function (a, b) {
      return a.time - b.time;
    });
    for (count = 0; count < extents.length; count++) {
      if (extents[count].type === 'start') {
        arity++;
        if (arity === 2) {
          start = extents[count].time;
        }
      } else if (extents[count].type === 'end') {
        arity--;
        if (arity === 1) {
          end = extents[count].time;
        }
      }
      if (start !== null && end !== null) {
        ranges.push([start, end]);
        start = null;
        end = null;
      }
    }
    return videojs.createTimeRanges(ranges);
  };
  var printableRange = function printableRange(range) {
    var strArr = [];
    if (!range || !range.length) {
      return '';
    }
    for (var i = 0; i < range.length; i++) {
      strArr.push(range.start(i) + ' => ' + range.end(i));
    }
    return strArr.join(', ');
  };
  var timeUntilRebuffer = function timeUntilRebuffer(buffered, currentTime, playbackRate) {
    if (playbackRate === void 0) {
      playbackRate = 1;
    }
    var bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;
    return (bufferedEnd - currentTime) / playbackRate;
  };
  var timeRangesToArray = function timeRangesToArray(timeRanges) {
    var timeRangesList = [];
    for (var i = 0; i < timeRanges.length; i++) {
      timeRangesList.push({
        start: timeRanges.start(i),
        end: timeRanges.end(i)
      });
    }
    return timeRangesList;
  };
  var isRangeDifferent = function isRangeDifferent(a, b) {
    if (a === b) {
      return false;
    }
    if (!a && b || !b && a) {
      return true;
    }
    if (a.length !== b.length) {
      return true;
    }
    for (var i = 0; i < a.length; i++) {
      if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) {
        return true;
      }
    }
    return false;
  };
  var lastBufferedEnd = function lastBufferedEnd(a) {
    if (!a || !a.length || !a.end) {
      return;
    }
    return a.end(a.length - 1);
  };
  var timeAheadOf = function timeAheadOf(range, startTime) {
    var time = 0;
    if (!range || !range.length) {
      return time;
    }
    for (var i = 0; i < range.length; i++) {
      var start = range.start(i);
      var end = range.end(i);
      if (startTime > end) {
        continue;
      }
      if (startTime > start && startTime <= end) {
        time += end - startTime;
        continue;
      }
      time += end - start;
    }
    return time;
  };
  var createTimeRange = videojs.createTimeRange;
  var segmentDurationWithParts = function segmentDurationWithParts(playlist, segment) {
    if (!segment.preload) {
      return segment.duration;
    }
    var result = 0;
    (segment.parts || []).forEach(function (p) {
      result += p.duration;
    });
    (segment.preloadHints || []).forEach(function (p) {
      if (p.type === 'PART') {
        result += playlist.partTargetDuration;
      }
    });
    return result;
  };
  var getPartsAndSegments = function getPartsAndSegments(playlist) {
    return (playlist.segments || []).reduce(function (acc, segment, si) {
      if (segment.parts) {
        segment.parts.forEach(function (part, pi) {
          acc.push({
            duration: part.duration,
            segmentIndex: si,
            partIndex: pi,
            part: part,
            segment: segment
          });
        });
      } else {
        acc.push({
          duration: segment.duration,
          segmentIndex: si,
          partIndex: null,
          segment: segment,
          part: null
        });
      }
      return acc;
    }, []);
  };
  var getLastParts = function getLastParts(media) {
    var lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];
    return lastSegment && lastSegment.parts || [];
  };
  var getKnownPartCount = function getKnownPartCount(_ref) {
    var preloadSegment = _ref.preloadSegment;
    if (!preloadSegment) {
      return;
    }
    var parts = preloadSegment.parts,
        preloadHints = preloadSegment.preloadHints;
    var partCount = (preloadHints || []).reduce(function (count, hint) {
      return count + (hint.type === 'PART' ? 1 : 0);
    }, 0);
    partCount += parts && parts.length ? parts.length : 0;
    return partCount;
  };
  var liveEdgeDelay = function liveEdgeDelay(master, media) {
    if (media.endList) {
      return 0;
    }
    if (master && master.suggestedPresentationDelay) {
      return master.suggestedPresentationDelay;
    }
    var hasParts = getLastParts(media).length > 0;
    if (hasParts && media.serverControl && media.serverControl.partHoldBack) {
      return media.serverControl.partHoldBack;
    } else if (hasParts && media.partTargetDuration) {
      return media.partTargetDuration * 3;
    } else if (media.serverControl && media.serverControl.holdBack) {
      return media.serverControl.holdBack;
    } else if (media.targetDuration) {
      return media.targetDuration * 3;
    }
    return 0;
  };
  var backwardDuration = function backwardDuration(playlist, endSequence) {
    var result = 0;
    var i = endSequence - playlist.mediaSequence;
    var segment = playlist.segments[i];
    if (segment) {
      if (typeof segment.start !== 'undefined') {
        return {
          result: segment.start,
          precise: true
        };
      }
      if (typeof segment.end !== 'undefined') {
        return {
          result: segment.end - segment.duration,
          precise: true
        };
      }
    }
    while (i--) {
      segment = playlist.segments[i];
      if (typeof segment.end !== 'undefined') {
        return {
          result: result + segment.end,
          precise: true
        };
      }
      result += segmentDurationWithParts(playlist, segment);
      if (typeof segment.start !== 'undefined') {
        return {
          result: result + segment.start,
          precise: true
        };
      }
    }
    return {
      result: result,
      precise: false
    };
  };
  var forwardDuration = function forwardDuration(playlist, endSequence) {
    var result = 0;
    var segment;
    var i = endSequence - playlist.mediaSequence;
    for (; i < playlist.segments.length; i++) {
      segment = playlist.segments[i];
      if (typeof segment.start !== 'undefined') {
        return {
          result: segment.start - result,
          precise: true
        };
      }
      result += segmentDurationWithParts(playlist, segment);
      if (typeof segment.end !== 'undefined') {
        return {
          result: segment.end - result,
          precise: true
        };
      }
    }
    return {
      result: -1,
      precise: false
    };
  };
  var intervalDuration = function intervalDuration(playlist, endSequence, expired) {
    if (typeof endSequence === 'undefined') {
      endSequence = playlist.mediaSequence + playlist.segments.length;
    }
    if (endSequence < playlist.mediaSequence) {
      return 0;
    }
    var backward = backwardDuration(playlist, endSequence);
    if (backward.precise) {
      return backward.result;
    }
    var forward = forwardDuration(playlist, endSequence);
    if (forward.precise) {
      return forward.result;
    }
    return backward.result + expired;
  };
  var duration = function duration(playlist, endSequence, expired) {
    if (!playlist) {
      return 0;
    }
    if (typeof expired !== 'number') {
      expired = 0;
    }
    if (typeof endSequence === 'undefined') {
      if (playlist.totalDuration) {
        return playlist.totalDuration;
      }
      if (!playlist.endList) {
        return window.Infinity;
      }
    }
    return intervalDuration(playlist, endSequence, expired);
  };
  var sumDurations = function sumDurations(_ref2) {
    var defaultDuration = _ref2.defaultDuration,
        durationList = _ref2.durationList,
        startIndex = _ref2.startIndex,
        endIndex = _ref2.endIndex;
    var durations = 0;
    if (startIndex > endIndex) {
      var _ref3 = [endIndex, startIndex];
      startIndex = _ref3[0];
      endIndex = _ref3[1];
    }
    if (startIndex < 0) {
      for (var i = startIndex; i < Math.min(0, endIndex); i++) {
        durations += defaultDuration;
      }
      startIndex = 0;
    }
    for (var _i = startIndex; _i < endIndex; _i++) {
      durations += durationList[_i].duration;
    }
    return durations;
  };
  var playlistEnd = function playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding) {
    if (!playlist || !playlist.segments) {
      return null;
    }
    if (playlist.endList) {
      return duration(playlist);
    }
    if (expired === null) {
      return null;
    }
    expired = expired || 0;
    var lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);
    if (useSafeLiveEnd) {
      liveEdgePadding = typeof liveEdgePadding === 'number' ? liveEdgePadding : liveEdgeDelay(null, playlist);
      lastSegmentEndTime -= liveEdgePadding;
    }
    return Math.max(0, lastSegmentEndTime);
  };
  var seekable = function seekable(playlist, expired, liveEdgePadding) {
    var useSafeLiveEnd = true;
    var seekableStart = expired || 0;
    var seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);
    if (seekableEnd === null) {
      return createTimeRange();
    }
    return createTimeRange(seekableStart, seekableEnd);
  };
  var getMediaInfoForTime = function getMediaInfoForTime(_ref4) {
    var playlist = _ref4.playlist,
        currentTime = _ref4.currentTime,
        startingSegmentIndex = _ref4.startingSegmentIndex,
        startingPartIndex = _ref4.startingPartIndex,
        startTime = _ref4.startTime,
        experimentalExactManifestTimings = _ref4.experimentalExactManifestTimings;
    var time = currentTime - startTime;
    var partsAndSegments = getPartsAndSegments(playlist);
    var startIndex = 0;
    for (var i = 0; i < partsAndSegments.length; i++) {
      var partAndSegment = partsAndSegments[i];
      if (startingSegmentIndex !== partAndSegment.segmentIndex) {
        continue;
      }
      if (typeof startingPartIndex === 'number' && typeof partAndSegment.partIndex === 'number' && startingPartIndex !== partAndSegment.partIndex) {
        continue;
      }
      startIndex = i;
      break;
    }
    if (time < 0) {
      if (startIndex > 0) {
        for (var _i2 = startIndex - 1; _i2 >= 0; _i2--) {
          var _partAndSegment = partsAndSegments[_i2];
          time += _partAndSegment.duration;
          if (experimentalExactManifestTimings) {
            if (time < 0) {
              continue;
            }
          } else if (time + TIME_FUDGE_FACTOR <= 0) {
            continue;
          }
          return {
            partIndex: _partAndSegment.partIndex,
            segmentIndex: _partAndSegment.segmentIndex,
            startTime: startTime - sumDurations({
              defaultDuration: playlist.targetDuration,
              durationList: partsAndSegments,
              startIndex: startIndex,
              endIndex: _i2
            })
          };
        }
      }
      return {
        partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
        segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
        startTime: currentTime
      };
    }
    if (startIndex < 0) {
      for (var _i3 = startIndex; _i3 < 0; _i3++) {
        time -= playlist.targetDuration;
        if (time < 0) {
          return {
            partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
            segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
            startTime: currentTime
          };
        }
      }
      startIndex = 0;
    }
    for (var _i4 = startIndex; _i4 < partsAndSegments.length; _i4++) {
      var _partAndSegment2 = partsAndSegments[_i4];
      time -= _partAndSegment2.duration;
      if (experimentalExactManifestTimings) {
        if (time > 0) {
          continue;
        }
      } else if (time - TIME_FUDGE_FACTOR >= 0) {
        continue;
      }
      return {
        partIndex: _partAndSegment2.partIndex,
        segmentIndex: _partAndSegment2.segmentIndex,
        startTime: startTime + sumDurations({
          defaultDuration: playlist.targetDuration,
          durationList: partsAndSegments,
          startIndex: startIndex,
          endIndex: _i4
        })
      };
    }
    return {
      segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,
      partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,
      startTime: currentTime
    };
  };
  var isBlacklisted = function isBlacklisted(playlist) {
    return playlist.excludeUntil && playlist.excludeUntil > Date.now();
  };
  var isIncompatible = function isIncompatible(playlist) {
    return playlist.excludeUntil && playlist.excludeUntil === Infinity;
  };
  var isEnabled = function isEnabled(playlist) {
    var blacklisted = isBlacklisted(playlist);
    return !playlist.disabled && !blacklisted;
  };
  var isDisabled = function isDisabled(playlist) {
    return playlist.disabled;
  };
  var isAes = function isAes(media) {
    for (var i = 0; i < media.segments.length; i++) {
      if (media.segments[i].key) {
        return true;
      }
    }
    return false;
  };
  var hasAttribute = function hasAttribute(attr, playlist) {
    return playlist.attributes && playlist.attributes[attr];
  };
  var estimateSegmentRequestTime = function estimateSegmentRequestTime(segmentDuration, bandwidth, playlist, bytesReceived) {
    if (bytesReceived === void 0) {
      bytesReceived = 0;
    }
    if (!hasAttribute('BANDWIDTH', playlist)) {
      return NaN;
    }
    var size = segmentDuration * playlist.attributes.BANDWIDTH;
    return (size - bytesReceived * 8) / bandwidth;
  };
  var isLowestEnabledRendition = function isLowestEnabledRendition(master, media) {
    if (master.playlists.length === 1) {
      return true;
    }
    var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;
    return master.playlists.filter(function (playlist) {
      if (!isEnabled(playlist)) {
        return false;
      }
      return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;
    }).length === 0;
  };
  var playlistMatch = function playlistMatch(a, b) {
    if (!a && !b || !a && b || a && !b) {
      return false;
    }
    if (a === b) {
      return true;
    }
    if (a.id && b.id && a.id === b.id) {
      return true;
    }
    if (a.resolvedUri && b.resolvedUri && a.resolvedUri === b.resolvedUri) {
      return true;
    }
    if (a.uri && b.uri && a.uri === b.uri) {
      return true;
    }
    return false;
  };
  var someAudioVariant = function someAudioVariant(master, callback) {
    var AUDIO = master && master.mediaGroups && master.mediaGroups.AUDIO || {};
    var found = false;
    for (var groupName in AUDIO) {
      for (var label in AUDIO[groupName]) {
        found = callback(AUDIO[groupName][label]);
        if (found) {
          break;
        }
      }
      if (found) {
        break;
      }
    }
    return !!found;
  };
  var isAudioOnly = function isAudioOnly(master) {
    if (!master || !master.playlists || !master.playlists.length) {
      var found = someAudioVariant(master, function (variant) {
        return variant.playlists && variant.playlists.length || variant.uri;
      });
      return found;
    }
    var _loop = function _loop(i) {
      var playlist = master.playlists[i];
      var CODECS = playlist.attributes && playlist.attributes.CODECS;
      if (CODECS && CODECS.split(',').every(function (c) {
        return isAudioCodec(c);
      })) {
        return "continue";
      }
      var found = someAudioVariant(master, function (variant) {
        return playlistMatch(playlist, variant);
      });
      if (found) {
        return "continue";
      }
      return {
        v: false
      };
    };
    for (var i = 0; i < master.playlists.length; i++) {
      var _ret = _loop(i);
      if (_ret === "continue") continue;
      if (typeof _ret === "object") return _ret.v;
    }
    return true;
  };
  var Playlist = {
    liveEdgeDelay: liveEdgeDelay,
    duration: duration,
    seekable: seekable,
    getMediaInfoForTime: getMediaInfoForTime,
    isEnabled: isEnabled,
    isDisabled: isDisabled,
    isBlacklisted: isBlacklisted,
    isIncompatible: isIncompatible,
    playlistEnd: playlistEnd,
    isAes: isAes,
    hasAttribute: hasAttribute,
    estimateSegmentRequestTime: estimateSegmentRequestTime,
    isLowestEnabledRendition: isLowestEnabledRendition,
    isAudioOnly: isAudioOnly,
    playlistMatch: playlistMatch,
    segmentDurationWithParts: segmentDurationWithParts
  };
  var log = videojs.log;
  var createPlaylistID = function createPlaylistID(index, uri) {
    return index + "-" + uri;
  };
  var parseManifest = function parseManifest(_ref) {
    var onwarn = _ref.onwarn,
        oninfo = _ref.oninfo,
        manifestString = _ref.manifestString,
        _ref$customTagParsers = _ref.customTagParsers,
        customTagParsers = _ref$customTagParsers === void 0 ? [] : _ref$customTagParsers,
        _ref$customTagMappers = _ref.customTagMappers,
        customTagMappers = _ref$customTagMappers === void 0 ? [] : _ref$customTagMappers,
        experimentalLLHLS = _ref.experimentalLLHLS;
    var parser = new Parser();
    if (onwarn) {
      parser.on('warn', onwarn);
    }
    if (oninfo) {
      parser.on('info', oninfo);
    }
    customTagParsers.forEach(function (customParser) {
      return parser.addParser(customParser);
    });
    customTagMappers.forEach(function (mapper) {
      return parser.addTagMapper(mapper);
    });
    parser.push(manifestString);
    parser.end();
    var manifest = parser.manifest;
    if (!experimentalLLHLS) {
      ['preloadSegment', 'skip', 'serverControl', 'renditionReports', 'partInf', 'partTargetDuration'].forEach(function (k) {
        if (manifest.hasOwnProperty(k)) {
          delete manifest[k];
        }
      });
      if (manifest.segments) {
        manifest.segments.forEach(function (segment) {
          ['parts', 'preloadHints'].forEach(function (k) {
            if (segment.hasOwnProperty(k)) {
              delete segment[k];
            }
          });
        });
      }
    }
    if (!manifest.targetDuration) {
      var targetDuration = 10;
      if (manifest.segments && manifest.segments.length) {
        targetDuration = manifest.segments.reduce(function (acc, s) {
          return Math.max(acc, s.duration);
        }, 0);
      }
      if (onwarn) {
        onwarn("manifest has no targetDuration defaulting to " + targetDuration);
      }
      manifest.targetDuration = targetDuration;
    }
    var parts = getLastParts(manifest);
    if (parts.length && !manifest.partTargetDuration) {
      var partTargetDuration = parts.reduce(function (acc, p) {
        return Math.max(acc, p.duration);
      }, 0);
      if (onwarn) {
        onwarn("manifest has no partTargetDuration defaulting to " + partTargetDuration);
        log.error('LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.');
      }
      manifest.partTargetDuration = partTargetDuration;
    }
    return manifest;
  };
  var forEachMediaGroup = function forEachMediaGroup(master, callback) {
    if (!master.mediaGroups) {
      return;
    }
    ['AUDIO', 'SUBTITLES'].forEach(function (mediaType) {
      if (!master.mediaGroups[mediaType]) {
        return;
      }
      for (var groupKey in master.mediaGroups[mediaType]) {
        for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
          var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
          callback(mediaProperties, mediaType, groupKey, labelKey);
        }
      }
    });
  };
  var setupMediaPlaylist = function setupMediaPlaylist(_ref2) {
    var playlist = _ref2.playlist,
        uri = _ref2.uri,
        id = _ref2.id;
    playlist.id = id;
    playlist.playlistErrors_ = 0;
    if (uri) {
      playlist.uri = uri;
    }
    playlist.attributes = playlist.attributes || {};
  };
  var setupMediaPlaylists = function setupMediaPlaylists(master) {
    var i = master.playlists.length;
    while (i--) {
      var playlist = master.playlists[i];
      setupMediaPlaylist({
        playlist: playlist,
        id: createPlaylistID(i, playlist.uri)
      });
      playlist.resolvedUri = resolveUrl(master.uri, playlist.uri);
      master.playlists[playlist.id] = playlist;
      master.playlists[playlist.uri] = playlist;
      if (!playlist.attributes.BANDWIDTH) {
        log.warn('Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.');
      }
    }
  };
  var resolveMediaGroupUris = function resolveMediaGroupUris(master) {
    forEachMediaGroup(master, function (properties) {
      if (properties.uri) {
        properties.resolvedUri = resolveUrl(master.uri, properties.uri);
      }
    });
  };
  var masterForMedia = function masterForMedia(media, uri) {
    var id = createPlaylistID(0, uri);
    var master = {
      mediaGroups: {
        'AUDIO': {},
        'VIDEO': {},
        'CLOSED-CAPTIONS': {},
        'SUBTITLES': {}
      },
      uri: window.location.href,
      resolvedUri: window.location.href,
      playlists: [{
        uri: uri,
        id: id,
        resolvedUri: uri,
        attributes: {}
      }]
    };
    master.playlists[id] = master.playlists[0];
    master.playlists[uri] = master.playlists[0];
    return master;
  };
  var addPropertiesToMaster = function addPropertiesToMaster(master, uri) {
    master.uri = uri;
    for (var i = 0; i < master.playlists.length; i++) {
      if (!master.playlists[i].uri) {
        var phonyUri = "placeholder-uri-" + i;
        master.playlists[i].uri = phonyUri;
      }
    }
    var audioOnlyMaster = isAudioOnly(master);
    forEachMediaGroup(master, function (properties, mediaType, groupKey, labelKey) {
      var groupId = "placeholder-uri-" + mediaType + "-" + groupKey + "-" + labelKey;
      if (!properties.playlists || !properties.playlists.length) {
        if (audioOnlyMaster && mediaType === 'AUDIO' && !properties.uri) {
          for (var _i = 0; _i < master.playlists.length; _i++) {
            var p = master.playlists[_i];
            if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) {
              return;
            }
          }
        }
        properties.playlists = [_extends_1({}, properties)];
      }
      properties.playlists.forEach(function (p, i) {
        var id = createPlaylistID(i, groupId);
        if (p.uri) {
          p.resolvedUri = p.resolvedUri || resolveUrl(master.uri, p.uri);
        } else {
          p.uri = i === 0 ? groupId : id;
          p.resolvedUri = p.uri;
        }
        p.id = p.id || id;
        p.attributes = p.attributes || {};
        master.playlists[p.id] = p;
        master.playlists[p.uri] = p;
      });
    });
    setupMediaPlaylists(master);
    resolveMediaGroupUris(master);
  };
  var mergeOptions$2 = videojs.mergeOptions,
      EventTarget$1 = videojs.EventTarget;
  var addLLHLSQueryDirectives = function addLLHLSQueryDirectives(uri, media) {
    if (media.endList || !media.serverControl) {
      return uri;
    }
    var parameters = {};
    if (media.serverControl.canBlockReload) {
      var preloadSegment = media.preloadSegment;
      var nextMSN = media.mediaSequence + media.segments.length;
      if (preloadSegment) {
        var parts = preloadSegment.parts || [];
        var nextPart = getKnownPartCount(media) - 1;
        if (nextPart > -1 && nextPart !== parts.length - 1) {
          parameters._HLS_part = nextPart;
        }
        if (nextPart > -1 || parts.length) {
          nextMSN--;
        }
      }
      parameters._HLS_msn = nextMSN;
    }
    if (media.serverControl && media.serverControl.canSkipUntil) {
      parameters._HLS_skip = media.serverControl.canSkipDateranges ? 'v2' : 'YES';
    }
    if (Object.keys(parameters).length) {
      var parsedUri = new window.URL(uri);
      ['_HLS_skip', '_HLS_msn', '_HLS_part'].forEach(function (name) {
        if (!parameters.hasOwnProperty(name)) {
          return;
        }
        parsedUri.searchParams.set(name, parameters[name]);
      });
      uri = parsedUri.toString();
    }
    return uri;
  };
  var updateSegment = function updateSegment(a, b) {
    if (!a) {
      return b;
    }
    var result = mergeOptions$2(a, b);
    if (a.preloadHints && !b.preloadHints) {
      delete result.preloadHints;
    }
    if (a.parts && !b.parts) {
      delete result.parts;
    } else if (a.parts && b.parts) {
      for (var i = 0; i < b.parts.length; i++) {
        if (a.parts && a.parts[i]) {
          result.parts[i] = mergeOptions$2(a.parts[i], b.parts[i]);
        }
      }
    }
    if (!a.skipped && b.skipped) {
      result.skipped = false;
    }
    if (a.preload && !b.preload) {
      result.preload = false;
    }
    return result;
  };
  var updateSegments = function updateSegments(original, update, offset) {
    var oldSegments = original.slice();
    var newSegments = update.slice();
    offset = offset || 0;
    var result = [];
    var currentMap;
    for (var newIndex = 0; newIndex < newSegments.length; newIndex++) {
      var oldSegment = oldSegments[newIndex + offset];
      var newSegment = newSegments[newIndex];
      if (oldSegment) {
        currentMap = oldSegment.map || currentMap;
        result.push(updateSegment(oldSegment, newSegment));
      } else {
        if (currentMap && !newSegment.map) {
          newSegment.map = currentMap;
        }
        result.push(newSegment);
      }
    }
    return result;
  };
  var resolveSegmentUris = function resolveSegmentUris(segment, baseUri) {
    if (!segment.resolvedUri && segment.uri) {
      segment.resolvedUri = resolveUrl(baseUri, segment.uri);
    }
    if (segment.key && !segment.key.resolvedUri) {
      segment.key.resolvedUri = resolveUrl(baseUri, segment.key.uri);
    }
    if (segment.map && !segment.map.resolvedUri) {
      segment.map.resolvedUri = resolveUrl(baseUri, segment.map.uri);
    }
    if (segment.map && segment.map.key && !segment.map.key.resolvedUri) {
      segment.map.key.resolvedUri = resolveUrl(baseUri, segment.map.key.uri);
    }
    if (segment.parts && segment.parts.length) {
      segment.parts.forEach(function (p) {
        if (p.resolvedUri) {
          return;
        }
        p.resolvedUri = resolveUrl(baseUri, p.uri);
      });
    }
    if (segment.preloadHints && segment.preloadHints.length) {
      segment.preloadHints.forEach(function (p) {
        if (p.resolvedUri) {
          return;
        }
        p.resolvedUri = resolveUrl(baseUri, p.uri);
      });
    }
  };
  var getAllSegments = function getAllSegments(media) {
    var segments = media.segments || [];
    var preloadSegment = media.preloadSegment;
    if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {
      if (preloadSegment.preloadHints) {
        for (var i = 0; i < preloadSegment.preloadHints.length; i++) {
          if (preloadSegment.preloadHints[i].type === 'MAP') {
            return segments;
          }
        }
      }
      preloadSegment.duration = media.targetDuration;
      preloadSegment.preload = true;
      segments.push(preloadSegment);
    }
    return segments;
  };
  var isPlaylistUnchanged = function isPlaylistUnchanged(a, b) {
    return a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;
  };
  var updateMaster$1 = function updateMaster(master, newMedia, unchangedCheck) {
    if (unchangedCheck === void 0) {
      unchangedCheck = isPlaylistUnchanged;
    }
    var result = mergeOptions$2(master, {});
    var oldMedia = result.playlists[newMedia.id];
    if (!oldMedia) {
      return null;
    }
    if (unchangedCheck(oldMedia, newMedia)) {
      return null;
    }
    newMedia.segments = getAllSegments(newMedia);
    var mergedPlaylist = mergeOptions$2(oldMedia, newMedia);
    if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) {
      delete mergedPlaylist.preloadSegment;
    }
    if (oldMedia.segments) {
      if (newMedia.skip) {
        newMedia.segments = newMedia.segments || [];
        for (var i = 0; i < newMedia.skip.skippedSegments; i++) {
          newMedia.segments.unshift({
            skipped: true
          });
        }
      }
      mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);
    }
    mergedPlaylist.segments.forEach(function (segment) {
      resolveSegmentUris(segment, mergedPlaylist.resolvedUri);
    });
    for (var _i = 0; _i < result.playlists.length; _i++) {
      if (result.playlists[_i].id === newMedia.id) {
        result.playlists[_i] = mergedPlaylist;
      }
    }
    result.playlists[newMedia.id] = mergedPlaylist;
    result.playlists[newMedia.uri] = mergedPlaylist;
    forEachMediaGroup(master, function (properties, mediaType, groupKey, labelKey) {
      if (!properties.playlists) {
        return;
      }
      for (var _i2 = 0; _i2 < properties.playlists.length; _i2++) {
        if (newMedia.id === properties.playlists[_i2].id) {
          properties.playlists[_i2] = newMedia;
        }
      }
    });
    return result;
  };
  var refreshDelay = function refreshDelay(media, update) {
    var segments = media.segments || [];
    var lastSegment = segments[segments.length - 1];
    var lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];
    var lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;
    if (update && lastDuration) {
      return lastDuration * 1000;
    }
    return (media.partTargetDuration || media.targetDuration || 10) * 500;
  };
  var PlaylistLoader = function (_EventTarget) {
    inheritsLoose(PlaylistLoader, _EventTarget);
    function PlaylistLoader(src, vhs, options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      _this = _EventTarget.call(this) || this;
      if (!src) {
        throw new Error('A non-empty playlist URL or object is required');
      }
      _this.logger_ = logger('PlaylistLoader');
      var _options = options,
          _options$withCredenti = _options.withCredentials,
          withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti,
          _options$handleManife = _options.handleManifestRedirects,
          handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;
      _this.src = src;
      _this.vhs_ = vhs;
      _this.withCredentials = withCredentials;
      _this.handleManifestRedirects = handleManifestRedirects;
      var vhsOptions = vhs.options_;
      _this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];
      _this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];
      _this.experimentalLLHLS = vhsOptions && vhsOptions.experimentalLLHLS || false;
      if (videojs.browser.IE_VERSION) {
        _this.experimentalLLHLS = false;
      }
      _this.state = 'HAVE_NOTHING';
      _this.handleMediaupdatetimeout_ = _this.handleMediaupdatetimeout_.bind(assertThisInitialized(_this));
      _this.on('mediaupdatetimeout', _this.handleMediaupdatetimeout_);
      return _this;
    }
    var _proto = PlaylistLoader.prototype;
    _proto.handleMediaupdatetimeout_ = function handleMediaupdatetimeout_() {
      var _this2 = this;
      if (this.state !== 'HAVE_METADATA') {
        return;
      }
      var media = this.media();
      var uri = resolveUrl(this.master.uri, media.uri);
      if (this.experimentalLLHLS) {
        uri = addLLHLSQueryDirectives(uri, media);
      }
      this.state = 'HAVE_CURRENT_METADATA';
      this.request = this.vhs_.xhr({
        uri: uri,
        withCredentials: this.withCredentials
      }, function (error, req) {
        if (!_this2.request) {
          return;
        }
        if (error) {
          return _this2.playlistRequestError(_this2.request, _this2.media(), 'HAVE_METADATA');
        }
        _this2.haveMetadata({
          playlistString: _this2.request.responseText,
          url: _this2.media().uri,
          id: _this2.media().id
        });
      });
    };
    _proto.playlistRequestError = function playlistRequestError(xhr, playlist, startingState) {
      var uri = playlist.uri,
          id = playlist.id;
      this.request = null;
      if (startingState) {
        this.state = startingState;
      }
      this.error = {
        playlist: this.master.playlists[id],
        status: xhr.status,
        message: "HLS playlist request error at URL: " + uri + ".",
        responseText: xhr.responseText,
        code: xhr.status >= 500 ? 4 : 2
      };
      this.trigger('error');
    };
    _proto.parseManifest_ = function parseManifest_(_ref) {
      var _this3 = this;
      var url = _ref.url,
          manifestString = _ref.manifestString;
      return parseManifest({
        onwarn: function onwarn(_ref2) {
          var message = _ref2.message;
          return _this3.logger_("m3u8-parser warn for " + url + ": " + message);
        },
        oninfo: function oninfo(_ref3) {
          var message = _ref3.message;
          return _this3.logger_("m3u8-parser info for " + url + ": " + message);
        },
        manifestString: manifestString,
        customTagParsers: this.customTagParsers,
        customTagMappers: this.customTagMappers,
        experimentalLLHLS: this.experimentalLLHLS
      });
    }
    ;
    _proto.haveMetadata = function haveMetadata(_ref4) {
      var playlistString = _ref4.playlistString,
          playlistObject = _ref4.playlistObject,
          url = _ref4.url,
          id = _ref4.id;
      this.request = null;
      this.state = 'HAVE_METADATA';
      var playlist = playlistObject || this.parseManifest_({
        url: url,
        manifestString: playlistString
      });
      playlist.lastRequest = Date.now();
      setupMediaPlaylist({
        playlist: playlist,
        uri: url,
        id: id
      });
      var update = updateMaster$1(this.master, playlist);
      this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;
      this.pendingMedia_ = null;
      if (update) {
        this.master = update;
        this.media_ = this.master.playlists[id];
      } else {
        this.trigger('playlistunchanged');
      }
      this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update));
      this.trigger('loadedplaylist');
    }
    ;
    _proto.dispose = function dispose() {
      this.trigger('dispose');
      this.stopRequest();
      window.clearTimeout(this.mediaUpdateTimeout);
      window.clearTimeout(this.finalRenditionTimeout);
      this.off();
    };
    _proto.stopRequest = function stopRequest() {
      if (this.request) {
        var oldRequest = this.request;
        this.request = null;
        oldRequest.onreadystatechange = null;
        oldRequest.abort();
      }
    }
    ;
    _proto.media = function media(playlist, shouldDelay) {
      var _this4 = this;
      if (!playlist) {
        return this.media_;
      }
      if (this.state === 'HAVE_NOTHING') {
        throw new Error('Cannot switch media playlist from ' + this.state);
      }
      if (typeof playlist === 'string') {
        if (!this.master.playlists[playlist]) {
          throw new Error('Unknown playlist URI: ' + playlist);
        }
        playlist = this.master.playlists[playlist];
      }
      window.clearTimeout(this.finalRenditionTimeout);
      if (shouldDelay) {
        var delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1000 || 5 * 1000;
        this.finalRenditionTimeout = window.setTimeout(this.media.bind(this, playlist, false), delay);
        return;
      }
      var startingState = this.state;
      var mediaChange = !this.media_ || playlist.id !== this.media_.id;
      var masterPlaylistRef = this.master.playlists[playlist.id];
      if (masterPlaylistRef && masterPlaylistRef.endList ||
      playlist.endList && playlist.segments.length) {
        if (this.request) {
          this.request.onreadystatechange = null;
          this.request.abort();
          this.request = null;
        }
        this.state = 'HAVE_METADATA';
        this.media_ = playlist;
        if (mediaChange) {
          this.trigger('mediachanging');
          if (startingState === 'HAVE_MASTER') {
            this.trigger('loadedmetadata');
          } else {
            this.trigger('mediachange');
          }
        }
        return;
      }
      this.updateMediaUpdateTimeout_(refreshDelay(playlist, true));
      if (!mediaChange) {
        return;
      }
      this.state = 'SWITCHING_MEDIA';
      if (this.request) {
        if (playlist.resolvedUri === this.request.url) {
          return;
        }
        this.request.onreadystatechange = null;
        this.request.abort();
        this.request = null;
      }
      if (this.media_) {
        this.trigger('mediachanging');
      }
      this.pendingMedia_ = playlist;
      this.request = this.vhs_.xhr({
        uri: playlist.resolvedUri,
        withCredentials: this.withCredentials
      }, function (error, req) {
        if (!_this4.request) {
          return;
        }
        playlist.lastRequest = Date.now();
        playlist.resolvedUri = resolveManifestRedirect(_this4.handleManifestRedirects, playlist.resolvedUri, req);
        if (error) {
          return _this4.playlistRequestError(_this4.request, playlist, startingState);
        }
        _this4.haveMetadata({
          playlistString: req.responseText,
          url: playlist.uri,
          id: playlist.id
        });
        if (startingState === 'HAVE_MASTER') {
          _this4.trigger('loadedmetadata');
        } else {
          _this4.trigger('mediachange');
        }
      });
    }
    ;
    _proto.pause = function pause() {
      if (this.mediaUpdateTimeout) {
        window.clearTimeout(this.mediaUpdateTimeout);
        this.mediaUpdateTimeout = null;
      }
      this.stopRequest();
      if (this.state === 'HAVE_NOTHING') {
        this.started = false;
      }
      if (this.state === 'SWITCHING_MEDIA') {
        if (this.media_) {
          this.state = 'HAVE_METADATA';
        } else {
          this.state = 'HAVE_MASTER';
        }
      } else if (this.state === 'HAVE_CURRENT_METADATA') {
        this.state = 'HAVE_METADATA';
      }
    }
    ;
    _proto.load = function load(shouldDelay) {
      var _this5 = this;
      if (this.mediaUpdateTimeout) {
        window.clearTimeout(this.mediaUpdateTimeout);
        this.mediaUpdateTimeout = null;
      }
      var media = this.media();
      if (shouldDelay) {
        var delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1000 : 5 * 1000;
        this.mediaUpdateTimeout = window.setTimeout(function () {
          _this5.mediaUpdateTimeout = null;
          _this5.load();
        }, delay);
        return;
      }
      if (!this.started) {
        this.start();
        return;
      }
      if (media && !media.endList) {
        this.trigger('mediaupdatetimeout');
      } else {
        this.trigger('loadedplaylist');
      }
    };
    _proto.updateMediaUpdateTimeout_ = function updateMediaUpdateTimeout_(delay) {
      var _this6 = this;
      if (this.mediaUpdateTimeout) {
        window.clearTimeout(this.mediaUpdateTimeout);
        this.mediaUpdateTimeout = null;
      }
      if (!this.media() || this.media().endList) {
        return;
      }
      this.mediaUpdateTimeout = window.setTimeout(function () {
        _this6.mediaUpdateTimeout = null;
        _this6.trigger('mediaupdatetimeout');
        _this6.updateMediaUpdateTimeout_(delay);
      }, delay);
    }
    ;
    _proto.start = function start() {
      var _this7 = this;
      this.started = true;
      if (typeof this.src === 'object') {
        if (!this.src.uri) {
          this.src.uri = window.location.href;
        }
        this.src.resolvedUri = this.src.uri;
        setTimeout(function () {
          _this7.setupInitialPlaylist(_this7.src);
        }, 0);
        return;
      }
      this.request = this.vhs_.xhr({
        uri: this.src,
        withCredentials: this.withCredentials
      }, function (error, req) {
        if (!_this7.request) {
          return;
        }
        _this7.request = null;
        if (error) {
          _this7.error = {
            status: req.status,
            message: "HLS playlist request error at URL: " + _this7.src + ".",
            responseText: req.responseText,
            code: 2
          };
          if (_this7.state === 'HAVE_NOTHING') {
            _this7.started = false;
          }
          return _this7.trigger('error');
        }
        _this7.src = resolveManifestRedirect(_this7.handleManifestRedirects, _this7.src, req);
        var manifest = _this7.parseManifest_({
          manifestString: req.responseText,
          url: _this7.src
        });
        _this7.setupInitialPlaylist(manifest);
      });
    };
    _proto.srcUri = function srcUri() {
      return typeof this.src === 'string' ? this.src : this.src.uri;
    }
    ;
    _proto.setupInitialPlaylist = function setupInitialPlaylist(manifest) {
      this.state = 'HAVE_MASTER';
      if (manifest.playlists) {
        this.master = manifest;
        addPropertiesToMaster(this.master, this.srcUri());
        manifest.playlists.forEach(function (playlist) {
          playlist.segments = getAllSegments(playlist);
          playlist.segments.forEach(function (segment) {
            resolveSegmentUris(segment, playlist.resolvedUri);
          });
        });
        this.trigger('loadedplaylist');
        if (!this.request) {
          this.media(this.master.playlists[0]);
        }
        return;
      }
      var uri = this.srcUri() || window.location.href;
      this.master = masterForMedia(manifest, uri);
      this.haveMetadata({
        playlistObject: manifest,
        url: uri,
        id: this.master.playlists[0].id
      });
      this.trigger('loadedmetadata');
    };
    return PlaylistLoader;
  }(EventTarget$1);
  var videojsXHR = videojs.xhr,
      mergeOptions$1 = videojs.mergeOptions;
  var callbackWrapper = function callbackWrapper(request, error, response, callback) {
    var reqResponse = request.responseType === 'arraybuffer' ? request.response : request.responseText;
    if (!error && reqResponse) {
      request.responseTime = Date.now();
      request.roundTripTime = request.responseTime - request.requestTime;
      request.bytesReceived = reqResponse.byteLength || reqResponse.length;
      if (!request.bandwidth) {
        request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1000);
      }
    }
    if (response.headers) {
      request.responseHeaders = response.headers;
    }
    if (error && error.code === 'ETIMEDOUT') {
      request.timedout = true;
    }
    if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {
      error = new Error('XHR Failed with a response of: ' + (request && (reqResponse || request.responseText)));
    }
    callback(error, request);
  };
  var xhrFactory = function xhrFactory() {
    var xhr = function XhrFunction(options, callback) {
      options = mergeOptions$1({
        timeout: 45e3
      }, options);
      var beforeRequest = XhrFunction.beforeRequest || videojs.Vhs.xhr.beforeRequest;
      if (beforeRequest && typeof beforeRequest === 'function') {
        var newOptions = beforeRequest(options);
        if (newOptions) {
          options = newOptions;
        }
      }
      var xhrMethod = videojs.Vhs.xhr.original === true ? videojsXHR : videojs.Vhs.xhr;
      var request = xhrMethod(options, function (error, response) {
        return callbackWrapper(request, error, response, callback);
      });
      var originalAbort = request.abort;
      request.abort = function () {
        request.aborted = true;
        return originalAbort.apply(request, arguments);
      };
      request.uri = options.uri;
      request.requestTime = Date.now();
      return request;
    };
    xhr.original = true;
    return xhr;
  };
  var byterangeStr = function byterangeStr(byterange) {
    var byterangeEnd;
    var byterangeStart = byterange.offset;
    if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {
      byterangeEnd = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);
    } else {
      byterangeEnd = byterange.offset + byterange.length - 1;
    }
    return 'bytes=' + byterangeStart + '-' + byterangeEnd;
  };
  var segmentXhrHeaders = function segmentXhrHeaders(segment) {
    var headers = {};
    if (segment.byterange) {
      headers.Range = byterangeStr(segment.byterange);
    }
    return headers;
  };
  var textRange = function textRange(range, i) {
    return range.start(i) + '-' + range.end(i);
  };
  var formatHexString = function formatHexString(e, i) {
    var value = e.toString(16);
    return '00'.substring(0, 2 - value.length) + value + (i % 2 ? ' ' : '');
  };
  var formatAsciiString = function formatAsciiString(e) {
    if (e >= 0x20 && e < 0x7e) {
      return String.fromCharCode(e);
    }
    return '.';
  };
  var createTransferableMessage = function createTransferableMessage(message) {
    var transferable = {};
    Object.keys(message).forEach(function (key) {
      var value = message[key];
      if (ArrayBuffer.isView(value)) {
        transferable[key] = {
          bytes: value.buffer,
          byteOffset: value.byteOffset,
          byteLength: value.byteLength
        };
      } else {
        transferable[key] = value;
      }
    });
    return transferable;
  };
  var initSegmentId = function initSegmentId(initSegment) {
    var byterange = initSegment.byterange || {
      length: Infinity,
      offset: 0
    };
    return [byterange.length, byterange.offset, initSegment.resolvedUri].join(',');
  };
  var segmentKeyId = function segmentKeyId(key) {
    return key.resolvedUri;
  };
  var hexDump = function hexDump(data) {
    var bytes = Array.prototype.slice.call(data);
    var step = 16;
    var result = '';
    var hex;
    var ascii;
    for (var j = 0; j < bytes.length / step; j++) {
      hex = bytes.slice(j * step, j * step + step).map(formatHexString).join('');
      ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join('');
      result += hex + ' ' + ascii + '\n';
    }
    return result;
  };
  var tagDump = function tagDump(_ref) {
    var bytes = _ref.bytes;
    return hexDump(bytes);
  };
  var textRanges = function textRanges(ranges) {
    var result = '';
    var i;
    for (i = 0; i < ranges.length; i++) {
      result += textRange(ranges, i) + ' ';
    }
    return result;
  };
  var utils = Object.freeze({
    __proto__: null,
    createTransferableMessage: createTransferableMessage,
    initSegmentId: initSegmentId,
    segmentKeyId: segmentKeyId,
    hexDump: hexDump,
    tagDump: tagDump,
    textRanges: textRanges
  });
  var SEGMENT_END_FUDGE_PERCENT = 0.25;
  var playerTimeToProgramTime = function playerTimeToProgramTime(playerTime, segment) {
    if (!segment.dateTimeObject) {
      return null;
    }
    var transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;
    var transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart;
    var startOfSegment = transmuxedStart + transmuxerPrependedSeconds;
    var offsetFromSegmentStart = playerTime - startOfSegment;
    return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1000);
  };
  var originalSegmentVideoDuration = function originalSegmentVideoDuration(videoTimingInfo) {
    return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;
  };
  var findSegmentForProgramTime = function findSegmentForProgramTime(programTime, playlist) {
    var dateTimeObject;
    try {
      dateTimeObject = new Date(programTime);
    } catch (e) {
      return null;
    }
    if (!playlist || !playlist.segments || playlist.segments.length === 0) {
      return null;
    }
    var segment = playlist.segments[0];
    if (dateTimeObject < segment.dateTimeObject) {
      return null;
    }
    for (var i = 0; i < playlist.segments.length - 1; i++) {
      segment = playlist.segments[i];
      var nextSegmentStart = playlist.segments[i + 1].dateTimeObject;
      if (dateTimeObject < nextSegmentStart) {
        break;
      }
    }
    var lastSegment = playlist.segments[playlist.segments.length - 1];
    var lastSegmentStart = lastSegment.dateTimeObject;
    var lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;
    var lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1000);
    if (dateTimeObject > lastSegmentEnd) {
      return null;
    }
    if (dateTimeObject > lastSegmentStart) {
      segment = lastSegment;
    }
    return {
      segment: segment,
      estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),
      type: segment.videoTimingInfo ? 'accurate' : 'estimate'
    };
  };
  var findSegmentForPlayerTime = function findSegmentForPlayerTime(time, playlist) {
    if (!playlist || !playlist.segments || playlist.segments.length === 0) {
      return null;
    }
    var segmentEnd = 0;
    var segment;
    for (var i = 0; i < playlist.segments.length; i++) {
      segment = playlist.segments[i];
      segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;
      if (time <= segmentEnd) {
        break;
      }
    }
    var lastSegment = playlist.segments[playlist.segments.length - 1];
    if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) {
      return null;
    }
    if (time > segmentEnd) {
      if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {
        return null;
      }
      segment = lastSegment;
    }
    return {
      segment: segment,
      estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,
      type: segment.videoTimingInfo ? 'accurate' : 'estimate'
    };
  };
  var getOffsetFromTimestamp = function getOffsetFromTimestamp(comparisonTimeStamp, programTime) {
    var segmentDateTime;
    var programDateTime;
    try {
      segmentDateTime = new Date(comparisonTimeStamp);
      programDateTime = new Date(programTime);
    } catch (e) {
    }
    var segmentTimeEpoch = segmentDateTime.getTime();
    var programTimeEpoch = programDateTime.getTime();
    return (programTimeEpoch - segmentTimeEpoch) / 1000;
  };
  var verifyProgramDateTimeTags = function verifyProgramDateTimeTags(playlist) {
    if (!playlist.segments || playlist.segments.length === 0) {
      return false;
    }
    for (var i = 0; i < playlist.segments.length; i++) {
      var segment = playlist.segments[i];
      if (!segment.dateTimeObject) {
        return false;
      }
    }
    return true;
  };
  var getProgramTime = function getProgramTime(_ref) {
    var playlist = _ref.playlist,
        _ref$time = _ref.time,
        time = _ref$time === void 0 ? undefined : _ref$time,
        callback = _ref.callback;
    if (!callback) {
      throw new Error('getProgramTime: callback must be provided');
    }
    if (!playlist || time === undefined) {
      return callback({
        message: 'getProgramTime: playlist and time must be provided'
      });
    }
    var matchedSegment = findSegmentForPlayerTime(time, playlist);
    if (!matchedSegment) {
      return callback({
        message: 'valid programTime was not found'
      });
    }
    if (matchedSegment.type === 'estimate') {
      return callback({
        message: 'Accurate programTime could not be determined.' + ' Please seek to e.seekTime and try again',
        seekTime: matchedSegment.estimatedStart
      });
    }
    var programTimeObject = {
      mediaSeconds: time
    };
    var programTime = playerTimeToProgramTime(time, matchedSegment.segment);
    if (programTime) {
      programTimeObject.programDateTime = programTime.toISOString();
    }
    return callback(null, programTimeObject);
  };
  var seekToProgramTime = function seekToProgramTime(_ref2) {
    var programTime = _ref2.programTime,
        playlist = _ref2.playlist,
        _ref2$retryCount = _ref2.retryCount,
        retryCount = _ref2$retryCount === void 0 ? 2 : _ref2$retryCount,
        seekTo = _ref2.seekTo,
        _ref2$pauseAfterSeek = _ref2.pauseAfterSeek,
        pauseAfterSeek = _ref2$pauseAfterSeek === void 0 ? true : _ref2$pauseAfterSeek,
        tech = _ref2.tech,
        callback = _ref2.callback;
    if (!callback) {
      throw new Error('seekToProgramTime: callback must be provided');
    }
    if (typeof programTime === 'undefined' || !playlist || !seekTo) {
      return callback({
        message: 'seekToProgramTime: programTime, seekTo and playlist must be provided'
      });
    }
    if (!playlist.endList && !tech.hasStarted_) {
      return callback({
        message: 'player must be playing a live stream to start buffering'
      });
    }
    if (!verifyProgramDateTimeTags(playlist)) {
      return callback({
        message: 'programDateTime tags must be provided in the manifest ' + playlist.resolvedUri
      });
    }
    var matchedSegment = findSegmentForProgramTime(programTime, playlist);
    if (!matchedSegment) {
      return callback({
        message: programTime + " was not found in the stream"
      });
    }
    var segment = matchedSegment.segment;
    var mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);
    if (matchedSegment.type === 'estimate') {
      if (retryCount === 0) {
        return callback({
          message: programTime + " is not buffered yet. Try again"
        });
      }
      seekTo(matchedSegment.estimatedStart + mediaOffset);
      tech.one('seeked', function () {
        seekToProgramTime({
          programTime: programTime,
          playlist: playlist,
          retryCount: retryCount - 1,
          seekTo: seekTo,
          pauseAfterSeek: pauseAfterSeek,
          tech: tech,
          callback: callback
        });
      });
      return;
    }
    var seekToTime = segment.start + mediaOffset;
    var seekedCallback = function seekedCallback() {
      return callback(null, tech.currentTime());
    };
    tech.one('seeked', seekedCallback);
    if (pauseAfterSeek) {
      tech.pause();
    }
    seekTo(seekToTime);
  };
  var callbackOnCompleted = function callbackOnCompleted(request, cb) {
    if (request.readyState === 4) {
      return cb();
    }
    return;
  };
  var containerRequest = function containerRequest(uri, xhr, cb) {
    var bytes = [];
    var id3Offset;
    var finished = false;
    var endRequestAndCallback = function endRequestAndCallback(err, req, type, _bytes) {
      req.abort();
      finished = true;
      return cb(err, req, type, _bytes);
    };
    var progressListener = function progressListener(error, request) {
      if (finished) {
        return;
      }
      if (error) {
        return endRequestAndCallback(error, request, '', bytes);
      }
      var newPart = request.responseText.substring(bytes && bytes.byteLength || 0, request.responseText.length);
      bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));
      id3Offset = id3Offset || getId3Offset(bytes);
      if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {
        return callbackOnCompleted(request, function () {
          return endRequestAndCallback(error, request, '', bytes);
        });
      }
      var type = detectContainerForBytes(bytes);
      if (type === 'ts' && bytes.length < 188) {
        return callbackOnCompleted(request, function () {
          return endRequestAndCallback(error, request, '', bytes);
        });
      }
      if (!type && bytes.length < 376) {
        return callbackOnCompleted(request, function () {
          return endRequestAndCallback(error, request, '', bytes);
        });
      }
      return endRequestAndCallback(null, request, type, bytes);
    };
    var options = {
      uri: uri,
      beforeSend: function beforeSend(request) {
        request.overrideMimeType('text/plain; charset=x-user-defined');
        request.addEventListener('progress', function (_ref) {
          _ref.total;
          _ref.loaded;
          return callbackWrapper(request, null, {
            statusCode: request.status
          }, progressListener);
        });
      }
    };
    var request = xhr(options, function (error, response) {
      return callbackWrapper(request, error, response, progressListener);
    });
    return request;
  };
  var EventTarget = videojs.EventTarget,
      mergeOptions = videojs.mergeOptions;
  var dashPlaylistUnchanged = function dashPlaylistUnchanged(a, b) {
    if (!isPlaylistUnchanged(a, b)) {
      return false;
    }
    if (a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length)) {
      return false;
    } else if (!a.sidx && b.sidx || a.sidx && !b.sidx) {
      return false;
    }
    if (a.segments && !b.segments || !a.segments && b.segments) {
      return false;
    }
    if (!a.segments && !b.segments) {
      return true;
    }
    for (var i = 0; i < a.segments.length; i++) {
      var aSegment = a.segments[i];
      var bSegment = b.segments[i];
      if (aSegment.uri !== bSegment.uri) {
        return false;
      }
      if (!aSegment.byterange && !bSegment.byterange) {
        continue;
      }
      var aByterange = aSegment.byterange;
      var bByterange = bSegment.byterange;
      if (aByterange && !bByterange || !aByterange && bByterange) {
        return false;
      }
      if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) {
        return false;
      }
    }
    return true;
  };
  var parseMasterXml = function parseMasterXml(_ref) {
    var masterXml = _ref.masterXml,
        srcUrl = _ref.srcUrl,
        clientOffset = _ref.clientOffset,
        sidxMapping = _ref.sidxMapping,
        previousManifest = _ref.previousManifest;
    var manifest = parse(masterXml, {
      manifestUri: srcUrl,
      clientOffset: clientOffset,
      sidxMapping: sidxMapping,
      previousManifest: previousManifest
    });
    addPropertiesToMaster(manifest, srcUrl);
    return manifest;
  };
  var updateMaster = function updateMaster(oldMaster, newMaster, sidxMapping) {
    var noChanges = true;
    var update = mergeOptions(oldMaster, {
      duration: newMaster.duration,
      minimumUpdatePeriod: newMaster.minimumUpdatePeriod,
      timelineStarts: newMaster.timelineStarts
    });
    for (var i = 0; i < newMaster.playlists.length; i++) {
      var playlist = newMaster.playlists[i];
      if (playlist.sidx) {
        var sidxKey = generateSidxKey(playlist.sidx);
        if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) {
          addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);
        }
      }
      var playlistUpdate = updateMaster$1(update, playlist, dashPlaylistUnchanged);
      if (playlistUpdate) {
        update = playlistUpdate;
        noChanges = false;
      }
    }
    forEachMediaGroup(newMaster, function (properties, type, group, label) {
      if (properties.playlists && properties.playlists.length) {
        var id = properties.playlists[0].id;
        var _playlistUpdate = updateMaster$1(update, properties.playlists[0], dashPlaylistUnchanged);
        if (_playlistUpdate) {
          update = _playlistUpdate;
          update.mediaGroups[type][group][label].playlists[0] = update.playlists[id];
          noChanges = false;
        }
      }
    });
    if (newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {
      noChanges = false;
    }
    if (noChanges) {
      return null;
    }
    return update;
  };
  var equivalentSidx = function equivalentSidx(a, b) {
    var neitherMap = Boolean(!a.map && !b.map);
    var equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);
    return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;
  };
  var compareSidxEntry = function compareSidxEntry(playlists, oldSidxMapping) {
    var newSidxMapping = {};
    for (var id in playlists) {
      var playlist = playlists[id];
      var currentSidxInfo = playlist.sidx;
      if (currentSidxInfo) {
        var key = generateSidxKey(currentSidxInfo);
        if (!oldSidxMapping[key]) {
          break;
        }
        var savedSidxInfo = oldSidxMapping[key].sidxInfo;
        if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {
          newSidxMapping[key] = oldSidxMapping[key];
        }
      }
    }
    return newSidxMapping;
  };
  var filterChangedSidxMappings = function filterChangedSidxMappings(master, oldSidxMapping) {
    var videoSidx = compareSidxEntry(master.playlists, oldSidxMapping);
    var mediaGroupSidx = videoSidx;
    forEachMediaGroup(master, function (properties, mediaType, groupKey, labelKey) {
      if (properties.playlists && properties.playlists.length) {
        var playlists = properties.playlists;
        mediaGroupSidx = mergeOptions(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));
      }
    });
    return mediaGroupSidx;
  };
  var DashPlaylistLoader = function (_EventTarget) {
    inheritsLoose(DashPlaylistLoader, _EventTarget);
    function DashPlaylistLoader(srcUrlOrPlaylist, vhs, options, masterPlaylistLoader) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      _this = _EventTarget.call(this) || this;
      _this.masterPlaylistLoader_ = masterPlaylistLoader || assertThisInitialized(_this);
      if (!masterPlaylistLoader) {
        _this.isMaster_ = true;
      }
      var _options = options,
          _options$withCredenti = _options.withCredentials,
          withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti,
          _options$handleManife = _options.handleManifestRedirects,
          handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;
      _this.vhs_ = vhs;
      _this.withCredentials = withCredentials;
      _this.handleManifestRedirects = handleManifestRedirects;
      if (!srcUrlOrPlaylist) {
        throw new Error('A non-empty playlist URL or object is required');
      }
      _this.on('minimumUpdatePeriod', function () {
        _this.refreshXml_();
      });
      _this.on('mediaupdatetimeout', function () {
        _this.refreshMedia_(_this.media().id);
      });
      _this.state = 'HAVE_NOTHING';
      _this.loadedPlaylists_ = {};
      _this.logger_ = logger('DashPlaylistLoader');
      if (_this.isMaster_) {
        _this.masterPlaylistLoader_.srcUrl = srcUrlOrPlaylist;
        _this.masterPlaylistLoader_.sidxMapping_ = {};
      } else {
        _this.childPlaylist_ = srcUrlOrPlaylist;
      }
      return _this;
    }
    var _proto = DashPlaylistLoader.prototype;
    _proto.requestErrored_ = function requestErrored_(err, request, startingState) {
      if (!this.request) {
        return true;
      }
      this.request = null;
      if (err) {
        this.error = typeof err === 'object' && !(err instanceof Error) ? err : {
          status: request.status,
          message: 'DASH request error at URL: ' + request.uri,
          response: request.response,
          code: 2
        };
        if (startingState) {
          this.state = startingState;
        }
        this.trigger('error');
        return true;
      }
    }
    ;
    _proto.addSidxSegments_ = function addSidxSegments_(playlist, startingState, cb) {
      var _this2 = this;
      var sidxKey = playlist.sidx && generateSidxKey(playlist.sidx);
      if (!playlist.sidx || !sidxKey || this.masterPlaylistLoader_.sidxMapping_[sidxKey]) {
        this.mediaRequest_ = window.setTimeout(function () {
          return cb(false);
        }, 0);
        return;
      }
      var uri = resolveManifestRedirect(this.handleManifestRedirects, playlist.sidx.resolvedUri);
      var fin = function fin(err, request) {
        if (_this2.requestErrored_(err, request, startingState)) {
          return;
        }
        var sidxMapping = _this2.masterPlaylistLoader_.sidxMapping_;
        var sidx;
        try {
          sidx = parseSidx_1(toUint8(request.response).subarray(8));
        } catch (e) {
          _this2.requestErrored_(e, request, startingState);
          return;
        }
        sidxMapping[sidxKey] = {
          sidxInfo: playlist.sidx,
          sidx: sidx
        };
        addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);
        return cb(true);
      };
      this.request = containerRequest(uri, this.vhs_.xhr, function (err, request, container, bytes) {
        if (err) {
          return fin(err, request);
        }
        if (!container || container !== 'mp4') {
          return fin({
            status: request.status,
            message: "Unsupported " + (container || 'unknown') + " container type for sidx segment at URL: " + uri,
            response: '',
            playlist: playlist,
            internal: true,
            blacklistDuration: Infinity,
            code: 2
          }, request);
        }
        var _playlist$sidx$bytera = playlist.sidx.byterange,
            offset = _playlist$sidx$bytera.offset,
            length = _playlist$sidx$bytera.length;
        if (bytes.length >= length + offset) {
          return fin(err, {
            response: bytes.subarray(offset, offset + length),
            status: request.status,
            uri: request.uri
          });
        }
        _this2.request = _this2.vhs_.xhr({
          uri: uri,
          responseType: 'arraybuffer',
          headers: segmentXhrHeaders({
            byterange: playlist.sidx.byterange
          })
        }, fin);
      });
    };
    _proto.dispose = function dispose() {
      this.trigger('dispose');
      this.stopRequest();
      this.loadedPlaylists_ = {};
      window.clearTimeout(this.minimumUpdatePeriodTimeout_);
      window.clearTimeout(this.mediaRequest_);
      window.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
      this.mediaRequest_ = null;
      this.minimumUpdatePeriodTimeout_ = null;
      if (this.masterPlaylistLoader_.createMupOnMedia_) {
        this.off('loadedmetadata', this.masterPlaylistLoader_.createMupOnMedia_);
        this.masterPlaylistLoader_.createMupOnMedia_ = null;
      }
      this.off();
    };
    _proto.hasPendingRequest = function hasPendingRequest() {
      return this.request || this.mediaRequest_;
    };
    _proto.stopRequest = function stopRequest() {
      if (this.request) {
        var oldRequest = this.request;
        this.request = null;
        oldRequest.onreadystatechange = null;
        oldRequest.abort();
      }
    };
    _proto.media = function media(playlist) {
      var _this3 = this;
      if (!playlist) {
        return this.media_;
      }
      if (this.state === 'HAVE_NOTHING') {
        throw new Error('Cannot switch media playlist from ' + this.state);
      }
      var startingState = this.state;
      if (typeof playlist === 'string') {
        if (!this.masterPlaylistLoader_.master.playlists[playlist]) {
          throw new Error('Unknown playlist URI: ' + playlist);
        }
        playlist = this.masterPlaylistLoader_.master.playlists[playlist];
      }
      var mediaChange = !this.media_ || playlist.id !== this.media_.id;
      if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {
        this.state = 'HAVE_METADATA';
        this.media_ = playlist;
        if (mediaChange) {
          this.trigger('mediachanging');
          this.trigger('mediachange');
        }
        return;
      }
      if (!mediaChange) {
        return;
      }
      if (this.media_) {
        this.trigger('mediachanging');
      }
      this.addSidxSegments_(playlist, startingState, function (sidxChanged) {
        _this3.haveMetadata({
          startingState: startingState,
          playlist: playlist
        });
      });
    };
    _proto.haveMetadata = function haveMetadata(_ref2) {
      var startingState = _ref2.startingState,
          playlist = _ref2.playlist;
      this.state = 'HAVE_METADATA';
      this.loadedPlaylists_[playlist.id] = playlist;
      this.mediaRequest_ = null;
      this.refreshMedia_(playlist.id);
      if (startingState === 'HAVE_MASTER') {
        this.trigger('loadedmetadata');
      } else {
        this.trigger('mediachange');
      }
    };
    _proto.pause = function pause() {
      if (this.masterPlaylistLoader_.createMupOnMedia_) {
        this.off('loadedmetadata', this.masterPlaylistLoader_.createMupOnMedia_);
        this.masterPlaylistLoader_.createMupOnMedia_ = null;
      }
      this.stopRequest();
      window.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
      if (this.isMaster_) {
        window.clearTimeout(this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_);
        this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;
      }
      if (this.state === 'HAVE_NOTHING') {
        this.started = false;
      }
    };
    _proto.load = function load(isFinalRendition) {
      var _this4 = this;
      window.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
      var media = this.media();
      if (isFinalRendition) {
        var delay = media ? media.targetDuration / 2 * 1000 : 5 * 1000;
        this.mediaUpdateTimeout = window.setTimeout(function () {
          return _this4.load();
        }, delay);
        return;
      }
      if (!this.started) {
        this.start();
        return;
      }
      if (media && !media.endList) {
        if (this.isMaster_ && !this.minimumUpdatePeriodTimeout_) {
          this.trigger('minimumUpdatePeriod');
          this.updateMinimumUpdatePeriodTimeout_();
        }
        this.trigger('mediaupdatetimeout');
      } else {
        this.trigger('loadedplaylist');
      }
    };
    _proto.start = function start() {
      var _this5 = this;
      this.started = true;
      if (!this.isMaster_) {
        this.mediaRequest_ = window.setTimeout(function () {
          return _this5.haveMaster_();
        }, 0);
        return;
      }
      this.requestMaster_(function (req, masterChanged) {
        _this5.haveMaster_();
        if (!_this5.hasPendingRequest() && !_this5.media_) {
          _this5.media(_this5.masterPlaylistLoader_.master.playlists[0]);
        }
      });
    };
    _proto.requestMaster_ = function requestMaster_(cb) {
      var _this6 = this;
      this.request = this.vhs_.xhr({
        uri: this.masterPlaylistLoader_.srcUrl,
        withCredentials: this.withCredentials
      }, function (error, req) {
        if (_this6.requestErrored_(error, req)) {
          if (_this6.state === 'HAVE_NOTHING') {
            _this6.started = false;
          }
          return;
        }
        var masterChanged = req.responseText !== _this6.masterPlaylistLoader_.masterXml_;
        _this6.masterPlaylistLoader_.masterXml_ = req.responseText;
        if (req.responseHeaders && req.responseHeaders.date) {
          _this6.masterLoaded_ = Date.parse(req.responseHeaders.date);
        } else {
          _this6.masterLoaded_ = Date.now();
        }
        _this6.masterPlaylistLoader_.srcUrl = resolveManifestRedirect(_this6.handleManifestRedirects, _this6.masterPlaylistLoader_.srcUrl, req);
        if (masterChanged) {
          _this6.handleMaster_();
          _this6.syncClientServerClock_(function () {
            return cb(req, masterChanged);
          });
          return;
        }
        return cb(req, masterChanged);
      });
    }
    ;
    _proto.syncClientServerClock_ = function syncClientServerClock_(done) {
      var _this7 = this;
      var utcTiming = parseUTCTiming(this.masterPlaylistLoader_.masterXml_);
      if (utcTiming === null) {
        this.masterPlaylistLoader_.clientOffset_ = this.masterLoaded_ - Date.now();
        return done();
      }
      if (utcTiming.method === 'DIRECT') {
        this.masterPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();
        return done();
      }
      this.request = this.vhs_.xhr({
        uri: resolveUrl(this.masterPlaylistLoader_.srcUrl, utcTiming.value),
        method: utcTiming.method,
        withCredentials: this.withCredentials
      }, function (error, req) {
        if (!_this7.request) {
          return;
        }
        if (error) {
          _this7.masterPlaylistLoader_.clientOffset_ = _this7.masterLoaded_ - Date.now();
          return done();
        }
        var serverTime;
        if (utcTiming.method === 'HEAD') {
          if (!req.responseHeaders || !req.responseHeaders.date) {
            serverTime = _this7.masterLoaded_;
          } else {
            serverTime = Date.parse(req.responseHeaders.date);
          }
        } else {
          serverTime = Date.parse(req.responseText);
        }
        _this7.masterPlaylistLoader_.clientOffset_ = serverTime - Date.now();
        done();
      });
    };
    _proto.haveMaster_ = function haveMaster_() {
      this.state = 'HAVE_MASTER';
      if (this.isMaster_) {
        this.trigger('loadedplaylist');
      } else if (!this.media_) {
        this.media(this.childPlaylist_);
      }
    };
    _proto.handleMaster_ = function handleMaster_() {
      this.mediaRequest_ = null;
      var oldMaster = this.masterPlaylistLoader_.master;
      var newMaster = parseMasterXml({
        masterXml: this.masterPlaylistLoader_.masterXml_,
        srcUrl: this.masterPlaylistLoader_.srcUrl,
        clientOffset: this.masterPlaylistLoader_.clientOffset_,
        sidxMapping: this.masterPlaylistLoader_.sidxMapping_,
        previousManifest: oldMaster
      });
      if (oldMaster) {
        newMaster = updateMaster(oldMaster, newMaster, this.masterPlaylistLoader_.sidxMapping_);
      }
      this.masterPlaylistLoader_.master = newMaster ? newMaster : oldMaster;
      var location = this.masterPlaylistLoader_.master.locations && this.masterPlaylistLoader_.master.locations[0];
      if (location && location !== this.masterPlaylistLoader_.srcUrl) {
        this.masterPlaylistLoader_.srcUrl = location;
      }
      if (!oldMaster || newMaster && newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {
        this.updateMinimumUpdatePeriodTimeout_();
      }
      return Boolean(newMaster);
    };
    _proto.updateMinimumUpdatePeriodTimeout_ = function updateMinimumUpdatePeriodTimeout_() {
      var mpl = this.masterPlaylistLoader_;
      if (mpl.createMupOnMedia_) {
        mpl.off('loadedmetadata', mpl.createMupOnMedia_);
        mpl.createMupOnMedia_ = null;
      }
      if (mpl.minimumUpdatePeriodTimeout_) {
        window.clearTimeout(mpl.minimumUpdatePeriodTimeout_);
        mpl.minimumUpdatePeriodTimeout_ = null;
      }
      var mup = mpl.master && mpl.master.minimumUpdatePeriod;
      if (mup === 0) {
        if (mpl.media()) {
          mup = mpl.media().targetDuration * 1000;
        } else {
          mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;
          mpl.one('loadedmetadata', mpl.createMupOnMedia_);
        }
      }
      if (typeof mup !== 'number' || mup <= 0) {
        if (mup < 0) {
          this.logger_("found invalid minimumUpdatePeriod of " + mup + ", not setting a timeout");
        }
        return;
      }
      this.createMUPTimeout_(mup);
    };
    _proto.createMUPTimeout_ = function createMUPTimeout_(mup) {
      var mpl = this.masterPlaylistLoader_;
      mpl.minimumUpdatePeriodTimeout_ = window.setTimeout(function () {
        mpl.minimumUpdatePeriodTimeout_ = null;
        mpl.trigger('minimumUpdatePeriod');
        mpl.createMUPTimeout_(mup);
      }, mup);
    }
    ;
    _proto.refreshXml_ = function refreshXml_() {
      var _this8 = this;
      this.requestMaster_(function (req, masterChanged) {
        if (!masterChanged) {
          return;
        }
        if (_this8.media_) {
          _this8.media_ = _this8.masterPlaylistLoader_.master.playlists[_this8.media_.id];
        }
        _this8.masterPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(_this8.masterPlaylistLoader_.master, _this8.masterPlaylistLoader_.sidxMapping_);
        _this8.addSidxSegments_(_this8.media(), _this8.state, function (sidxChanged) {
          _this8.refreshMedia_(_this8.media().id);
        });
      });
    }
    ;
    _proto.refreshMedia_ = function refreshMedia_(mediaID) {
      var _this9 = this;
      if (!mediaID) {
        throw new Error('refreshMedia_ must take a media id');
      }
      if (this.media_ && this.isMaster_) {
        this.handleMaster_();
      }
      var playlists = this.masterPlaylistLoader_.master.playlists;
      var mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];
      if (mediaChanged) {
        this.media_ = playlists[mediaID];
      } else {
        this.trigger('playlistunchanged');
      }
      if (!this.mediaUpdateTimeout) {
        var createMediaUpdateTimeout = function createMediaUpdateTimeout() {
          if (_this9.media().endList) {
            return;
          }
          _this9.mediaUpdateTimeout = window.setTimeout(function () {
            _this9.trigger('mediaupdatetimeout');
            createMediaUpdateTimeout();
          }, refreshDelay(_this9.media(), Boolean(mediaChanged)));
        };
        createMediaUpdateTimeout();
      }
      this.trigger('loadedplaylist');
    };
    return DashPlaylistLoader;
  }(EventTarget);
  var Config = {
    GOAL_BUFFER_LENGTH: 30,
    MAX_GOAL_BUFFER_LENGTH: 60,
    BACK_BUFFER_LENGTH: 30,
    GOAL_BUFFER_LENGTH_RATE: 1,
    INITIAL_BANDWIDTH: 4194304,
    BANDWIDTH_VARIANCE: 1.2,
    BUFFER_LOW_WATER_LINE: 0,
    MAX_BUFFER_LOW_WATER_LINE: 30,
    EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
    BUFFER_LOW_WATER_LINE_RATE: 1,
    BUFFER_HIGH_WATER_LINE: 30
  };
  var stringToArrayBuffer = function stringToArrayBuffer(string) {
    var view = new Uint8Array(new ArrayBuffer(string.length));
    for (var i = 0; i < string.length; i++) {
      view[i] = string.charCodeAt(i);
    }
    return view.buffer;
  };
  var browserWorkerPolyFill = function browserWorkerPolyFill(workerObj) {
    workerObj.on = workerObj.addEventListener;
    workerObj.off = workerObj.removeEventListener;
    return workerObj;
  };
  var createObjectURL = function createObjectURL(str) {
    try {
      return URL.createObjectURL(new Blob([str], {
        type: 'application/javascript'
      }));
    } catch (e) {
      var blob = new BlobBuilder();
      blob.append(str);
      return URL.createObjectURL(blob.getBlob());
    }
  };
  var factory = function factory(code) {
    return function () {
      var objectUrl = createObjectURL(code);
      var worker = browserWorkerPolyFill(new Worker(objectUrl));
      worker.objURL = objectUrl;
      var terminate = worker.terminate;
      worker.on = worker.addEventListener;
      worker.off = worker.removeEventListener;
      worker.terminate = function () {
        URL.revokeObjectURL(objectUrl);
        return terminate.call(this);
      };
      return worker;
    };
  };
  var transform = function transform(code) {
    return "var browserWorkerPolyFill = " + browserWorkerPolyFill.toString() + ";\n" + 'browserWorkerPolyFill(self);\n' + code;
  };
  var getWorkerString = function getWorkerString(fn) {
    return fn.toString().replace(/^function.+?{/, '').slice(0, -1);
  };
  var workerCode$1 = transform(getWorkerString(function () {
    var Stream = function Stream() {
      this.init = function () {
        var listeners = {};
        this.on = function (type, listener) {
          if (!listeners[type]) {
            listeners[type] = [];
          }
          listeners[type] = listeners[type].concat(listener);
        };
        this.off = function (type, listener) {
          var index;
          if (!listeners[type]) {
            return false;
          }
          index = listeners[type].indexOf(listener);
          listeners[type] = listeners[type].slice();
          listeners[type].splice(index, 1);
          return index > -1;
        };
        this.trigger = function (type) {
          var callbacks, i, length, args;
          callbacks = listeners[type];
          if (!callbacks) {
            return;
          }
          if (arguments.length === 2) {
            length = callbacks.length;
            for (i = 0; i < length; ++i) {
              callbacks[i].call(this, arguments[1]);
            }
          } else {
            args = [];
            i = arguments.length;
            for (i = 1; i < arguments.length; ++i) {
              args.push(arguments[i]);
            }
            length = callbacks.length;
            for (i = 0; i < length; ++i) {
              callbacks[i].apply(this, args);
            }
          }
        };
        this.dispose = function () {
          listeners = {};
        };
      };
    };
    Stream.prototype.pipe = function (destination) {
      this.on('data', function (data) {
        destination.push(data);
      });
      this.on('done', function (flushSource) {
        destination.flush(flushSource);
      });
      this.on('partialdone', function (flushSource) {
        destination.partialFlush(flushSource);
      });
      this.on('endedtimeline', function (flushSource) {
        destination.endTimeline(flushSource);
      });
      this.on('reset', function (flushSource) {
        destination.reset(flushSource);
      });
      return destination;
    };
    Stream.prototype.push = function (data) {
      this.trigger('data', data);
    };
    Stream.prototype.flush = function (flushSource) {
      this.trigger('done', flushSource);
    };
    Stream.prototype.partialFlush = function (flushSource) {
      this.trigger('partialdone', flushSource);
    };
    Stream.prototype.endTimeline = function (flushSource) {
      this.trigger('endedtimeline', flushSource);
    };
    Stream.prototype.reset = function (flushSource) {
      this.trigger('reset', flushSource);
    };
    var stream = Stream;
    var MAX_UINT32$1 = Math.pow(2, 32);
    var getUint64$2 = function getUint64(uint8) {
      var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
      var value;
      if (dv.getBigUint64) {
        value = dv.getBigUint64(0);
        if (value < Number.MAX_SAFE_INTEGER) {
          return Number(value);
        }
        return value;
      }
      return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);
    };
    var numbers = {
      getUint64: getUint64$2,
      MAX_UINT32: MAX_UINT32$1
    };
    var MAX_UINT32 = numbers.MAX_UINT32;
    var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;
    (function () {
      var i;
      types = {
        avc1: [],
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        smhd: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        styp: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: []
      };
      if (typeof Uint8Array === 'undefined') {
        return;
      }
      for (i in types) {
        if (types.hasOwnProperty(i)) {
          types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }
      MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);
      AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);
      MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);
      VIDEO_HDLR = new Uint8Array([0x00,
      0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x76, 0x69, 0x64, 0x65,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00
      ]);
      AUDIO_HDLR = new Uint8Array([0x00,
      0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x73, 0x6f, 0x75, 0x6e,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00
      ]);
      HDLR_TYPES = {
        video: VIDEO_HDLR,
        audio: AUDIO_HDLR
      };
      DREF = new Uint8Array([0x00,
      0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x01,
      0x00, 0x00, 0x00, 0x0c,
      0x75, 0x72, 0x6c, 0x20,
      0x00,
      0x00, 0x00, 0x01
      ]);
      SMHD = new Uint8Array([0x00,
      0x00, 0x00, 0x00,
      0x00, 0x00,
      0x00, 0x00
      ]);
      STCO = new Uint8Array([0x00,
      0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
      ]);
      STSC = STCO;
      STSZ = new Uint8Array([0x00,
      0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
      ]);
      STTS = STCO;
      VMHD = new Uint8Array([0x00,
      0x00, 0x00, 0x01,
      0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00
      ]);
    })();
    box = function box(type) {
      var payload = [],
          size = 0,
          i,
          result,
          view;
      for (i = 1; i < arguments.length; i++) {
        payload.push(arguments[i]);
      }
      i = payload.length;
      while (i--) {
        size += payload[i].byteLength;
      }
      result = new Uint8Array(size + 8);
      view = new DataView(result.buffer, result.byteOffset, result.byteLength);
      view.setUint32(0, result.byteLength);
      result.set(type, 4);
      for (i = 0, size = 8; i < payload.length; i++) {
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    };
    dinf = function dinf() {
      return box(types.dinf, box(types.dref, DREF));
    };
    esds = function esds(track) {
      return box(types.esds, new Uint8Array([0x00,
      0x00, 0x00, 0x00,
      0x03,
      0x19,
      0x00, 0x00,
      0x00,
      0x04,
      0x11,
      0x40,
      0x15,
      0x00, 0x06, 0x00,
      0x00, 0x00, 0xda, 0xc0,
      0x00, 0x00, 0xda, 0xc0,
      0x05,
      0x02,
      track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02
      ]));
    };
    ftyp = function ftyp() {
      return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);
    };
    hdlr = function hdlr(type) {
      return box(types.hdlr, HDLR_TYPES[type]);
    };
    mdat = function mdat(data) {
      return box(types.mdat, data);
    };
    mdhd = function mdhd(track) {
      var result = new Uint8Array([0x00,
      0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x02,
      0x00, 0x00, 0x00, 0x03,
      0x00, 0x01, 0x5f, 0x90,
      track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF,
      0x55, 0xc4,
      0x00, 0x00]);
      if (track.samplerate) {
        result[12] = track.samplerate >>> 24 & 0xFF;
        result[13] = track.samplerate >>> 16 & 0xFF;
        result[14] = track.samplerate >>> 8 & 0xFF;
        result[15] = track.samplerate & 0xFF;
      }
      return box(types.mdhd, result);
    };
    mdia = function mdia(track) {
      return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));
    };
    mfhd = function mfhd(sequenceNumber) {
      return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,
      (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF
      ]));
    };
    minf = function minf(track) {
      return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));
    };
    moof = function moof(sequenceNumber, tracks) {
      var trackFragments = [],
          i = tracks.length;
      while (i--) {
        trackFragments[i] = traf(tracks[i]);
      }
      return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));
    };
    moov = function moov(tracks) {
      var i = tracks.length,
          boxes = [];
      while (i--) {
        boxes[i] = trak(tracks[i]);
      }
      return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));
    };
    mvex = function mvex(tracks) {
      var i = tracks.length,
          boxes = [];
      while (i--) {
        boxes[i] = trex(tracks[i]);
      }
      return box.apply(null, [types.mvex].concat(boxes));
    };
    mvhd = function mvhd(duration) {
      var bytes = new Uint8Array([0x00,
      0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x01,
      0x00, 0x00, 0x00, 0x02,
      0x00, 0x01, 0x5f, 0x90,
      (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF,
      0x00, 0x01, 0x00, 0x00,
      0x01, 0x00,
      0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff
      ]);
      return box(types.mvhd, bytes);
    };
    sdtp = function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags,
          i;
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }
      return box(types.sdtp, bytes);
    };
    stbl = function stbl(track) {
      return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));
    };
    (function () {
      var videoSample, audioSample;
      stsd = function stsd(track) {
        return box(types.stsd, new Uint8Array([0x00,
        0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));
      };
      videoSample = function videoSample(track) {
        var sps = track.sps || [],
            pps = track.pps || [],
            sequenceParameterSets = [],
            pictureParameterSets = [],
            i,
            avc1Box;
        for (i = 0; i < sps.length; i++) {
          sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);
          sequenceParameterSets.push(sps[i].byteLength & 0xFF);
          sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i]));
        }
        for (i = 0; i < pps.length; i++) {
          pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);
          pictureParameterSets.push(pps[i].byteLength & 0xFF);
          pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));
        }
        avc1Box = [types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01,
        0x00, 0x00,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        (track.width & 0xff00) >> 8, track.width & 0xff,
        (track.height & 0xff00) >> 8, track.height & 0xff,
        0x00, 0x48, 0x00, 0x00,
        0x00, 0x48, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x01,
        0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x18,
        0x11, 0x11
        ]), box(types.avcC, new Uint8Array([0x01,
        track.profileIdc,
        track.profileCompatibility,
        track.levelIdc,
        0xff
        ].concat([sps.length],
        sequenceParameterSets,
        [pps.length],
        pictureParameterSets
        ))), box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,
        0x00, 0x2d, 0xc6, 0xc0,
        0x00, 0x2d, 0xc6, 0xc0
        ]))];
        if (track.sarRatio) {
          var hSpacing = track.sarRatio[0],
              vSpacing = track.sarRatio[1];
          avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 0xFF000000) >> 24, (hSpacing & 0xFF0000) >> 16, (hSpacing & 0xFF00) >> 8, hSpacing & 0xFF, (vSpacing & 0xFF000000) >> 24, (vSpacing & 0xFF0000) >> 16, (vSpacing & 0xFF00) >> 8, vSpacing & 0xFF])));
        }
        return box.apply(null, avc1Box);
      };
      audioSample = function audioSample(track) {
        return box(types.mp4a, new Uint8Array([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff,
        (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff,
        0x00, 0x00,
        0x00, 0x00,
        (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00
        ]), esds(track));
      };
    })();
    tkhd = function tkhd(track) {
      var result = new Uint8Array([0x00,
      0x00, 0x00, 0x07,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,
      0x00, 0x00, 0x00, 0x00,
      (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00,
      0x00, 0x00,
      0x01, 0x00,
      0x00, 0x00,
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
      (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00,
      (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00
      ]);
      return box(types.tkhd, result);
    };
    traf = function traf(track) {
      var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;
      trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00,
      0x00, 0x00, 0x3a,
      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,
      0x00, 0x00, 0x00, 0x01,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
      ]));
      upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);
      lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);
      trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01,
      0x00, 0x00, 0x00,
      upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF]));
      dataOffset = 32 +
      20 +
      8 +
      16 +
      8 +
      8;
      if (track.type === 'audio') {
        trackFragmentRun = trun$1(track, dataOffset);
        return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);
      }
      sampleDependencyTable = sdtp(track);
      trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);
      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);
    };
    trak = function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return box(types.trak, tkhd(track), mdia(track));
    };
    trex = function trex(track) {
      var result = new Uint8Array([0x00,
      0x00, 0x00, 0x00,
      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,
      0x00, 0x00, 0x00, 0x01,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x01, 0x00, 0x01
      ]);
      if (track.type !== 'video') {
        result[result.length - 1] = 0x00;
      }
      return box(types.trex, result);
    };
    (function () {
      var audioTrun, videoTrun, trunHeader;
      trunHeader = function trunHeader(samples, offset) {
        var durationPresent = 0,
            sizePresent = 0,
            flagsPresent = 0,
            compositionTimeOffset = 0;
        if (samples.length) {
          if (samples[0].duration !== undefined) {
            durationPresent = 0x1;
          }
          if (samples[0].size !== undefined) {
            sizePresent = 0x2;
          }
          if (samples[0].flags !== undefined) {
            flagsPresent = 0x4;
          }
          if (samples[0].compositionTimeOffset !== undefined) {
            compositionTimeOffset = 0x8;
          }
        }
        return [0x00,
        0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01,
        (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF,
        (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF
        ];
      };
      videoTrun = function videoTrun(track, offset) {
        var bytesOffest, bytes, header, samples, sample, i;
        samples = track.samples || [];
        offset += 8 + 12 + 16 * samples.length;
        header = trunHeader(samples, offset);
        bytes = new Uint8Array(header.length + samples.length * 16);
        bytes.set(header);
        bytesOffest = header.length;
        for (i = 0; i < samples.length; i++) {
          sample = samples[i];
          bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;
          bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;
          bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;
          bytes[bytesOffest++] = sample.duration & 0xFF;
          bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;
          bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;
          bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;
          bytes[bytesOffest++] = sample.size & 0xFF;
          bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;
          bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;
          bytes[bytesOffest++] = sample.flags.degradationPriority & 0xF0 << 8;
          bytes[bytesOffest++] = sample.flags.degradationPriority & 0x0F;
          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF000000) >>> 24;
          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF0000) >>> 16;
          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF00) >>> 8;
          bytes[bytesOffest++] = sample.compositionTimeOffset & 0xFF;
        }
        return box(types.trun, bytes);
      };
      audioTrun = function audioTrun(track, offset) {
        var bytes, bytesOffest, header, samples, sample, i;
        samples = track.samples || [];
        offset += 8 + 12 + 8 * samples.length;
        header = trunHeader(samples, offset);
        bytes = new Uint8Array(header.length + samples.length * 8);
        bytes.set(header);
        bytesOffest = header.length;
        for (i = 0; i < samples.length; i++) {
          sample = samples[i];
          bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;
          bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;
          bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;
          bytes[bytesOffest++] = sample.duration & 0xFF;
          bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;
          bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;
          bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;
          bytes[bytesOffest++] = sample.size & 0xFF;
        }
        return box(types.trun, bytes);
      };
      trun$1 = function trun(track, offset) {
        if (track.type === 'audio') {
          return audioTrun(track, offset);
        }
        return videoTrun(track, offset);
      };
    })();
    var mp4Generator = {
      ftyp: ftyp,
      mdat: mdat,
      moof: moof,
      moov: moov,
      initSegment: function initSegment(tracks) {
        var fileType = ftyp(),
            movie = moov(tracks),
            result;
        result = new Uint8Array(fileType.byteLength + movie.byteLength);
        result.set(fileType);
        result.set(movie, fileType.byteLength);
        return result;
      }
    };
    var groupNalsIntoFrames = function groupNalsIntoFrames(nalUnits) {
      var i,
          currentNal,
          currentFrame = [],
          frames = [];
      frames.byteLength = 0;
      frames.nalCount = 0;
      frames.duration = 0;
      currentFrame.byteLength = 0;
      for (i = 0; i < nalUnits.length; i++) {
        currentNal = nalUnits[i];
        if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {
          if (currentFrame.length) {
            currentFrame.duration = currentNal.dts - currentFrame.dts;
            frames.byteLength += currentFrame.byteLength;
            frames.nalCount += currentFrame.length;
            frames.duration += currentFrame.duration;
            frames.push(currentFrame);
          }
          currentFrame = [currentNal];
          currentFrame.byteLength = currentNal.data.byteLength;
          currentFrame.pts = currentNal.pts;
          currentFrame.dts = currentNal.dts;
        } else {
          if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {
            currentFrame.keyFrame = true;
          }
          currentFrame.duration = currentNal.dts - currentFrame.dts;
          currentFrame.byteLength += currentNal.data.byteLength;
          currentFrame.push(currentNal);
        }
      }
      if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {
        currentFrame.duration = frames[frames.length - 1].duration;
      }
      frames.byteLength += currentFrame.byteLength;
      frames.nalCount += currentFrame.length;
      frames.duration += currentFrame.duration;
      frames.push(currentFrame);
      return frames;
    };
    var groupFramesIntoGops = function groupFramesIntoGops(frames) {
      var i,
          currentFrame,
          currentGop = [],
          gops = [];
      currentGop.byteLength = 0;
      currentGop.nalCount = 0;
      currentGop.duration = 0;
      currentGop.pts = frames[0].pts;
      currentGop.dts = frames[0].dts;
      gops.byteLength = 0;
      gops.nalCount = 0;
      gops.duration = 0;
      gops.pts = frames[0].pts;
      gops.dts = frames[0].dts;
      for (i = 0; i < frames.length; i++) {
        currentFrame = frames[i];
        if (currentFrame.keyFrame) {
          if (currentGop.length) {
            gops.push(currentGop);
            gops.byteLength += currentGop.byteLength;
            gops.nalCount += currentGop.nalCount;
            gops.duration += currentGop.duration;
          }
          currentGop = [currentFrame];
          currentGop.nalCount = currentFrame.length;
          currentGop.byteLength = currentFrame.byteLength;
          currentGop.pts = currentFrame.pts;
          currentGop.dts = currentFrame.dts;
          currentGop.duration = currentFrame.duration;
        } else {
          currentGop.duration += currentFrame.duration;
          currentGop.nalCount += currentFrame.length;
          currentGop.byteLength += currentFrame.byteLength;
          currentGop.push(currentFrame);
        }
      }
      if (gops.length && currentGop.duration <= 0) {
        currentGop.duration = gops[gops.length - 1].duration;
      }
      gops.byteLength += currentGop.byteLength;
      gops.nalCount += currentGop.nalCount;
      gops.duration += currentGop.duration;
      gops.push(currentGop);
      return gops;
    };
    var extendFirstKeyFrame = function extendFirstKeyFrame(gops) {
      var currentGop;
      if (!gops[0][0].keyFrame && gops.length > 1) {
        currentGop = gops.shift();
        gops.byteLength -= currentGop.byteLength;
        gops.nalCount -= currentGop.nalCount;
        gops[0][0].dts = currentGop.dts;
        gops[0][0].pts = currentGop.pts;
        gops[0][0].duration += currentGop.duration;
      }
      return gops;
    };
    var createDefaultSample = function createDefaultSample() {
      return {
        size: 0,
        flags: {
          isLeading: 0,
          dependsOn: 1,
          isDependedOn: 0,
          hasRedundancy: 0,
          degradationPriority: 0,
          isNonSyncSample: 1
        }
      };
    };
    var sampleForFrame = function sampleForFrame(frame, dataOffset) {
      var sample = createDefaultSample();
      sample.dataOffset = dataOffset;
      sample.compositionTimeOffset = frame.pts - frame.dts;
      sample.duration = frame.duration;
      sample.size = 4 * frame.length;
      sample.size += frame.byteLength;
      if (frame.keyFrame) {
        sample.flags.dependsOn = 2;
        sample.flags.isNonSyncSample = 0;
      }
      return sample;
    };
    var generateSampleTable$1 = function generateSampleTable(gops, baseDataOffset) {
      var h,
          i,
          sample,
          currentGop,
          currentFrame,
          dataOffset = baseDataOffset || 0,
          samples = [];
      for (h = 0; h < gops.length; h++) {
        currentGop = gops[h];
        for (i = 0; i < currentGop.length; i++) {
          currentFrame = currentGop[i];
          sample = sampleForFrame(currentFrame, dataOffset);
          dataOffset += sample.size;
          samples.push(sample);
        }
      }
      return samples;
    };
    var concatenateNalData = function concatenateNalData(gops) {
      var h,
          i,
          j,
          currentGop,
          currentFrame,
          currentNal,
          dataOffset = 0,
          nalsByteLength = gops.byteLength,
          numberOfNals = gops.nalCount,
          totalByteLength = nalsByteLength + 4 * numberOfNals,
          data = new Uint8Array(totalByteLength),
          view = new DataView(data.buffer);
      for (h = 0; h < gops.length; h++) {
        currentGop = gops[h];
        for (i = 0; i < currentGop.length; i++) {
          currentFrame = currentGop[i];
          for (j = 0; j < currentFrame.length; j++) {
            currentNal = currentFrame[j];
            view.setUint32(dataOffset, currentNal.data.byteLength);
            dataOffset += 4;
            data.set(currentNal.data, dataOffset);
            dataOffset += currentNal.data.byteLength;
          }
        }
      }
      return data;
    };
    var generateSampleTableForFrame = function generateSampleTableForFrame(frame, baseDataOffset) {
      var sample,
          dataOffset = baseDataOffset || 0,
          samples = [];
      sample = sampleForFrame(frame, dataOffset);
      samples.push(sample);
      return samples;
    };
    var concatenateNalDataForFrame = function concatenateNalDataForFrame(frame) {
      var i,
          currentNal,
          dataOffset = 0,
          nalsByteLength = frame.byteLength,
          numberOfNals = frame.length,
          totalByteLength = nalsByteLength + 4 * numberOfNals,
          data = new Uint8Array(totalByteLength),
          view = new DataView(data.buffer);
      for (i = 0; i < frame.length; i++) {
        currentNal = frame[i];
        view.setUint32(dataOffset, currentNal.data.byteLength);
        dataOffset += 4;
        data.set(currentNal.data, dataOffset);
        dataOffset += currentNal.data.byteLength;
      }
      return data;
    };
    var frameUtils = {
      groupNalsIntoFrames: groupNalsIntoFrames,
      groupFramesIntoGops: groupFramesIntoGops,
      extendFirstKeyFrame: extendFirstKeyFrame,
      generateSampleTable: generateSampleTable$1,
      concatenateNalData: concatenateNalData,
      generateSampleTableForFrame: generateSampleTableForFrame,
      concatenateNalDataForFrame: concatenateNalDataForFrame
    };
    var highPrefix = [33, 16, 5, 32, 164, 27];
    var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];
    var zeroFill = function zeroFill(count) {
      var a = [];
      while (count--) {
        a.push(0);
      }
      return a;
    };
    var makeTable = function makeTable(metaTable) {
      return Object.keys(metaTable).reduce(function (obj, key) {
        obj[key] = new Uint8Array(metaTable[key].reduce(function (arr, part) {
          return arr.concat(part);
        }, []));
        return obj;
      }, {});
    };
    var silence;
    var silence_1 = function silence_1() {
      if (!silence) {
        var coneOfSilence = {
          96000: [highPrefix, [227, 64], zeroFill(154), [56]],
          88200: [highPrefix, [231], zeroFill(170), [56]],
          64000: [highPrefix, [248, 192], zeroFill(240), [56]],
          48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],
          44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],
          32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],
          24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],
          16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],
          12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],
          11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],
          8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]
        };
        silence = makeTable(coneOfSilence);
      }
      return silence;
    };
    var ONE_SECOND_IN_TS$4 = 90000,
    secondsToVideoTs,
        secondsToAudioTs,
        videoTsToSeconds,
        audioTsToSeconds,
        audioTsToVideoTs,
        videoTsToAudioTs,
        metadataTsToSeconds;
    secondsToVideoTs = function secondsToVideoTs(seconds) {
      return seconds * ONE_SECOND_IN_TS$4;
    };
    secondsToAudioTs = function secondsToAudioTs(seconds, sampleRate) {
      return seconds * sampleRate;
    };
    videoTsToSeconds = function videoTsToSeconds(timestamp) {
      return timestamp / ONE_SECOND_IN_TS$4;
    };
    audioTsToSeconds = function audioTsToSeconds(timestamp, sampleRate) {
      return timestamp / sampleRate;
    };
    audioTsToVideoTs = function audioTsToVideoTs(timestamp, sampleRate) {
      return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
    };
    videoTsToAudioTs = function videoTsToAudioTs(timestamp, sampleRate) {
      return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
    };
    metadataTsToSeconds = function metadataTsToSeconds(timestamp, timelineStartPts, keepOriginalTimestamps) {
      return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
    };
    var clock = {
      ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,
      secondsToVideoTs: secondsToVideoTs,
      secondsToAudioTs: secondsToAudioTs,
      videoTsToSeconds: videoTsToSeconds,
      audioTsToSeconds: audioTsToSeconds,
      audioTsToVideoTs: audioTsToVideoTs,
      videoTsToAudioTs: videoTsToAudioTs,
      metadataTsToSeconds: metadataTsToSeconds
    };
    var sumFrameByteLengths = function sumFrameByteLengths(array) {
      var i,
          currentObj,
          sum = 0;
      for (i = 0; i < array.length; i++) {
        currentObj = array[i];
        sum += currentObj.data.byteLength;
      }
      return sum;
    };
    var prefixWithSilence = function prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {
      var baseMediaDecodeTimeTs,
          frameDuration = 0,
          audioGapDuration = 0,
          audioFillFrameCount = 0,
          audioFillDuration = 0,
          silentFrame,
          i,
          firstFrame;
      if (!frames.length) {
        return;
      }
      baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);
      frameDuration = Math.ceil(clock.ONE_SECOND_IN_TS / (track.samplerate / 1024));
      if (audioAppendStartTs && videoBaseMediaDecodeTime) {
        audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);
        audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);
        audioFillDuration = audioFillFrameCount * frameDuration;
      }
      if (audioFillFrameCount < 1 || audioFillDuration > clock.ONE_SECOND_IN_TS / 2) {
        return;
      }
      silentFrame = silence_1()[track.samplerate];
      if (!silentFrame) {
        silentFrame = frames[0].data;
      }
      for (i = 0; i < audioFillFrameCount; i++) {
        firstFrame = frames[0];
        frames.splice(0, 0, {
          data: silentFrame,
          dts: firstFrame.dts - frameDuration,
          pts: firstFrame.pts - frameDuration
        });
      }
      track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));
      return audioFillDuration;
    };
    var trimAdtsFramesByEarliestDts = function trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts) {
      if (track.minSegmentDts >= earliestAllowedDts) {
        return adtsFrames;
      }
      track.minSegmentDts = Infinity;
      return adtsFrames.filter(function (currentFrame) {
        if (currentFrame.dts >= earliestAllowedDts) {
          track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);
          track.minSegmentPts = track.minSegmentDts;
          return true;
        }
        return false;
      });
    };
    var generateSampleTable = function generateSampleTable(frames) {
      var i,
          currentFrame,
          samples = [];
      for (i = 0; i < frames.length; i++) {
        currentFrame = frames[i];
        samples.push({
          size: currentFrame.data.byteLength,
          duration: 1024
        });
      }
      return samples;
    };
    var concatenateFrameData = function concatenateFrameData(frames) {
      var i,
          currentFrame,
          dataOffset = 0,
          data = new Uint8Array(sumFrameByteLengths(frames));
      for (i = 0; i < frames.length; i++) {
        currentFrame = frames[i];
        data.set(currentFrame.data, dataOffset);
        dataOffset += currentFrame.data.byteLength;
      }
      return data;
    };
    var audioFrameUtils = {
      prefixWithSilence: prefixWithSilence,
      trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,
      generateSampleTable: generateSampleTable,
      concatenateFrameData: concatenateFrameData
    };
    var ONE_SECOND_IN_TS$3 = clock.ONE_SECOND_IN_TS;
    var collectDtsInfo = function collectDtsInfo(track, data) {
      if (typeof data.pts === 'number') {
        if (track.timelineStartInfo.pts === undefined) {
          track.timelineStartInfo.pts = data.pts;
        }
        if (track.minSegmentPts === undefined) {
          track.minSegmentPts = data.pts;
        } else {
          track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);
        }
        if (track.maxSegmentPts === undefined) {
          track.maxSegmentPts = data.pts;
        } else {
          track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);
        }
      }
      if (typeof data.dts === 'number') {
        if (track.timelineStartInfo.dts === undefined) {
          track.timelineStartInfo.dts = data.dts;
        }
        if (track.minSegmentDts === undefined) {
          track.minSegmentDts = data.dts;
        } else {
          track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);
        }
        if (track.maxSegmentDts === undefined) {
          track.maxSegmentDts = data.dts;
        } else {
          track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);
        }
      }
    };
    var clearDtsInfo = function clearDtsInfo(track) {
      delete track.minSegmentDts;
      delete track.maxSegmentDts;
      delete track.minSegmentPts;
      delete track.maxSegmentPts;
    };
    var calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime(track, keepOriginalTimestamps) {
      var baseMediaDecodeTime,
          scale,
          minSegmentDts = track.minSegmentDts;
      if (!keepOriginalTimestamps) {
        minSegmentDts -= track.timelineStartInfo.dts;
      }
      baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;
      baseMediaDecodeTime += minSegmentDts;
      baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);
      if (track.type === 'audio') {
        scale = track.samplerate / ONE_SECOND_IN_TS$3;
        baseMediaDecodeTime *= scale;
        baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);
      }
      return baseMediaDecodeTime;
    };
    var trackDecodeInfo = {
      clearDtsInfo: clearDtsInfo,
      calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,
      collectDtsInfo: collectDtsInfo
    };
    var USER_DATA_REGISTERED_ITU_T_T35 = 4,
        RBSP_TRAILING_BITS = 128;
    var parseSei = function parseSei(bytes) {
      var i = 0,
          result = {
        payloadType: -1,
        payloadSize: 0
      },
          payloadType = 0,
          payloadSize = 0;
      while (i < bytes.byteLength) {
        if (bytes[i] === RBSP_TRAILING_BITS) {
          break;
        }
        while (bytes[i] === 0xFF) {
          payloadType += 255;
          i++;
        }
        payloadType += bytes[i++];
        while (bytes[i] === 0xFF) {
          payloadSize += 255;
          i++;
        }
        payloadSize += bytes[i++];
        if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {
          var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);
          if (userIdentifier === 'GA94') {
            result.payloadType = payloadType;
            result.payloadSize = payloadSize;
            result.payload = bytes.subarray(i, i + payloadSize);
            break;
          } else {
            result.payload = void 0;
          }
        }
        i += payloadSize;
        payloadType = 0;
        payloadSize = 0;
      }
      return result;
    };
    var parseUserData = function parseUserData(sei) {
      if (sei.payload[0] !== 181) {
        return null;
      }
      if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {
        return null;
      }
      if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {
        return null;
      }
      if (sei.payload[7] !== 0x03) {
        return null;
      }
      return sei.payload.subarray(8, sei.payload.length - 1);
    };
    var parseCaptionPackets = function parseCaptionPackets(pts, userData) {
      var results = [],
          i,
          count,
          offset,
          data;
      if (!(userData[0] & 0x40)) {
        return results;
      }
      count = userData[0] & 0x1f;
      for (i = 0; i < count; i++) {
        offset = i * 3;
        data = {
          type: userData[offset + 2] & 0x03,
          pts: pts
        };
        if (userData[offset + 2] & 0x04) {
          data.ccData = userData[offset + 3] << 8 | userData[offset + 4];
          results.push(data);
        }
      }
      return results;
    };
    var discardEmulationPreventionBytes$1 = function discardEmulationPreventionBytes(data) {
      var length = data.byteLength,
          emulationPreventionBytesPositions = [],
          i = 1,
          newLength,
          newData;
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          emulationPreventionBytesPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }
      if (emulationPreventionBytesPositions.length === 0) {
        return data;
      }
      newLength = length - emulationPreventionBytesPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;
      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === emulationPreventionBytesPositions[0]) {
          sourceIndex++;
          emulationPreventionBytesPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    };
    var captionPacketParser = {
      parseSei: parseSei,
      parseUserData: parseUserData,
      parseCaptionPackets: parseCaptionPackets,
      discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,
      USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35
    };
    var CaptionStream$1 = function CaptionStream(options) {
      options = options || {};
      CaptionStream.prototype.init.call(this);
      this.parse708captions_ = typeof options.parse708captions === 'boolean' ? options.parse708captions : true;
      this.captionPackets_ = [];
      this.ccStreams_ = [new Cea608Stream(0, 0),
      new Cea608Stream(0, 1),
      new Cea608Stream(1, 0),
      new Cea608Stream(1, 1)
      ];
      if (this.parse708captions_) {
        this.cc708Stream_ = new Cea708Stream({
          captionServices: options.captionServices
        });
      }
      this.reset();
      this.ccStreams_.forEach(function (cc) {
        cc.on('data', this.trigger.bind(this, 'data'));
        cc.on('partialdone', this.trigger.bind(this, 'partialdone'));
        cc.on('done', this.trigger.bind(this, 'done'));
      }, this);
      if (this.parse708captions_) {
        this.cc708Stream_.on('data', this.trigger.bind(this, 'data'));
        this.cc708Stream_.on('partialdone', this.trigger.bind(this, 'partialdone'));
        this.cc708Stream_.on('done', this.trigger.bind(this, 'done'));
      }
    };
    CaptionStream$1.prototype = new stream();
    CaptionStream$1.prototype.push = function (event) {
      var sei, userData, newCaptionPackets;
      if (event.nalUnitType !== 'sei_rbsp') {
        return;
      }
      sei = captionPacketParser.parseSei(event.escapedRBSP);
      if (!sei.payload) {
        return;
      }
      if (sei.payloadType !== captionPacketParser.USER_DATA_REGISTERED_ITU_T_T35) {
        return;
      }
      userData = captionPacketParser.parseUserData(sei);
      if (!userData) {
        return;
      }
      if (event.dts < this.latestDts_) {
        this.ignoreNextEqualDts_ = true;
        return;
      } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
        this.numSameDts_--;
        if (!this.numSameDts_) {
          this.ignoreNextEqualDts_ = false;
        }
        return;
      }
      newCaptionPackets = captionPacketParser.parseCaptionPackets(event.pts, userData);
      this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);
      if (this.latestDts_ !== event.dts) {
        this.numSameDts_ = 0;
      }
      this.numSameDts_++;
      this.latestDts_ = event.dts;
    };
    CaptionStream$1.prototype.flushCCStreams = function (flushType) {
      this.ccStreams_.forEach(function (cc) {
        return flushType === 'flush' ? cc.flush() : cc.partialFlush();
      }, this);
    };
    CaptionStream$1.prototype.flushStream = function (flushType) {
      if (!this.captionPackets_.length) {
        this.flushCCStreams(flushType);
        return;
      }
      this.captionPackets_.forEach(function (elem, idx) {
        elem.presortIndex = idx;
      });
      this.captionPackets_.sort(function (a, b) {
        if (a.pts === b.pts) {
          return a.presortIndex - b.presortIndex;
        }
        return a.pts - b.pts;
      });
      this.captionPackets_.forEach(function (packet) {
        if (packet.type < 2) {
          this.dispatchCea608Packet(packet);
        } else {
          this.dispatchCea708Packet(packet);
        }
      }, this);
      this.captionPackets_.length = 0;
      this.flushCCStreams(flushType);
    };
    CaptionStream$1.prototype.flush = function () {
      return this.flushStream('flush');
    };
    CaptionStream$1.prototype.partialFlush = function () {
      return this.flushStream('partialFlush');
    };
    CaptionStream$1.prototype.reset = function () {
      this.latestDts_ = null;
      this.ignoreNextEqualDts_ = false;
      this.numSameDts_ = 0;
      this.activeCea608Channel_ = [null, null];
      this.ccStreams_.forEach(function (ccStream) {
        ccStream.reset();
      });
    };
    CaptionStream$1.prototype.dispatchCea608Packet = function (packet) {
      if (this.setsTextOrXDSActive(packet)) {
        this.activeCea608Channel_[packet.type] = null;
      } else if (this.setsChannel1Active(packet)) {
        this.activeCea608Channel_[packet.type] = 0;
      } else if (this.setsChannel2Active(packet)) {
        this.activeCea608Channel_[packet.type] = 1;
      }
      if (this.activeCea608Channel_[packet.type] === null) {
        return;
      }
      this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);
    };
    CaptionStream$1.prototype.setsChannel1Active = function (packet) {
      return (packet.ccData & 0x7800) === 0x1000;
    };
    CaptionStream$1.prototype.setsChannel2Active = function (packet) {
      return (packet.ccData & 0x7800) === 0x1800;
    };
    CaptionStream$1.prototype.setsTextOrXDSActive = function (packet) {
      return (packet.ccData & 0x7100) === 0x0100 || (packet.ccData & 0x78fe) === 0x102a || (packet.ccData & 0x78fe) === 0x182a;
    };
    CaptionStream$1.prototype.dispatchCea708Packet = function (packet) {
      if (this.parse708captions_) {
        this.cc708Stream_.push(packet);
      }
    };
    var CHARACTER_TRANSLATION_708 = {
      0x7f: 0x266a,
      0x1020: 0x20,
      0x1021: 0xa0,
      0x1025: 0x2026,
      0x102a: 0x0160,
      0x102c: 0x0152,
      0x1030: 0x2588,
      0x1031: 0x2018,
      0x1032: 0x2019,
      0x1033: 0x201c,
      0x1034: 0x201d,
      0x1035: 0x2022,
      0x1039: 0x2122,
      0x103a: 0x0161,
      0x103c: 0x0153,
      0x103d: 0x2120,
      0x103f: 0x0178,
      0x1076: 0x215b,
      0x1077: 0x215c,
      0x1078: 0x215d,
      0x1079: 0x215e,
      0x107a: 0x23d0,
      0x107b: 0x23a4,
      0x107c: 0x23a3,
      0x107d: 0x23af,
      0x107e: 0x23a6,
      0x107f: 0x23a1,
      0x10a0: 0x3138
    };
    var get708CharFromCode = function get708CharFromCode(code) {
      var newCode = CHARACTER_TRANSLATION_708[code] || code;
      if (code & 0x1000 && code === newCode) {
        return '';
      }
      return String.fromCharCode(newCode);
    };
    var within708TextBlock = function within708TextBlock(b) {
      return 0x20 <= b && b <= 0x7f || 0xa0 <= b && b <= 0xff;
    };
    var Cea708Window = function Cea708Window(windowNum) {
      this.windowNum = windowNum;
      this.reset();
    };
    Cea708Window.prototype.reset = function () {
      this.clearText();
      this.pendingNewLine = false;
      this.winAttr = {};
      this.penAttr = {};
      this.penLoc = {};
      this.penColor = {};
      this.visible = 0;
      this.rowLock = 0;
      this.columnLock = 0;
      this.priority = 0;
      this.relativePositioning = 0;
      this.anchorVertical = 0;
      this.anchorHorizontal = 0;
      this.anchorPoint = 0;
      this.rowCount = 1;
      this.virtualRowCount = this.rowCount + 1;
      this.columnCount = 41;
      this.windowStyle = 0;
      this.penStyle = 0;
    };
    Cea708Window.prototype.getText = function () {
      return this.rows.join('\n');
    };
    Cea708Window.prototype.clearText = function () {
      this.rows = [''];
      this.rowIdx = 0;
    };
    Cea708Window.prototype.newLine = function (pts) {
      if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === 'function') {
        this.beforeRowOverflow(pts);
      }
      if (this.rows.length > 0) {
        this.rows.push('');
        this.rowIdx++;
      }
      while (this.rows.length > this.virtualRowCount) {
        this.rows.shift();
        this.rowIdx--;
      }
    };
    Cea708Window.prototype.isEmpty = function () {
      if (this.rows.length === 0) {
        return true;
      } else if (this.rows.length === 1) {
        return this.rows[0] === '';
      }
      return false;
    };
    Cea708Window.prototype.addText = function (text) {
      this.rows[this.rowIdx] += text;
    };
    Cea708Window.prototype.backspace = function () {
      if (!this.isEmpty()) {
        var row = this.rows[this.rowIdx];
        this.rows[this.rowIdx] = row.substr(0, row.length - 1);
      }
    };
    var Cea708Service = function Cea708Service(serviceNum, encoding, stream) {
      this.serviceNum = serviceNum;
      this.text = '';
      this.currentWindow = new Cea708Window(-1);
      this.windows = [];
      this.stream = stream;
      if (typeof encoding === 'string') {
        this.createTextDecoder(encoding);
      }
    };
    Cea708Service.prototype.init = function (pts, beforeRowOverflow) {
      this.startPts = pts;
      for (var win = 0; win < 8; win++) {
        this.windows[win] = new Cea708Window(win);
        if (typeof beforeRowOverflow === 'function') {
          this.windows[win].beforeRowOverflow = beforeRowOverflow;
        }
      }
    };
    Cea708Service.prototype.setCurrentWindow = function (windowNum) {
      this.currentWindow = this.windows[windowNum];
    };
    Cea708Service.prototype.createTextDecoder = function (encoding) {
      if (typeof TextDecoder === 'undefined') {
        this.stream.trigger('log', {
          level: 'warn',
          message: 'The `encoding` option is unsupported without TextDecoder support'
        });
      } else {
        try {
          this.textDecoder_ = new TextDecoder(encoding);
        } catch (error) {
          this.stream.trigger('log', {
            level: 'warn',
            message: 'TextDecoder could not be created with ' + encoding + ' encoding. ' + error
          });
        }
      }
    };
    var Cea708Stream = function Cea708Stream(options) {
      options = options || {};
      Cea708Stream.prototype.init.call(this);
      var self = this;
      var captionServices = options.captionServices || {};
      var captionServiceEncodings = {};
      var serviceProps;
      Object.keys(captionServices).forEach(function (serviceName) {
        serviceProps = captionServices[serviceName];
        if (/^SERVICE/.test(serviceName)) {
          captionServiceEncodings[serviceName] = serviceProps.encoding;
        }
      });
      this.serviceEncodings = captionServiceEncodings;
      this.current708Packet = null;
      this.services = {};
      this.push = function (packet) {
        if (packet.type === 3) {
          self.new708Packet();
          self.add708Bytes(packet);
        } else {
          if (self.current708Packet === null) {
            self.new708Packet();
          }
          self.add708Bytes(packet);
        }
      };
    };
    Cea708Stream.prototype = new stream();
    Cea708Stream.prototype.new708Packet = function () {
      if (this.current708Packet !== null) {
        this.push708Packet();
      }
      this.current708Packet = {
        data: [],
        ptsVals: []
      };
    };
    Cea708Stream.prototype.add708Bytes = function (packet) {
      var data = packet.ccData;
      var byte0 = data >>> 8;
      var byte1 = data & 0xff;
      this.current708Packet.ptsVals.push(packet.pts);
      this.current708Packet.data.push(byte0);
      this.current708Packet.data.push(byte1);
    };
    Cea708Stream.prototype.push708Packet = function () {
      var packet708 = this.current708Packet;
      var packetData = packet708.data;
      var serviceNum = null;
      var blockSize = null;
      var i = 0;
      var b = packetData[i++];
      packet708.seq = b >> 6;
      packet708.sizeCode = b & 0x3f;
      for (; i < packetData.length; i++) {
        b = packetData[i++];
        serviceNum = b >> 5;
        blockSize = b & 0x1f;
        if (serviceNum === 7 && blockSize > 0) {
          b = packetData[i++];
          serviceNum = b;
        }
        this.pushServiceBlock(serviceNum, i, blockSize);
        if (blockSize > 0) {
          i += blockSize - 1;
        }
      }
    };
    Cea708Stream.prototype.pushServiceBlock = function (serviceNum, start, size) {
      var b;
      var i = start;
      var packetData = this.current708Packet.data;
      var service = this.services[serviceNum];
      if (!service) {
        service = this.initService(serviceNum, i);
      }
      for (; i < start + size && i < packetData.length; i++) {
        b = packetData[i];
        if (within708TextBlock(b)) {
          i = this.handleText(i, service);
        } else if (b === 0x18) {
          i = this.multiByteCharacter(i, service);
        } else if (b === 0x10) {
          i = this.extendedCommands(i, service);
        } else if (0x80 <= b && b <= 0x87) {
          i = this.setCurrentWindow(i, service);
        } else if (0x98 <= b && b <= 0x9f) {
          i = this.defineWindow(i, service);
        } else if (b === 0x88) {
          i = this.clearWindows(i, service);
        } else if (b === 0x8c) {
          i = this.deleteWindows(i, service);
        } else if (b === 0x89) {
          i = this.displayWindows(i, service);
        } else if (b === 0x8a) {
          i = this.hideWindows(i, service);
        } else if (b === 0x8b) {
          i = this.toggleWindows(i, service);
        } else if (b === 0x97) {
          i = this.setWindowAttributes(i, service);
        } else if (b === 0x90) {
          i = this.setPenAttributes(i, service);
        } else if (b === 0x91) {
          i = this.setPenColor(i, service);
        } else if (b === 0x92) {
          i = this.setPenLocation(i, service);
        } else if (b === 0x8f) {
          service = this.reset(i, service);
        } else if (b === 0x08) {
          service.currentWindow.backspace();
        } else if (b === 0x0c) {
          service.currentWindow.clearText();
        } else if (b === 0x0d) {
          service.currentWindow.pendingNewLine = true;
        } else if (b === 0x0e) {
          service.currentWindow.clearText();
        } else if (b === 0x8d) {
          i++;
        } else ;
      }
    };
    Cea708Stream.prototype.extendedCommands = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      if (within708TextBlock(b)) {
        i = this.handleText(i, service, {
          isExtended: true
        });
      }
      return i;
    };
    Cea708Stream.prototype.getPts = function (byteIndex) {
      return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];
    };
    Cea708Stream.prototype.initService = function (serviceNum, i) {
      var serviceName = 'SERVICE' + serviceNum;
      var self = this;
      var serviceName;
      var encoding;
      if (serviceName in this.serviceEncodings) {
        encoding = this.serviceEncodings[serviceName];
      }
      this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self);
      this.services[serviceNum].init(this.getPts(i), function (pts) {
        self.flushDisplayed(pts, self.services[serviceNum]);
      });
      return this.services[serviceNum];
    };
    Cea708Stream.prototype.handleText = function (i, service, options) {
      var isExtended = options && options.isExtended;
      var isMultiByte = options && options.isMultiByte;
      var packetData = this.current708Packet.data;
      var extended = isExtended ? 0x1000 : 0x0000;
      var currentByte = packetData[i];
      var nextByte = packetData[i + 1];
      var win = service.currentWindow;
      var _char;
      var charCodeArray;
      if (service.textDecoder_ && !isExtended) {
        if (isMultiByte) {
          charCodeArray = [currentByte, nextByte];
          i++;
        } else {
          charCodeArray = [currentByte];
        }
        _char = service.textDecoder_.decode(new Uint8Array(charCodeArray));
      } else {
        _char = get708CharFromCode(extended | currentByte);
      }
      if (win.pendingNewLine && !win.isEmpty()) {
        win.newLine(this.getPts(i));
      }
      win.pendingNewLine = false;
      win.addText(_char);
      return i;
    };
    Cea708Stream.prototype.multiByteCharacter = function (i, service) {
      var packetData = this.current708Packet.data;
      var firstByte = packetData[i + 1];
      var secondByte = packetData[i + 2];
      if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {
        i = this.handleText(++i, service, {
          isMultiByte: true
        });
      }
      return i;
    };
    Cea708Stream.prototype.setCurrentWindow = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var windowNum = b & 0x07;
      service.setCurrentWindow(windowNum);
      return i;
    };
    Cea708Stream.prototype.defineWindow = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var windowNum = b & 0x07;
      service.setCurrentWindow(windowNum);
      var win = service.currentWindow;
      b = packetData[++i];
      win.visible = (b & 0x20) >> 5;
      win.rowLock = (b & 0x10) >> 4;
      win.columnLock = (b & 0x08) >> 3;
      win.priority = b & 0x07;
      b = packetData[++i];
      win.relativePositioning = (b & 0x80) >> 7;
      win.anchorVertical = b & 0x7f;
      b = packetData[++i];
      win.anchorHorizontal = b;
      b = packetData[++i];
      win.anchorPoint = (b & 0xf0) >> 4;
      win.rowCount = b & 0x0f;
      b = packetData[++i];
      win.columnCount = b & 0x3f;
      b = packetData[++i];
      win.windowStyle = (b & 0x38) >> 3;
      win.penStyle = b & 0x07;
      win.virtualRowCount = win.rowCount + 1;
      return i;
    };
    Cea708Stream.prototype.setWindowAttributes = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var winAttr = service.currentWindow.winAttr;
      b = packetData[++i];
      winAttr.fillOpacity = (b & 0xc0) >> 6;
      winAttr.fillRed = (b & 0x30) >> 4;
      winAttr.fillGreen = (b & 0x0c) >> 2;
      winAttr.fillBlue = b & 0x03;
      b = packetData[++i];
      winAttr.borderType = (b & 0xc0) >> 6;
      winAttr.borderRed = (b & 0x30) >> 4;
      winAttr.borderGreen = (b & 0x0c) >> 2;
      winAttr.borderBlue = b & 0x03;
      b = packetData[++i];
      winAttr.borderType += (b & 0x80) >> 5;
      winAttr.wordWrap = (b & 0x40) >> 6;
      winAttr.printDirection = (b & 0x30) >> 4;
      winAttr.scrollDirection = (b & 0x0c) >> 2;
      winAttr.justify = b & 0x03;
      b = packetData[++i];
      winAttr.effectSpeed = (b & 0xf0) >> 4;
      winAttr.effectDirection = (b & 0x0c) >> 2;
      winAttr.displayEffect = b & 0x03;
      return i;
    };
    Cea708Stream.prototype.flushDisplayed = function (pts, service) {
      var displayedText = [];
      for (var winId = 0; winId < 8; winId++) {
        if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {
          displayedText.push(service.windows[winId].getText());
        }
      }
      service.endPts = pts;
      service.text = displayedText.join('\n\n');
      this.pushCaption(service);
      service.startPts = pts;
    };
    Cea708Stream.prototype.pushCaption = function (service) {
      if (service.text !== '') {
        this.trigger('data', {
          startPts: service.startPts,
          endPts: service.endPts,
          text: service.text,
          stream: 'cc708_' + service.serviceNum
        });
        service.text = '';
        service.startPts = service.endPts;
      }
    };
    Cea708Stream.prototype.displayWindows = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      for (var winId = 0; winId < 8; winId++) {
        if (b & 0x01 << winId) {
          service.windows[winId].visible = 1;
        }
      }
      return i;
    };
    Cea708Stream.prototype.hideWindows = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      for (var winId = 0; winId < 8; winId++) {
        if (b & 0x01 << winId) {
          service.windows[winId].visible = 0;
        }
      }
      return i;
    };
    Cea708Stream.prototype.toggleWindows = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      for (var winId = 0; winId < 8; winId++) {
        if (b & 0x01 << winId) {
          service.windows[winId].visible ^= 1;
        }
      }
      return i;
    };
    Cea708Stream.prototype.clearWindows = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      for (var winId = 0; winId < 8; winId++) {
        if (b & 0x01 << winId) {
          service.windows[winId].clearText();
        }
      }
      return i;
    };
    Cea708Stream.prototype.deleteWindows = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      for (var winId = 0; winId < 8; winId++) {
        if (b & 0x01 << winId) {
          service.windows[winId].reset();
        }
      }
      return i;
    };
    Cea708Stream.prototype.setPenAttributes = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var penAttr = service.currentWindow.penAttr;
      b = packetData[++i];
      penAttr.textTag = (b & 0xf0) >> 4;
      penAttr.offset = (b & 0x0c) >> 2;
      penAttr.penSize = b & 0x03;
      b = packetData[++i];
      penAttr.italics = (b & 0x80) >> 7;
      penAttr.underline = (b & 0x40) >> 6;
      penAttr.edgeType = (b & 0x38) >> 3;
      penAttr.fontStyle = b & 0x07;
      return i;
    };
    Cea708Stream.prototype.setPenColor = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var penColor = service.currentWindow.penColor;
      b = packetData[++i];
      penColor.fgOpacity = (b & 0xc0) >> 6;
      penColor.fgRed = (b & 0x30) >> 4;
      penColor.fgGreen = (b & 0x0c) >> 2;
      penColor.fgBlue = b & 0x03;
      b = packetData[++i];
      penColor.bgOpacity = (b & 0xc0) >> 6;
      penColor.bgRed = (b & 0x30) >> 4;
      penColor.bgGreen = (b & 0x0c) >> 2;
      penColor.bgBlue = b & 0x03;
      b = packetData[++i];
      penColor.edgeRed = (b & 0x30) >> 4;
      penColor.edgeGreen = (b & 0x0c) >> 2;
      penColor.edgeBlue = b & 0x03;
      return i;
    };
    Cea708Stream.prototype.setPenLocation = function (i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var penLoc = service.currentWindow.penLoc;
      service.currentWindow.pendingNewLine = true;
      b = packetData[++i];
      penLoc.row = b & 0x0f;
      b = packetData[++i];
      penLoc.column = b & 0x3f;
      return i;
    };
    Cea708Stream.prototype.reset = function (i, service) {
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      return this.initService(service.serviceNum, i);
    };
    var CHARACTER_TRANSLATION = {
      0x2a: 0xe1,
      0x5c: 0xe9,
      0x5e: 0xed,
      0x5f: 0xf3,
      0x60: 0xfa,
      0x7b: 0xe7,
      0x7c: 0xf7,
      0x7d: 0xd1,
      0x7e: 0xf1,
      0x7f: 0x2588,
      0x0130: 0xae,
      0x0131: 0xb0,
      0x0132: 0xbd,
      0x0133: 0xbf,
      0x0134: 0x2122,
      0x0135: 0xa2,
      0x0136: 0xa3,
      0x0137: 0x266a,
      0x0138: 0xe0,
      0x0139: 0xa0,
      0x013a: 0xe8,
      0x013b: 0xe2,
      0x013c: 0xea,
      0x013d: 0xee,
      0x013e: 0xf4,
      0x013f: 0xfb,
      0x0220: 0xc1,
      0x0221: 0xc9,
      0x0222: 0xd3,
      0x0223: 0xda,
      0x0224: 0xdc,
      0x0225: 0xfc,
      0x0226: 0x2018,
      0x0227: 0xa1,
      0x0228: 0x2a,
      0x0229: 0x27,
      0x022a: 0x2014,
      0x022b: 0xa9,
      0x022c: 0x2120,
      0x022d: 0x2022,
      0x022e: 0x201c,
      0x022f: 0x201d,
      0x0230: 0xc0,
      0x0231: 0xc2,
      0x0232: 0xc7,
      0x0233: 0xc8,
      0x0234: 0xca,
      0x0235: 0xcb,
      0x0236: 0xeb,
      0x0237: 0xce,
      0x0238: 0xcf,
      0x0239: 0xef,
      0x023a: 0xd4,
      0x023b: 0xd9,
      0x023c: 0xf9,
      0x023d: 0xdb,
      0x023e: 0xab,
      0x023f: 0xbb,
      0x0320: 0xc3,
      0x0321: 0xe3,
      0x0322: 0xcd,
      0x0323: 0xcc,
      0x0324: 0xec,
      0x0325: 0xd2,
      0x0326: 0xf2,
      0x0327: 0xd5,
      0x0328: 0xf5,
      0x0329: 0x7b,
      0x032a: 0x7d,
      0x032b: 0x5c,
      0x032c: 0x5e,
      0x032d: 0x5f,
      0x032e: 0x7c,
      0x032f: 0x7e,
      0x0330: 0xc4,
      0x0331: 0xe4,
      0x0332: 0xd6,
      0x0333: 0xf6,
      0x0334: 0xdf,
      0x0335: 0xa5,
      0x0336: 0xa4,
      0x0337: 0x2502,
      0x0338: 0xc5,
      0x0339: 0xe5,
      0x033a: 0xd8,
      0x033b: 0xf8,
      0x033c: 0x250c,
      0x033d: 0x2510,
      0x033e: 0x2514,
      0x033f: 0x2518
    };
    var getCharFromCode = function getCharFromCode(code) {
      if (code === null) {
        return '';
      }
      code = CHARACTER_TRANSLATION[code] || code;
      return String.fromCharCode(code);
    };
    var BOTTOM_ROW = 14;
    var ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420];
    var createDisplayBuffer = function createDisplayBuffer() {
      var result = [],
          i = BOTTOM_ROW + 1;
      while (i--) {
        result.push('');
      }
      return result;
    };
    var Cea608Stream = function Cea608Stream(field, dataChannel) {
      Cea608Stream.prototype.init.call(this);
      this.field_ = field || 0;
      this.dataChannel_ = dataChannel || 0;
      this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);
      this.setConstants();
      this.reset();
      this.push = function (packet) {
        var data, swap, char0, char1, text;
        data = packet.ccData & 0x7f7f;
        if (data === this.lastControlCode_) {
          this.lastControlCode_ = null;
          return;
        }
        if ((data & 0xf000) === 0x1000) {
          this.lastControlCode_ = data;
        } else if (data !== this.PADDING_) {
          this.lastControlCode_ = null;
        }
        char0 = data >>> 8;
        char1 = data & 0xff;
        if (data === this.PADDING_) {
          return;
        } else if (data === this.RESUME_CAPTION_LOADING_) {
          this.mode_ = 'popOn';
        } else if (data === this.END_OF_CAPTION_) {
          this.mode_ = 'popOn';
          this.clearFormatting(packet.pts);
          this.flushDisplayed(packet.pts);
          swap = this.displayed_;
          this.displayed_ = this.nonDisplayed_;
          this.nonDisplayed_ = swap;
          this.startPts_ = packet.pts;
        } else if (data === this.ROLL_UP_2_ROWS_) {
          this.rollUpRows_ = 2;
          this.setRollUp(packet.pts);
        } else if (data === this.ROLL_UP_3_ROWS_) {
          this.rollUpRows_ = 3;
          this.setRollUp(packet.pts);
        } else if (data === this.ROLL_UP_4_ROWS_) {
          this.rollUpRows_ = 4;
          this.setRollUp(packet.pts);
        } else if (data === this.CARRIAGE_RETURN_) {
          this.clearFormatting(packet.pts);
          this.flushDisplayed(packet.pts);
          this.shiftRowsUp_();
          this.startPts_ = packet.pts;
        } else if (data === this.BACKSPACE_) {
          if (this.mode_ === 'popOn') {
            this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);
          } else {
            this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
          }
        } else if (data === this.ERASE_DISPLAYED_MEMORY_) {
          this.flushDisplayed(packet.pts);
          this.displayed_ = createDisplayBuffer();
        } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {
          this.nonDisplayed_ = createDisplayBuffer();
        } else if (data === this.RESUME_DIRECT_CAPTIONING_) {
          if (this.mode_ !== 'paintOn') {
            this.flushDisplayed(packet.pts);
            this.displayed_ = createDisplayBuffer();
          }
          this.mode_ = 'paintOn';
          this.startPts_ = packet.pts;
        } else if (this.isSpecialCharacter(char0, char1)) {
          char0 = (char0 & 0x03) << 8;
          text = getCharFromCode(char0 | char1);
          this[this.mode_](packet.pts, text);
          this.column_++;
        } else if (this.isExtCharacter(char0, char1)) {
          if (this.mode_ === 'popOn') {
            this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);
          } else {
            this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
          }
          char0 = (char0 & 0x03) << 8;
          text = getCharFromCode(char0 | char1);
          this[this.mode_](packet.pts, text);
          this.column_++;
        } else if (this.isMidRowCode(char0, char1)) {
          this.clearFormatting(packet.pts);
          this[this.mode_](packet.pts, ' ');
          this.column_++;
          if ((char1 & 0xe) === 0xe) {
            this.addFormatting(packet.pts, ['i']);
          }
          if ((char1 & 0x1) === 0x1) {
            this.addFormatting(packet.pts, ['u']);
          }
        } else if (this.isOffsetControlCode(char0, char1)) {
          this.column_ += char1 & 0x03;
        } else if (this.isPAC(char0, char1)) {
          var row = ROWS.indexOf(data & 0x1f20);
          if (this.mode_ === 'rollUp') {
            if (row - this.rollUpRows_ + 1 < 0) {
              row = this.rollUpRows_ - 1;
            }
            this.setRollUp(packet.pts, row);
          }
          if (row !== this.row_) {
            this.clearFormatting(packet.pts);
            this.row_ = row;
          }
          if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {
            this.addFormatting(packet.pts, ['u']);
          }
          if ((data & 0x10) === 0x10) {
            this.column_ = ((data & 0xe) >> 1) * 4;
          }
          if (this.isColorPAC(char1)) {
            if ((char1 & 0xe) === 0xe) {
              this.addFormatting(packet.pts, ['i']);
            }
          }
        } else if (this.isNormalChar(char0)) {
          if (char1 === 0x00) {
            char1 = null;
          }
          text = getCharFromCode(char0);
          text += getCharFromCode(char1);
          this[this.mode_](packet.pts, text);
          this.column_ += text.length;
        }
      };
    };
    Cea608Stream.prototype = new stream();
    Cea608Stream.prototype.flushDisplayed = function (pts) {
      var content = this.displayed_
      .map(function (row, index) {
        try {
          return row.trim();
        } catch (e) {
          this.trigger('log', {
            level: 'warn',
            message: 'Skipping a malformed 608 caption at index ' + index + '.'
          });
          return '';
        }
      }, this)
      .join('\n')
      .replace(/^\n+|\n+$/g, '');
      if (content.length) {
        this.trigger('data', {
          startPts: this.startPts_,
          endPts: pts,
          text: content,
          stream: this.name_
        });
      }
    };
    Cea608Stream.prototype.reset = function () {
      this.mode_ = 'popOn';
      this.topRow_ = 0;
      this.startPts_ = 0;
      this.displayed_ = createDisplayBuffer();
      this.nonDisplayed_ = createDisplayBuffer();
      this.lastControlCode_ = null;
      this.column_ = 0;
      this.row_ = BOTTOM_ROW;
      this.rollUpRows_ = 2;
      this.formatting_ = [];
    };
    Cea608Stream.prototype.setConstants = function () {
      if (this.dataChannel_ === 0) {
        this.BASE_ = 0x10;
        this.EXT_ = 0x11;
        this.CONTROL_ = (0x14 | this.field_) << 8;
        this.OFFSET_ = 0x17;
      } else if (this.dataChannel_ === 1) {
        this.BASE_ = 0x18;
        this.EXT_ = 0x19;
        this.CONTROL_ = (0x1c | this.field_) << 8;
        this.OFFSET_ = 0x1f;
      }
      this.PADDING_ = 0x0000;
      this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;
      this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f;
      this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;
      this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;
      this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;
      this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d;
      this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29;
      this.BACKSPACE_ = this.CONTROL_ | 0x21;
      this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;
      this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;
    };
    Cea608Stream.prototype.isSpecialCharacter = function (char0, char1) {
      return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;
    };
    Cea608Stream.prototype.isExtCharacter = function (char0, char1) {
      return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;
    };
    Cea608Stream.prototype.isMidRowCode = function (char0, char1) {
      return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;
    };
    Cea608Stream.prototype.isOffsetControlCode = function (char0, char1) {
      return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;
    };
    Cea608Stream.prototype.isPAC = function (char0, char1) {
      return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;
    };
    Cea608Stream.prototype.isColorPAC = function (char1) {
      return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;
    };
    Cea608Stream.prototype.isNormalChar = function (_char2) {
      return _char2 >= 0x20 && _char2 <= 0x7f;
    };
    Cea608Stream.prototype.setRollUp = function (pts, newBaseRow) {
      if (this.mode_ !== 'rollUp') {
        this.row_ = BOTTOM_ROW;
        this.mode_ = 'rollUp';
        this.flushDisplayed(pts);
        this.nonDisplayed_ = createDisplayBuffer();
        this.displayed_ = createDisplayBuffer();
      }
      if (newBaseRow !== undefined && newBaseRow !== this.row_) {
        for (var i = 0; i < this.rollUpRows_; i++) {
          this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];
          this.displayed_[this.row_ - i] = '';
        }
      }
      if (newBaseRow === undefined) {
        newBaseRow = this.row_;
      }
      this.topRow_ = newBaseRow - this.rollUpRows_ + 1;
    };
    Cea608Stream.prototype.addFormatting = function (pts, format) {
      this.formatting_ = this.formatting_.concat(format);
      var text = format.reduce(function (text, format) {
        return text + '<' + format + '>';
      }, '');
      this[this.mode_](pts, text);
    };
    Cea608Stream.prototype.clearFormatting = function (pts) {
      if (!this.formatting_.length) {
        return;
      }
      var text = this.formatting_.reverse().reduce(function (text, format) {
        return text + '</' + format + '>';
      }, '');
      this.formatting_ = [];
      this[this.mode_](pts, text);
    };
    Cea608Stream.prototype.popOn = function (pts, text) {
      var baseRow = this.nonDisplayed_[this.row_];
      baseRow += text;
      this.nonDisplayed_[this.row_] = baseRow;
    };
    Cea608Stream.prototype.rollUp = function (pts, text) {
      var baseRow = this.displayed_[this.row_];
      baseRow += text;
      this.displayed_[this.row_] = baseRow;
    };
    Cea608Stream.prototype.shiftRowsUp_ = function () {
      var i;
      for (i = 0; i < this.topRow_; i++) {
        this.displayed_[i] = '';
      }
      for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {
        this.displayed_[i] = '';
      }
      for (i = this.topRow_; i < this.row_; i++) {
        this.displayed_[i] = this.displayed_[i + 1];
      }
      this.displayed_[this.row_] = '';
    };
    Cea608Stream.prototype.paintOn = function (pts, text) {
      var baseRow = this.displayed_[this.row_];
      baseRow += text;
      this.displayed_[this.row_] = baseRow;
    };
    var captionStream = {
      CaptionStream: CaptionStream$1,
      Cea608Stream: Cea608Stream,
      Cea708Stream: Cea708Stream
    };
    var streamTypes = {
      H264_STREAM_TYPE: 0x1B,
      ADTS_STREAM_TYPE: 0x0F,
      METADATA_STREAM_TYPE: 0x15
    };
    var MAX_TS = 8589934592;
    var RO_THRESH = 4294967296;
    var TYPE_SHARED = 'shared';
    var handleRollover$1 = function handleRollover(value, reference) {
      var direction = 1;
      if (value > reference) {
        direction = -1;
      }
      while (Math.abs(reference - value) > RO_THRESH) {
        value += direction * MAX_TS;
      }
      return value;
    };
    var TimestampRolloverStream$1 = function TimestampRolloverStream(type) {
      var lastDTS, referenceDTS;
      TimestampRolloverStream.prototype.init.call(this);
      this.type_ = type || TYPE_SHARED;
      this.push = function (data) {
        if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {
          return;
        }
        if (referenceDTS === undefined) {
          referenceDTS = data.dts;
        }
        data.dts = handleRollover$1(data.dts, referenceDTS);
        data.pts = handleRollover$1(data.pts, referenceDTS);
        lastDTS = data.dts;
        this.trigger('data', data);
      };
      this.flush = function () {
        referenceDTS = lastDTS;
        this.trigger('done');
      };
      this.endTimeline = function () {
        this.flush();
        this.trigger('endedtimeline');
      };
      this.discontinuity = function () {
        referenceDTS = void 0;
        lastDTS = void 0;
      };
      this.reset = function () {
        this.discontinuity();
        this.trigger('reset');
      };
    };
    TimestampRolloverStream$1.prototype = new stream();
    var timestampRolloverStream = {
      TimestampRolloverStream: TimestampRolloverStream$1,
      handleRollover: handleRollover$1
    };
    var percentEncode$1 = function percentEncode(bytes, start, end) {
      var i,
          result = '';
      for (i = start; i < end; i++) {
        result += '%' + ('00' + bytes[i].toString(16)).slice(-2);
      }
      return result;
    },
    parseUtf8 = function parseUtf8(bytes, start, end) {
      return decodeURIComponent(percentEncode$1(bytes, start, end));
    },
    parseIso88591$1 = function parseIso88591(bytes, start, end) {
      return unescape(percentEncode$1(bytes, start, end));
    },
        parseSyncSafeInteger$1 = function parseSyncSafeInteger(data) {
      return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
    },
        tagParsers = {
      TXXX: function TXXX(tag) {
        var i;
        if (tag.data[0] !== 3) {
          return;
        }
        for (i = 1; i < tag.data.length; i++) {
          if (tag.data[i] === 0) {
            tag.description = parseUtf8(tag.data, 1, i);
            tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\0*$/, '');
            break;
          }
        }
        tag.data = tag.value;
      },
      WXXX: function WXXX(tag) {
        var i;
        if (tag.data[0] !== 3) {
          return;
        }
        for (i = 1; i < tag.data.length; i++) {
          if (tag.data[i] === 0) {
            tag.description = parseUtf8(tag.data, 1, i);
            tag.url = parseUtf8(tag.data, i + 1, tag.data.length);
            break;
          }
        }
      },
      PRIV: function PRIV(tag) {
        var i;
        for (i = 0; i < tag.data.length; i++) {
          if (tag.data[i] === 0) {
            tag.owner = parseIso88591$1(tag.data, 0, i);
            break;
          }
        }
        tag.privateData = tag.data.subarray(i + 1);
        tag.data = tag.privateData;
      }
    },
        _MetadataStream;
    _MetadataStream = function MetadataStream(options) {
      var settings = {
        descriptor: options && options.descriptor
      },
      tagSize = 0,
      buffer = [],
      bufferSize = 0,
          i;
      _MetadataStream.prototype.init.call(this);
      this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16);
      if (settings.descriptor) {
        for (i = 0; i < settings.descriptor.length; i++) {
          this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);
        }
      }
      this.push = function (chunk) {
        var tag, frameStart, frameSize, frame, i, frameHeader;
        if (chunk.type !== 'timed-metadata') {
          return;
        }
        if (chunk.dataAlignmentIndicator) {
          bufferSize = 0;
          buffer.length = 0;
        }
        if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {
          this.trigger('log', {
            level: 'warn',
            message: 'Skipping unrecognized metadata packet'
          });
          return;
        }
        buffer.push(chunk);
        bufferSize += chunk.data.byteLength;
        if (buffer.length === 1) {
          tagSize = parseSyncSafeInteger$1(chunk.data.subarray(6, 10));
          tagSize += 10;
        }
        if (bufferSize < tagSize) {
          return;
        }
        tag = {
          data: new Uint8Array(tagSize),
          frames: [],
          pts: buffer[0].pts,
          dts: buffer[0].dts
        };
        for (i = 0; i < tagSize;) {
          tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);
          i += buffer[0].data.byteLength;
          bufferSize -= buffer[0].data.byteLength;
          buffer.shift();
        }
        frameStart = 10;
        if (tag.data[5] & 0x40) {
          frameStart += 4;
          frameStart += parseSyncSafeInteger$1(tag.data.subarray(10, 14));
          tagSize -= parseSyncSafeInteger$1(tag.data.subarray(16, 20));
        }
        do {
          frameSize = parseSyncSafeInteger$1(tag.data.subarray(frameStart + 4, frameStart + 8));
          if (frameSize < 1) {
            this.trigger('log', {
              level: 'warn',
              message: 'Malformed ID3 frame encountered. Skipping metadata parsing.'
            });
            return;
          }
          frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);
          frame = {
            id: frameHeader,
            data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)
          };
          frame.key = frame.id;
          if (tagParsers[frame.id]) {
            tagParsers[frame.id](frame);
            if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {
              var d = frame.data,
                  size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
              size *= 4;
              size += d[7] & 0x03;
              frame.timeStamp = size;
              if (tag.pts === undefined && tag.dts === undefined) {
                tag.pts = frame.timeStamp;
                tag.dts = frame.timeStamp;
              }
              this.trigger('timestamp', frame);
            }
          }
          tag.frames.push(frame);
          frameStart += 10;
          frameStart += frameSize;
        } while (frameStart < tagSize);
        this.trigger('data', tag);
      };
    };
    _MetadataStream.prototype = new stream();
    var metadataStream = _MetadataStream;
    var TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream;
    var _TransportPacketStream, _TransportParseStream, _ElementaryStream;
    var MP2T_PACKET_LENGTH$1 = 188,
    SYNC_BYTE$1 = 0x47;
    _TransportPacketStream = function TransportPacketStream() {
      var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1),
          bytesInBuffer = 0;
      _TransportPacketStream.prototype.init.call(this);
      this.push = function (bytes) {
        var startIndex = 0,
            endIndex = MP2T_PACKET_LENGTH$1,
            everything;
        if (bytesInBuffer) {
          everything = new Uint8Array(bytes.byteLength + bytesInBuffer);
          everything.set(buffer.subarray(0, bytesInBuffer));
          everything.set(bytes, bytesInBuffer);
          bytesInBuffer = 0;
        } else {
          everything = bytes;
        }
        while (endIndex < everything.byteLength) {
          if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {
            this.trigger('data', everything.subarray(startIndex, endIndex));
            startIndex += MP2T_PACKET_LENGTH$1;
            endIndex += MP2T_PACKET_LENGTH$1;
            continue;
          }
          startIndex++;
          endIndex++;
        }
        if (startIndex < everything.byteLength) {
          buffer.set(everything.subarray(startIndex), 0);
          bytesInBuffer = everything.byteLength - startIndex;
        }
      };
      this.flush = function () {
        if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {
          this.trigger('data', buffer);
          bytesInBuffer = 0;
        }
        this.trigger('done');
      };
      this.endTimeline = function () {
        this.flush();
        this.trigger('endedtimeline');
      };
      this.reset = function () {
        bytesInBuffer = 0;
        this.trigger('reset');
      };
    };
    _TransportPacketStream.prototype = new stream();
    _TransportParseStream = function TransportParseStream() {
      var parsePsi, parsePat, parsePmt, self;
      _TransportParseStream.prototype.init.call(this);
      self = this;
      this.packetsWaitingForPmt = [];
      this.programMapTable = undefined;
      parsePsi = function parsePsi(payload, psi) {
        var offset = 0;
        if (psi.payloadUnitStartIndicator) {
          offset += payload[offset] + 1;
        }
        if (psi.type === 'pat') {
          parsePat(payload.subarray(offset), psi);
        } else {
          parsePmt(payload.subarray(offset), psi);
        }
      };
      parsePat = function parsePat(payload, pat) {
        pat.section_number = payload[7];
        pat.last_section_number = payload[8];
        self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];
        pat.pmtPid = self.pmtPid;
      };
      parsePmt = function parsePmt(payload, pmt) {
        var sectionLength, tableEnd, programInfoLength, offset;
        if (!(payload[5] & 0x01)) {
          return;
        }
        self.programMapTable = {
          video: null,
          audio: null,
          'timed-metadata': {}
        };
        sectionLength = (payload[1] & 0x0f) << 8 | payload[2];
        tableEnd = 3 + sectionLength - 4;
        programInfoLength = (payload[10] & 0x0f) << 8 | payload[11];
        offset = 12 + programInfoLength;
        while (offset < tableEnd) {
          var streamType = payload[offset];
          var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2];
          if (streamType === streamTypes.H264_STREAM_TYPE && self.programMapTable.video === null) {
            self.programMapTable.video = pid;
          } else if (streamType === streamTypes.ADTS_STREAM_TYPE && self.programMapTable.audio === null) {
            self.programMapTable.audio = pid;
          } else if (streamType === streamTypes.METADATA_STREAM_TYPE) {
            self.programMapTable['timed-metadata'][pid] = streamType;
          }
          offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;
        }
        pmt.programMapTable = self.programMapTable;
      };
      this.push = function (packet) {
        var result = {},
            offset = 4;
        result.payloadUnitStartIndicator = !!(packet[1] & 0x40);
        result.pid = packet[1] & 0x1f;
        result.pid <<= 8;
        result.pid |= packet[2];
        if ((packet[3] & 0x30) >>> 4 > 0x01) {
          offset += packet[offset] + 1;
        }
        if (result.pid === 0) {
          result.type = 'pat';
          parsePsi(packet.subarray(offset), result);
          this.trigger('data', result);
        } else if (result.pid === this.pmtPid) {
          result.type = 'pmt';
          parsePsi(packet.subarray(offset), result);
          this.trigger('data', result);
          while (this.packetsWaitingForPmt.length) {
            this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
          }
        } else if (this.programMapTable === undefined) {
          this.packetsWaitingForPmt.push([packet, offset, result]);
        } else {
          this.processPes_(packet, offset, result);
        }
      };
      this.processPes_ = function (packet, offset, result) {
        if (result.pid === this.programMapTable.video) {
          result.streamType = streamTypes.H264_STREAM_TYPE;
        } else if (result.pid === this.programMapTable.audio) {
          result.streamType = streamTypes.ADTS_STREAM_TYPE;
        } else {
          result.streamType = this.programMapTable['timed-metadata'][result.pid];
        }
        result.type = 'pes';
        result.data = packet.subarray(offset);
        this.trigger('data', result);
      };
    };
    _TransportParseStream.prototype = new stream();
    _TransportParseStream.STREAM_TYPES = {
      h264: 0x1b,
      adts: 0x0f
    };
    _ElementaryStream = function ElementaryStream() {
      var self = this,
          segmentHadPmt = false,
      video = {
        data: [],
        size: 0
      },
          audio = {
        data: [],
        size: 0
      },
          timedMetadata = {
        data: [],
        size: 0
      },
          programMapTable,
          parsePes = function parsePes(payload, pes) {
        var ptsDtsFlags;
        var startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2];
        pes.data = new Uint8Array();
        if (startPrefix !== 1) {
          return;
        }
        pes.packetLength = 6 + (payload[4] << 8 | payload[5]);
        pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0;
        ptsDtsFlags = payload[7];
        if (ptsDtsFlags & 0xC0) {
          pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;
          pes.pts *= 4;
          pes.pts += (payload[13] & 0x06) >>> 1;
          pes.dts = pes.pts;
          if (ptsDtsFlags & 0x40) {
            pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;
            pes.dts *= 4;
            pes.dts += (payload[18] & 0x06) >>> 1;
          }
        }
        pes.data = payload.subarray(9 + payload[8]);
      },
      flushStream = function flushStream(stream, type, forceFlush) {
        var packetData = new Uint8Array(stream.size),
            event = {
          type: type
        },
            i = 0,
            offset = 0,
            packetFlushable = false,
            fragment;
        if (!stream.data.length || stream.size < 9) {
          return;
        }
        event.trackId = stream.data[0].pid;
        for (i = 0; i < stream.data.length; i++) {
          fragment = stream.data[i];
          packetData.set(fragment.data, offset);
          offset += fragment.data.byteLength;
        }
        parsePes(packetData, event);
        packetFlushable = type === 'video' || event.packetLength <= stream.size;
        if (forceFlush || packetFlushable) {
          stream.size = 0;
          stream.data.length = 0;
        }
        if (packetFlushable) {
          self.trigger('data', event);
        }
      };
      _ElementaryStream.prototype.init.call(this);
      this.push = function (data) {
        ({
          pat: function pat() {
          },
          pes: function pes() {
            var stream, streamType;
            switch (data.streamType) {
              case streamTypes.H264_STREAM_TYPE:
                stream = video;
                streamType = 'video';
                break;
              case streamTypes.ADTS_STREAM_TYPE:
                stream = audio;
                streamType = 'audio';
                break;
              case streamTypes.METADATA_STREAM_TYPE:
                stream = timedMetadata;
                streamType = 'timed-metadata';
                break;
              default:
                return;
            }
            if (data.payloadUnitStartIndicator) {
              flushStream(stream, streamType, true);
            }
            stream.data.push(data);
            stream.size += data.data.byteLength;
          },
          pmt: function pmt() {
            var event = {
              type: 'metadata',
              tracks: []
            };
            programMapTable = data.programMapTable;
            if (programMapTable.video !== null) {
              event.tracks.push({
                timelineStartInfo: {
                  baseMediaDecodeTime: 0
                },
                id: +programMapTable.video,
                codec: 'avc',
                type: 'video'
              });
            }
            if (programMapTable.audio !== null) {
              event.tracks.push({
                timelineStartInfo: {
                  baseMediaDecodeTime: 0
                },
                id: +programMapTable.audio,
                codec: 'adts',
                type: 'audio'
              });
            }
            segmentHadPmt = true;
            self.trigger('data', event);
          }
        })[data.type]();
      };
      this.reset = function () {
        video.size = 0;
        video.data.length = 0;
        audio.size = 0;
        audio.data.length = 0;
        this.trigger('reset');
      };
      this.flushStreams_ = function () {
        flushStream(video, 'video');
        flushStream(audio, 'audio');
        flushStream(timedMetadata, 'timed-metadata');
      };
      this.flush = function () {
        if (!segmentHadPmt && programMapTable) {
          var pmt = {
            type: 'metadata',
            tracks: []
          };
          if (programMapTable.video !== null) {
            pmt.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.video,
              codec: 'avc',
              type: 'video'
            });
          }
          if (programMapTable.audio !== null) {
            pmt.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.audio,
              codec: 'adts',
              type: 'audio'
            });
          }
          self.trigger('data', pmt);
        }
        segmentHadPmt = false;
        this.flushStreams_();
        this.trigger('done');
      };
    };
    _ElementaryStream.prototype = new stream();
    var m2ts = {
      PAT_PID: 0x0000,
      MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,
      TransportPacketStream: _TransportPacketStream,
      TransportParseStream: _TransportParseStream,
      ElementaryStream: _ElementaryStream,
      TimestampRolloverStream: TimestampRolloverStream,
      CaptionStream: captionStream.CaptionStream,
      Cea608Stream: captionStream.Cea608Stream,
      Cea708Stream: captionStream.Cea708Stream,
      MetadataStream: metadataStream
    };
    for (var type in streamTypes) {
      if (streamTypes.hasOwnProperty(type)) {
        m2ts[type] = streamTypes[type];
      }
    }
    var m2ts_1 = m2ts;
    var ONE_SECOND_IN_TS$2 = clock.ONE_SECOND_IN_TS;
    var _AdtsStream;
    var ADTS_SAMPLING_FREQUENCIES$1 = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
    _AdtsStream = function AdtsStream(handlePartialSegments) {
      var buffer,
          frameNum = 0;
      _AdtsStream.prototype.init.call(this);
      this.skipWarn_ = function (start, end) {
        this.trigger('log', {
          level: 'warn',
          message: "adts skiping bytes " + start + " to " + end + " in frame " + frameNum + " outside syncword"
        });
      };
      this.push = function (packet) {
        var i = 0,
            frameLength,
            protectionSkipBytes,
            oldBuffer,
            sampleCount,
            adtsFrameDuration;
        if (!handlePartialSegments) {
          frameNum = 0;
        }
        if (packet.type !== 'audio') {
          return;
        }
        if (buffer && buffer.length) {
          oldBuffer = buffer;
          buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);
          buffer.set(oldBuffer);
          buffer.set(packet.data, oldBuffer.byteLength);
        } else {
          buffer = packet.data;
        }
        var skip;
        while (i + 7 < buffer.length) {
          if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {
            if (typeof skip !== 'number') {
              skip = i;
            }
            i++;
            continue;
          }
          if (typeof skip === 'number') {
            this.skipWarn_(skip, i);
            skip = null;
          }
          protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2;
          frameLength = (buffer[i + 3] & 0x03) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 0xe0) >> 5;
          sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;
          adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2];
          if (buffer.byteLength - i < frameLength) {
            break;
          }
          this.trigger('data', {
            pts: packet.pts + frameNum * adtsFrameDuration,
            dts: packet.dts + frameNum * adtsFrameDuration,
            sampleCount: sampleCount,
            audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,
            channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 0xc0) >>> 6,
            samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2],
            samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,
            samplesize: 16,
            data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)
          });
          frameNum++;
          i += frameLength;
        }
        if (typeof skip === 'number') {
          this.skipWarn_(skip, i);
          skip = null;
        }
        buffer = buffer.subarray(i);
      };
      this.flush = function () {
        frameNum = 0;
        this.trigger('done');
      };
      this.reset = function () {
        buffer = void 0;
        this.trigger('reset');
      };
      this.endTimeline = function () {
        buffer = void 0;
        this.trigger('endedtimeline');
      };
    };
    _AdtsStream.prototype = new stream();
    var adts = _AdtsStream;
    var ExpGolomb;
    ExpGolomb = function ExpGolomb(workingData) {
      var
      workingBytesAvailable = workingData.byteLength,
      workingWord = 0,
      workingBitsAvailable = 0;
      this.length = function () {
        return 8 * workingBytesAvailable;
      };
      this.bitsAvailable = function () {
        return 8 * workingBytesAvailable + workingBitsAvailable;
      };
      this.loadWord = function () {
        var position = workingData.byteLength - workingBytesAvailable,
            workingBytes = new Uint8Array(4),
            availableBytes = Math.min(4, workingBytesAvailable);
        if (availableBytes === 0) {
          throw new Error('no bytes available');
        }
        workingBytes.set(workingData.subarray(position, position + availableBytes));
        workingWord = new DataView(workingBytes.buffer).getUint32(0);
        workingBitsAvailable = availableBytes * 8;
        workingBytesAvailable -= availableBytes;
      };
      this.skipBits = function (count) {
        var skipBytes;
        if (workingBitsAvailable > count) {
          workingWord <<= count;
          workingBitsAvailable -= count;
        } else {
          count -= workingBitsAvailable;
          skipBytes = Math.floor(count / 8);
          count -= skipBytes * 8;
          workingBytesAvailable -= skipBytes;
          this.loadWord();
          workingWord <<= count;
          workingBitsAvailable -= count;
        }
      };
      this.readBits = function (size) {
        var bits = Math.min(workingBitsAvailable, size),
        valu = workingWord >>> 32 - bits;
        workingBitsAvailable -= bits;
        if (workingBitsAvailable > 0) {
          workingWord <<= bits;
        } else if (workingBytesAvailable > 0) {
          this.loadWord();
        }
        bits = size - bits;
        if (bits > 0) {
          return valu << bits | this.readBits(bits);
        }
        return valu;
      };
      this.skipLeadingZeros = function () {
        var leadingZeroCount;
        for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {
          if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {
            workingWord <<= leadingZeroCount;
            workingBitsAvailable -= leadingZeroCount;
            return leadingZeroCount;
          }
        }
        this.loadWord();
        return leadingZeroCount + this.skipLeadingZeros();
      };
      this.skipUnsignedExpGolomb = function () {
        this.skipBits(1 + this.skipLeadingZeros());
      };
      this.skipExpGolomb = function () {
        this.skipBits(1 + this.skipLeadingZeros());
      };
      this.readUnsignedExpGolomb = function () {
        var clz = this.skipLeadingZeros();
        return this.readBits(clz + 1) - 1;
      };
      this.readExpGolomb = function () {
        var valu = this.readUnsignedExpGolomb();
        if (0x01 & valu) {
          return 1 + valu >>> 1;
        }
        return -1 * (valu >>> 1);
      };
      this.readBoolean = function () {
        return this.readBits(1) === 1;
      };
      this.readUnsignedByte = function () {
        return this.readBits(8);
      };
      this.loadWord();
    };
    var expGolomb = ExpGolomb;
    var _H264Stream, _NalByteStream;
    var PROFILES_WITH_OPTIONAL_SPS_DATA;
    _NalByteStream = function NalByteStream() {
      var syncPoint = 0,
          i,
          buffer;
      _NalByteStream.prototype.init.call(this);
      this.push = function (data) {
        var swapBuffer;
        if (!buffer) {
          buffer = data.data;
        } else {
          swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);
          swapBuffer.set(buffer);
          swapBuffer.set(data.data, buffer.byteLength);
          buffer = swapBuffer;
        }
        var len = buffer.byteLength;
        for (; syncPoint < len - 3; syncPoint++) {
          if (buffer[syncPoint + 2] === 1) {
            i = syncPoint + 5;
            break;
          }
        }
        while (i < len) {
          switch (buffer[i]) {
            case 0:
              if (buffer[i - 1] !== 0) {
                i += 2;
                break;
              } else if (buffer[i - 2] !== 0) {
                i++;
                break;
              }
              if (syncPoint + 3 !== i - 2) {
                this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));
              }
              do {
                i++;
              } while (buffer[i] !== 1 && i < len);
              syncPoint = i - 2;
              i += 3;
              break;
            case 1:
              if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {
                i += 3;
                break;
              }
              this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));
              syncPoint = i - 2;
              i += 3;
              break;
            default:
              i += 3;
              break;
          }
        }
        buffer = buffer.subarray(syncPoint);
        i -= syncPoint;
        syncPoint = 0;
      };
      this.reset = function () {
        buffer = null;
        syncPoint = 0;
        this.trigger('reset');
      };
      this.flush = function () {
        if (buffer && buffer.byteLength > 3) {
          this.trigger('data', buffer.subarray(syncPoint + 3));
        }
        buffer = null;
        syncPoint = 0;
        this.trigger('done');
      };
      this.endTimeline = function () {
        this.flush();
        this.trigger('endedtimeline');
      };
    };
    _NalByteStream.prototype = new stream();
    PROFILES_WITH_OPTIONAL_SPS_DATA = {
      100: true,
      110: true,
      122: true,
      244: true,
      44: true,
      83: true,
      86: true,
      118: true,
      128: true,
      138: true,
      139: true,
      134: true
    };
    _H264Stream = function H264Stream() {
      var nalByteStream = new _NalByteStream(),
          self,
          trackId,
          currentPts,
          currentDts,
          discardEmulationPreventionBytes,
          readSequenceParameterSet,
          skipScalingList;
      _H264Stream.prototype.init.call(this);
      self = this;
      this.push = function (packet) {
        if (packet.type !== 'video') {
          return;
        }
        trackId = packet.trackId;
        currentPts = packet.pts;
        currentDts = packet.dts;
        nalByteStream.push(packet);
      };
      nalByteStream.on('data', function (data) {
        var event = {
          trackId: trackId,
          pts: currentPts,
          dts: currentDts,
          data: data,
          nalUnitTypeCode: data[0] & 0x1f
        };
        switch (event.nalUnitTypeCode) {
          case 0x05:
            event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';
            break;
          case 0x06:
            event.nalUnitType = 'sei_rbsp';
            event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));
            break;
          case 0x07:
            event.nalUnitType = 'seq_parameter_set_rbsp';
            event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));
            event.config = readSequenceParameterSet(event.escapedRBSP);
            break;
          case 0x08:
            event.nalUnitType = 'pic_parameter_set_rbsp';
            break;
          case 0x09:
            event.nalUnitType = 'access_unit_delimiter_rbsp';
            break;
        }
        self.trigger('data', event);
      });
      nalByteStream.on('done', function () {
        self.trigger('done');
      });
      nalByteStream.on('partialdone', function () {
        self.trigger('partialdone');
      });
      nalByteStream.on('reset', function () {
        self.trigger('reset');
      });
      nalByteStream.on('endedtimeline', function () {
        self.trigger('endedtimeline');
      });
      this.flush = function () {
        nalByteStream.flush();
      };
      this.partialFlush = function () {
        nalByteStream.partialFlush();
      };
      this.reset = function () {
        nalByteStream.reset();
      };
      this.endTimeline = function () {
        nalByteStream.endTimeline();
      };
      skipScalingList = function skipScalingList(count, expGolombDecoder) {
        var lastScale = 8,
            nextScale = 8,
            j,
            deltaScale;
        for (j = 0; j < count; j++) {
          if (nextScale !== 0) {
            deltaScale = expGolombDecoder.readExpGolomb();
            nextScale = (lastScale + deltaScale + 256) % 256;
          }
          lastScale = nextScale === 0 ? lastScale : nextScale;
        }
      };
      discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {
        var length = data.byteLength,
            emulationPreventionBytesPositions = [],
            i = 1,
            newLength,
            newData;
        while (i < length - 2) {
          if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
            emulationPreventionBytesPositions.push(i + 2);
            i += 2;
          } else {
            i++;
          }
        }
        if (emulationPreventionBytesPositions.length === 0) {
          return data;
        }
        newLength = length - emulationPreventionBytesPositions.length;
        newData = new Uint8Array(newLength);
        var sourceIndex = 0;
        for (i = 0; i < newLength; sourceIndex++, i++) {
          if (sourceIndex === emulationPreventionBytesPositions[0]) {
            sourceIndex++;
            emulationPreventionBytesPositions.shift();
          }
          newData[i] = data[sourceIndex];
        }
        return newData;
      };
      readSequenceParameterSet = function readSequenceParameterSet(data) {
        var frameCropLeftOffset = 0,
            frameCropRightOffset = 0,
            frameCropTopOffset = 0,
            frameCropBottomOffset = 0,
            expGolombDecoder,
            profileIdc,
            levelIdc,
            profileCompatibility,
            chromaFormatIdc,
            picOrderCntType,
            numRefFramesInPicOrderCntCycle,
            picWidthInMbsMinus1,
            picHeightInMapUnitsMinus1,
            frameMbsOnlyFlag,
            scalingListCount,
            sarRatio = [1, 1],
            aspectRatioIdc,
            i;
        expGolombDecoder = new expGolomb(data);
        profileIdc = expGolombDecoder.readUnsignedByte();
        profileCompatibility = expGolombDecoder.readUnsignedByte();
        levelIdc = expGolombDecoder.readUnsignedByte();
        expGolombDecoder.skipUnsignedExpGolomb();
        if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {
          chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();
          if (chromaFormatIdc === 3) {
            expGolombDecoder.skipBits(1);
          }
          expGolombDecoder.skipUnsignedExpGolomb();
          expGolombDecoder.skipUnsignedExpGolomb();
          expGolombDecoder.skipBits(1);
          if (expGolombDecoder.readBoolean()) {
            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
            for (i = 0; i < scalingListCount; i++) {
              if (expGolombDecoder.readBoolean()) {
                if (i < 6) {
                  skipScalingList(16, expGolombDecoder);
                } else {
                  skipScalingList(64, expGolombDecoder);
                }
              }
            }
          }
        }
        expGolombDecoder.skipUnsignedExpGolomb();
        picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();
        if (picOrderCntType === 0) {
          expGolombDecoder.readUnsignedExpGolomb();
        } else if (picOrderCntType === 1) {
          expGolombDecoder.skipBits(1);
          expGolombDecoder.skipExpGolomb();
          expGolombDecoder.skipExpGolomb();
          numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();
          for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
            expGolombDecoder.skipExpGolomb();
          }
        }
        expGolombDecoder.skipUnsignedExpGolomb();
        expGolombDecoder.skipBits(1);
        picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
        picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
        frameMbsOnlyFlag = expGolombDecoder.readBits(1);
        if (frameMbsOnlyFlag === 0) {
          expGolombDecoder.skipBits(1);
        }
        expGolombDecoder.skipBits(1);
        if (expGolombDecoder.readBoolean()) {
          frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();
          frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();
          frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();
          frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();
        }
        if (expGolombDecoder.readBoolean()) {
          if (expGolombDecoder.readBoolean()) {
            aspectRatioIdc = expGolombDecoder.readUnsignedByte();
            switch (aspectRatioIdc) {
              case 1:
                sarRatio = [1, 1];
                break;
              case 2:
                sarRatio = [12, 11];
                break;
              case 3:
                sarRatio = [10, 11];
                break;
              case 4:
                sarRatio = [16, 11];
                break;
              case 5:
                sarRatio = [40, 33];
                break;
              case 6:
                sarRatio = [24, 11];
                break;
              case 7:
                sarRatio = [20, 11];
                break;
              case 8:
                sarRatio = [32, 11];
                break;
              case 9:
                sarRatio = [80, 33];
                break;
              case 10:
                sarRatio = [18, 11];
                break;
              case 11:
                sarRatio = [15, 11];
                break;
              case 12:
                sarRatio = [64, 33];
                break;
              case 13:
                sarRatio = [160, 99];
                break;
              case 14:
                sarRatio = [4, 3];
                break;
              case 15:
                sarRatio = [3, 2];
                break;
              case 16:
                sarRatio = [2, 1];
                break;
              case 255:
                {
                  sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];
                  break;
                }
            }
            if (sarRatio) {
              sarRatio[0] / sarRatio[1];
            }
          }
        }
        return {
          profileIdc: profileIdc,
          levelIdc: levelIdc,
          profileCompatibility: profileCompatibility,
          width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,
          height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,
          sarRatio: sarRatio
        };
      };
    };
    _H264Stream.prototype = new stream();
    var h264 = {
      H264Stream: _H264Stream,
      NalByteStream: _NalByteStream
    };
    var ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
    var parseId3TagSize = function parseId3TagSize(header, byteIndex) {
      var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],
          flags = header[byteIndex + 5],
          footerPresent = (flags & 16) >> 4;
      returnSize = returnSize >= 0 ? returnSize : 0;
      if (footerPresent) {
        return returnSize + 20;
      }
      return returnSize + 10;
    };
    var getId3Offset = function getId3Offset(data, offset) {
      if (data.length - offset < 10 || data[offset] !== 'I'.charCodeAt(0) || data[offset + 1] !== 'D'.charCodeAt(0) || data[offset + 2] !== '3'.charCodeAt(0)) {
        return offset;
      }
      offset += parseId3TagSize(data, offset);
      return getId3Offset(data, offset);
    };
    var isLikelyAacData$1 = function isLikelyAacData(data) {
      var offset = getId3Offset(data, 0);
      return data.length >= offset + 2 && (data[offset] & 0xFF) === 0xFF && (data[offset + 1] & 0xF0) === 0xF0 &&
      (data[offset + 1] & 0x16) === 0x10;
    };
    var parseSyncSafeInteger = function parseSyncSafeInteger(data) {
      return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
    };
    var percentEncode = function percentEncode(bytes, start, end) {
      var i,
          result = '';
      for (i = start; i < end; i++) {
        result += '%' + ('00' + bytes[i].toString(16)).slice(-2);
      }
      return result;
    };
    var parseIso88591 = function parseIso88591(bytes, start, end) {
      return unescape(percentEncode(bytes, start, end));
    };
    var parseAdtsSize = function parseAdtsSize(header, byteIndex) {
      var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,
          middle = header[byteIndex + 4] << 3,
          highTwo = header[byteIndex + 3] & 0x3 << 11;
      return highTwo | middle | lowThree;
    };
    var parseType$2 = function parseType(header, byteIndex) {
      if (header[byteIndex] === 'I'.charCodeAt(0) && header[byteIndex + 1] === 'D'.charCodeAt(0) && header[byteIndex + 2] === '3'.charCodeAt(0)) {
        return 'timed-metadata';
      } else if (header[byteIndex] & 0xff === 0xff && (header[byteIndex + 1] & 0xf0) === 0xf0) {
        return 'audio';
      }
      return null;
    };
    var parseSampleRate = function parseSampleRate(packet) {
      var i = 0;
      while (i + 5 < packet.length) {
        if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {
          i++;
          continue;
        }
        return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];
      }
      return null;
    };
    var parseAacTimestamp = function parseAacTimestamp(packet) {
      var frameStart, frameSize, frame, frameHeader;
      frameStart = 10;
      if (packet[5] & 0x40) {
        frameStart += 4;
        frameStart += parseSyncSafeInteger(packet.subarray(10, 14));
      }
      do {
        frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));
        if (frameSize < 1) {
          return null;
        }
        frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);
        if (frameHeader === 'PRIV') {
          frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);
          for (var i = 0; i < frame.byteLength; i++) {
            if (frame[i] === 0) {
              var owner = parseIso88591(frame, 0, i);
              if (owner === 'com.apple.streaming.transportStreamTimestamp') {
                var d = frame.subarray(i + 1);
                var size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
                size *= 4;
                size += d[7] & 0x03;
                return size;
              }
              break;
            }
          }
        }
        frameStart += 10;
        frameStart += frameSize;
      } while (frameStart < packet.byteLength);
      return null;
    };
    var utils = {
      isLikelyAacData: isLikelyAacData$1,
      parseId3TagSize: parseId3TagSize,
      parseAdtsSize: parseAdtsSize,
      parseType: parseType$2,
      parseSampleRate: parseSampleRate,
      parseAacTimestamp: parseAacTimestamp
    };
    var _AacStream;
    _AacStream = function AacStream() {
      var everything = new Uint8Array(),
          timeStamp = 0;
      _AacStream.prototype.init.call(this);
      this.setTimestamp = function (timestamp) {
        timeStamp = timestamp;
      };
      this.push = function (bytes) {
        var frameSize = 0,
            byteIndex = 0,
            bytesLeft,
            chunk,
            packet,
            tempLength;
        if (everything.length) {
          tempLength = everything.length;
          everything = new Uint8Array(bytes.byteLength + tempLength);
          everything.set(everything.subarray(0, tempLength));
          everything.set(bytes, tempLength);
        } else {
          everything = bytes;
        }
        while (everything.length - byteIndex >= 3) {
          if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {
            if (everything.length - byteIndex < 10) {
              break;
            }
            frameSize = utils.parseId3TagSize(everything, byteIndex);
            if (byteIndex + frameSize > everything.length) {
              break;
            }
            chunk = {
              type: 'timed-metadata',
              data: everything.subarray(byteIndex, byteIndex + frameSize)
            };
            this.trigger('data', chunk);
            byteIndex += frameSize;
            continue;
          } else if ((everything[byteIndex] & 0xff) === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {
            if (everything.length - byteIndex < 7) {
              break;
            }
            frameSize = utils.parseAdtsSize(everything, byteIndex);
            if (byteIndex + frameSize > everything.length) {
              break;
            }
            packet = {
              type: 'audio',
              data: everything.subarray(byteIndex, byteIndex + frameSize),
              pts: timeStamp,
              dts: timeStamp
            };
            this.trigger('data', packet);
            byteIndex += frameSize;
            continue;
          }
          byteIndex++;
        }
        bytesLeft = everything.length - byteIndex;
        if (bytesLeft > 0) {
          everything = everything.subarray(byteIndex);
        } else {
          everything = new Uint8Array();
        }
      };
      this.reset = function () {
        everything = new Uint8Array();
        this.trigger('reset');
      };
      this.endTimeline = function () {
        everything = new Uint8Array();
        this.trigger('endedtimeline');
      };
    };
    _AacStream.prototype = new stream();
    var aac = _AacStream;
    var AUDIO_PROPERTIES = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];
    var audioProperties = AUDIO_PROPERTIES;
    var VIDEO_PROPERTIES = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility', 'sarRatio'];
    var videoProperties = VIDEO_PROPERTIES;
    var H264Stream = h264.H264Stream;
    var isLikelyAacData = utils.isLikelyAacData;
    var ONE_SECOND_IN_TS$1 = clock.ONE_SECOND_IN_TS;
    var _VideoSegmentStream, _AudioSegmentStream, _Transmuxer, _CoalesceStream;
    var retriggerForStream = function retriggerForStream(key, event) {
      event.stream = key;
      this.trigger('log', event);
    };
    var addPipelineLogRetriggers = function addPipelineLogRetriggers(transmuxer, pipeline) {
      var keys = Object.keys(pipeline);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key === 'headOfPipeline' || !pipeline[key].on) {
          continue;
        }
        pipeline[key].on('log', retriggerForStream.bind(transmuxer, key));
      }
    };
    var arrayEquals = function arrayEquals(a, b) {
      var i;
      if (a.length !== b.length) {
        return false;
      }
      for (i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    };
    var generateSegmentTimingInfo = function generateSegmentTimingInfo(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {
      var ptsOffsetFromDts = startPts - startDts,
          decodeDuration = endDts - startDts,
          presentationDuration = endPts - startPts;
      return {
        start: {
          dts: baseMediaDecodeTime,
          pts: baseMediaDecodeTime + ptsOffsetFromDts
        },
        end: {
          dts: baseMediaDecodeTime + decodeDuration,
          pts: baseMediaDecodeTime + presentationDuration
        },
        prependedContentDuration: prependedContentDuration,
        baseMediaDecodeTime: baseMediaDecodeTime
      };
    };
    _AudioSegmentStream = function AudioSegmentStream(track, options) {
      var adtsFrames = [],
          sequenceNumber,
          earliestAllowedDts = 0,
          audioAppendStartTs = 0,
          videoBaseMediaDecodeTime = Infinity;
      options = options || {};
      sequenceNumber = options.firstSequenceNumber || 0;
      _AudioSegmentStream.prototype.init.call(this);
      this.push = function (data) {
        trackDecodeInfo.collectDtsInfo(track, data);
        if (track) {
          audioProperties.forEach(function (prop) {
            track[prop] = data[prop];
          });
        }
        adtsFrames.push(data);
      };
      this.setEarliestDts = function (earliestDts) {
        earliestAllowedDts = earliestDts;
      };
      this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {
        videoBaseMediaDecodeTime = baseMediaDecodeTime;
      };
      this.setAudioAppendStart = function (timestamp) {
        audioAppendStartTs = timestamp;
      };
      this.flush = function () {
        var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed;
        if (adtsFrames.length === 0) {
          this.trigger('done', 'AudioSegmentStream');
          return;
        }
        frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);
        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
        videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);
        track.samples = audioFrameUtils.generateSampleTable(frames);
        mdat = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));
        adtsFrames = [];
        moof = mp4Generator.moof(sequenceNumber, [track]);
        boxes = new Uint8Array(moof.byteLength + mdat.byteLength);
        sequenceNumber++;
        boxes.set(moof);
        boxes.set(mdat, moof.byteLength);
        trackDecodeInfo.clearDtsInfo(track);
        frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);
        if (frames.length) {
          segmentDuration = frames.length * frameDuration;
          this.trigger('segmentTimingInfo', generateSegmentTimingInfo(
          clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate),
          frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));
          this.trigger('timingInfo', {
            start: frames[0].pts,
            end: frames[0].pts + segmentDuration
          });
        }
        this.trigger('data', {
          track: track,
          boxes: boxes
        });
        this.trigger('done', 'AudioSegmentStream');
      };
      this.reset = function () {
        trackDecodeInfo.clearDtsInfo(track);
        adtsFrames = [];
        this.trigger('reset');
      };
    };
    _AudioSegmentStream.prototype = new stream();
    _VideoSegmentStream = function VideoSegmentStream(track, options) {
      var sequenceNumber,
          nalUnits = [],
          gopsToAlignWith = [],
          config,
          pps;
      options = options || {};
      sequenceNumber = options.firstSequenceNumber || 0;
      _VideoSegmentStream.prototype.init.call(this);
      delete track.minPTS;
      this.gopCache_ = [];
      this.push = function (nalUnit) {
        trackDecodeInfo.collectDtsInfo(track, nalUnit);
        if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {
          config = nalUnit.config;
          track.sps = [nalUnit.data];
          videoProperties.forEach(function (prop) {
            track[prop] = config[prop];
          }, this);
        }
        if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {
          pps = nalUnit.data;
          track.pps = [nalUnit.data];
        }
        nalUnits.push(nalUnit);
      };
      this.flush = function () {
        var frames,
            gopForFusion,
            gops,
            moof,
            mdat,
            boxes,
            prependedContentDuration = 0,
            firstGop,
            lastGop;
        while (nalUnits.length) {
          if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {
            break;
          }
          nalUnits.shift();
        }
        if (nalUnits.length === 0) {
          this.resetStream_();
          this.trigger('done', 'VideoSegmentStream');
          return;
        }
        frames = frameUtils.groupNalsIntoFrames(nalUnits);
        gops = frameUtils.groupFramesIntoGops(frames);
        if (!gops[0][0].keyFrame) {
          gopForFusion = this.getGopForFusion_(nalUnits[0], track);
          if (gopForFusion) {
            prependedContentDuration = gopForFusion.duration;
            gops.unshift(gopForFusion);
            gops.byteLength += gopForFusion.byteLength;
            gops.nalCount += gopForFusion.nalCount;
            gops.pts = gopForFusion.pts;
            gops.dts = gopForFusion.dts;
            gops.duration += gopForFusion.duration;
          } else {
            gops = frameUtils.extendFirstKeyFrame(gops);
          }
        }
        if (gopsToAlignWith.length) {
          var alignedGops;
          if (options.alignGopsAtEnd) {
            alignedGops = this.alignGopsAtEnd_(gops);
          } else {
            alignedGops = this.alignGopsAtStart_(gops);
          }
          if (!alignedGops) {
            this.gopCache_.unshift({
              gop: gops.pop(),
              pps: track.pps,
              sps: track.sps
            });
            this.gopCache_.length = Math.min(6, this.gopCache_.length);
            nalUnits = [];
            this.resetStream_();
            this.trigger('done', 'VideoSegmentStream');
            return;
          }
          trackDecodeInfo.clearDtsInfo(track);
          gops = alignedGops;
        }
        trackDecodeInfo.collectDtsInfo(track, gops);
        track.samples = frameUtils.generateSampleTable(gops);
        mdat = mp4Generator.mdat(frameUtils.concatenateNalData(gops));
        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
        this.trigger('processedGopsInfo', gops.map(function (gop) {
          return {
            pts: gop.pts,
            dts: gop.dts,
            byteLength: gop.byteLength
          };
        }));
        firstGop = gops[0];
        lastGop = gops[gops.length - 1];
        this.trigger('segmentTimingInfo', generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));
        this.trigger('timingInfo', {
          start: gops[0].pts,
          end: gops[gops.length - 1].pts + gops[gops.length - 1].duration
        });
        this.gopCache_.unshift({
          gop: gops.pop(),
          pps: track.pps,
          sps: track.sps
        });
        this.gopCache_.length = Math.min(6, this.gopCache_.length);
        nalUnits = [];
        this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);
        this.trigger('timelineStartInfo', track.timelineStartInfo);
        moof = mp4Generator.moof(sequenceNumber, [track]);
        boxes = new Uint8Array(moof.byteLength + mdat.byteLength);
        sequenceNumber++;
        boxes.set(moof);
        boxes.set(mdat, moof.byteLength);
        this.trigger('data', {
          track: track,
          boxes: boxes
        });
        this.resetStream_();
        this.trigger('done', 'VideoSegmentStream');
      };
      this.reset = function () {
        this.resetStream_();
        nalUnits = [];
        this.gopCache_.length = 0;
        gopsToAlignWith.length = 0;
        this.trigger('reset');
      };
      this.resetStream_ = function () {
        trackDecodeInfo.clearDtsInfo(track);
        config = undefined;
        pps = undefined;
      };
      this.getGopForFusion_ = function (nalUnit) {
        var halfSecond = 45000,
        allowableOverlap = 10000,
        nearestDistance = Infinity,
            dtsDistance,
            nearestGopObj,
            currentGop,
            currentGopObj,
            i;
        for (i = 0; i < this.gopCache_.length; i++) {
          currentGopObj = this.gopCache_[i];
          currentGop = currentGopObj.gop;
          if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {
            continue;
          }
          if (currentGop.dts < track.timelineStartInfo.dts) {
            continue;
          }
          dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration;
          if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {
            if (!nearestGopObj || nearestDistance > dtsDistance) {
              nearestGopObj = currentGopObj;
              nearestDistance = dtsDistance;
            }
          }
        }
        if (nearestGopObj) {
          return nearestGopObj.gop;
        }
        return null;
      };
      this.alignGopsAtStart_ = function (gops) {
        var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;
        byteLength = gops.byteLength;
        nalCount = gops.nalCount;
        duration = gops.duration;
        alignIndex = gopIndex = 0;
        while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {
          align = gopsToAlignWith[alignIndex];
          gop = gops[gopIndex];
          if (align.pts === gop.pts) {
            break;
          }
          if (gop.pts > align.pts) {
            alignIndex++;
            continue;
          }
          gopIndex++;
          byteLength -= gop.byteLength;
          nalCount -= gop.nalCount;
          duration -= gop.duration;
        }
        if (gopIndex === 0) {
          return gops;
        }
        if (gopIndex === gops.length) {
          return null;
        }
        alignedGops = gops.slice(gopIndex);
        alignedGops.byteLength = byteLength;
        alignedGops.duration = duration;
        alignedGops.nalCount = nalCount;
        alignedGops.pts = alignedGops[0].pts;
        alignedGops.dts = alignedGops[0].dts;
        return alignedGops;
      };
      this.alignGopsAtEnd_ = function (gops) {
        var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;
        alignIndex = gopsToAlignWith.length - 1;
        gopIndex = gops.length - 1;
        alignEndIndex = null;
        matchFound = false;
        while (alignIndex >= 0 && gopIndex >= 0) {
          align = gopsToAlignWith[alignIndex];
          gop = gops[gopIndex];
          if (align.pts === gop.pts) {
            matchFound = true;
            break;
          }
          if (align.pts > gop.pts) {
            alignIndex--;
            continue;
          }
          if (alignIndex === gopsToAlignWith.length - 1) {
            alignEndIndex = gopIndex;
          }
          gopIndex--;
        }
        if (!matchFound && alignEndIndex === null) {
          return null;
        }
        var trimIndex;
        if (matchFound) {
          trimIndex = gopIndex;
        } else {
          trimIndex = alignEndIndex;
        }
        if (trimIndex === 0) {
          return gops;
        }
        var alignedGops = gops.slice(trimIndex);
        var metadata = alignedGops.reduce(function (total, gop) {
          total.byteLength += gop.byteLength;
          total.duration += gop.duration;
          total.nalCount += gop.nalCount;
          return total;
        }, {
          byteLength: 0,
          duration: 0,
          nalCount: 0
        });
        alignedGops.byteLength = metadata.byteLength;
        alignedGops.duration = metadata.duration;
        alignedGops.nalCount = metadata.nalCount;
        alignedGops.pts = alignedGops[0].pts;
        alignedGops.dts = alignedGops[0].dts;
        return alignedGops;
      };
      this.alignGopsWith = function (newGopsToAlignWith) {
        gopsToAlignWith = newGopsToAlignWith;
      };
    };
    _VideoSegmentStream.prototype = new stream();
    _CoalesceStream = function CoalesceStream(options, metadataStream) {
      this.numberOfTracks = 0;
      this.metadataStream = metadataStream;
      options = options || {};
      if (typeof options.remux !== 'undefined') {
        this.remuxTracks = !!options.remux;
      } else {
        this.remuxTracks = true;
      }
      if (typeof options.keepOriginalTimestamps === 'boolean') {
        this.keepOriginalTimestamps = options.keepOriginalTimestamps;
      } else {
        this.keepOriginalTimestamps = false;
      }
      this.pendingTracks = [];
      this.videoTrack = null;
      this.pendingBoxes = [];
      this.pendingCaptions = [];
      this.pendingMetadata = [];
      this.pendingBytes = 0;
      this.emittedTracks = 0;
      _CoalesceStream.prototype.init.call(this);
      this.push = function (output) {
        if (output.text) {
          return this.pendingCaptions.push(output);
        }
        if (output.frames) {
          return this.pendingMetadata.push(output);
        }
        this.pendingTracks.push(output.track);
        this.pendingBytes += output.boxes.byteLength;
        if (output.track.type === 'video') {
          this.videoTrack = output.track;
          this.pendingBoxes.push(output.boxes);
        }
        if (output.track.type === 'audio') {
          this.audioTrack = output.track;
          this.pendingBoxes.unshift(output.boxes);
        }
      };
    };
    _CoalesceStream.prototype = new stream();
    _CoalesceStream.prototype.flush = function (flushSource) {
      var offset = 0,
          event = {
        captions: [],
        captionStreams: {},
        metadata: [],
        info: {}
      },
          caption,
          id3,
          initSegment,
          timelineStartPts = 0,
          i;
      if (this.pendingTracks.length < this.numberOfTracks) {
        if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {
          return;
        } else if (this.remuxTracks) {
          return;
        } else if (this.pendingTracks.length === 0) {
          this.emittedTracks++;
          if (this.emittedTracks >= this.numberOfTracks) {
            this.trigger('done');
            this.emittedTracks = 0;
          }
          return;
        }
      }
      if (this.videoTrack) {
        timelineStartPts = this.videoTrack.timelineStartInfo.pts;
        videoProperties.forEach(function (prop) {
          event.info[prop] = this.videoTrack[prop];
        }, this);
      } else if (this.audioTrack) {
        timelineStartPts = this.audioTrack.timelineStartInfo.pts;
        audioProperties.forEach(function (prop) {
          event.info[prop] = this.audioTrack[prop];
        }, this);
      }
      if (this.videoTrack || this.audioTrack) {
        if (this.pendingTracks.length === 1) {
          event.type = this.pendingTracks[0].type;
        } else {
          event.type = 'combined';
        }
        this.emittedTracks += this.pendingTracks.length;
        initSegment = mp4Generator.initSegment(this.pendingTracks);
        event.initSegment = new Uint8Array(initSegment.byteLength);
        event.initSegment.set(initSegment);
        event.data = new Uint8Array(this.pendingBytes);
        for (i = 0; i < this.pendingBoxes.length; i++) {
          event.data.set(this.pendingBoxes[i], offset);
          offset += this.pendingBoxes[i].byteLength;
        }
        for (i = 0; i < this.pendingCaptions.length; i++) {
          caption = this.pendingCaptions[i];
          caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);
          caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);
          event.captionStreams[caption.stream] = true;
          event.captions.push(caption);
        }
        for (i = 0; i < this.pendingMetadata.length; i++) {
          id3 = this.pendingMetadata[i];
          id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);
          event.metadata.push(id3);
        }
        event.metadata.dispatchType = this.metadataStream.dispatchType;
        this.pendingTracks.length = 0;
        this.videoTrack = null;
        this.pendingBoxes.length = 0;
        this.pendingCaptions.length = 0;
        this.pendingBytes = 0;
        this.pendingMetadata.length = 0;
        this.trigger('data', event);
        for (i = 0; i < event.captions.length; i++) {
          caption = event.captions[i];
          this.trigger('caption', caption);
        }
        for (i = 0; i < event.metadata.length; i++) {
          id3 = event.metadata[i];
          this.trigger('id3Frame', id3);
        }
      }
      if (this.emittedTracks >= this.numberOfTracks) {
        this.trigger('done');
        this.emittedTracks = 0;
      }
    };
    _CoalesceStream.prototype.setRemux = function (val) {
      this.remuxTracks = val;
    };
    _Transmuxer = function Transmuxer(options) {
      var self = this,
          hasFlushed = true,
          videoTrack,
          audioTrack;
      _Transmuxer.prototype.init.call(this);
      options = options || {};
      this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;
      this.transmuxPipeline_ = {};
      this.setupAacPipeline = function () {
        var pipeline = {};
        this.transmuxPipeline_ = pipeline;
        pipeline.type = 'aac';
        pipeline.metadataStream = new m2ts_1.MetadataStream();
        pipeline.aacStream = new aac();
        pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('audio');
        pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('timed-metadata');
        pipeline.adtsStream = new adts();
        pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);
        pipeline.headOfPipeline = pipeline.aacStream;
        pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);
        pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
        pipeline.metadataStream.on('timestamp', function (frame) {
          pipeline.aacStream.setTimestamp(frame.timeStamp);
        });
        pipeline.aacStream.on('data', function (data) {
          if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {
            return;
          }
          audioTrack = audioTrack || {
            timelineStartInfo: {
              baseMediaDecodeTime: self.baseMediaDecodeTime
            },
            codec: 'adts',
            type: 'audio'
          };
          pipeline.coalesceStream.numberOfTracks++;
          pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);
          pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));
          pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo'));
          pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
          self.trigger('trackinfo', {
            hasAudio: !!audioTrack,
            hasVideo: !!videoTrack
          });
        });
        pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));
        pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));
        addPipelineLogRetriggers(this, pipeline);
      };
      this.setupTsPipeline = function () {
        var pipeline = {};
        this.transmuxPipeline_ = pipeline;
        pipeline.type = 'ts';
        pipeline.metadataStream = new m2ts_1.MetadataStream();
        pipeline.packetStream = new m2ts_1.TransportPacketStream();
        pipeline.parseStream = new m2ts_1.TransportParseStream();
        pipeline.elementaryStream = new m2ts_1.ElementaryStream();
        pipeline.timestampRolloverStream = new m2ts_1.TimestampRolloverStream();
        pipeline.adtsStream = new adts();
        pipeline.h264Stream = new H264Stream();
        pipeline.captionStream = new m2ts_1.CaptionStream(options);
        pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);
        pipeline.headOfPipeline = pipeline.packetStream;
        pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream);
        pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);
        pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);
        pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
        pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);
        pipeline.elementaryStream.on('data', function (data) {
          var i;
          if (data.type === 'metadata') {
            i = data.tracks.length;
            while (i--) {
              if (!videoTrack && data.tracks[i].type === 'video') {
                videoTrack = data.tracks[i];
                videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;
              } else if (!audioTrack && data.tracks[i].type === 'audio') {
                audioTrack = data.tracks[i];
                audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;
              }
            }
            if (videoTrack && !pipeline.videoSegmentStream) {
              pipeline.coalesceStream.numberOfTracks++;
              pipeline.videoSegmentStream = new _VideoSegmentStream(videoTrack, options);
              pipeline.videoSegmentStream.on('log', self.getLogTrigger_('videoSegmentStream'));
              pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {
                if (audioTrack && !options.keepOriginalTimestamps) {
                  audioTrack.timelineStartInfo = timelineStartInfo;
                  pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);
                }
              });
              pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));
              pipeline.videoSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'videoSegmentTimingInfo'));
              pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {
                if (audioTrack) {
                  pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);
                }
              });
              pipeline.videoSegmentStream.on('timingInfo', self.trigger.bind(self, 'videoTimingInfo'));
              pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);
            }
            if (audioTrack && !pipeline.audioSegmentStream) {
              pipeline.coalesceStream.numberOfTracks++;
              pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);
              pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));
              pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo'));
              pipeline.audioSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'audioSegmentTimingInfo'));
              pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
            }
            self.trigger('trackinfo', {
              hasAudio: !!audioTrack,
              hasVideo: !!videoTrack
            });
          }
        });
        pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));
        pipeline.coalesceStream.on('id3Frame', function (id3Frame) {
          id3Frame.dispatchType = pipeline.metadataStream.dispatchType;
          self.trigger('id3Frame', id3Frame);
        });
        pipeline.coalesceStream.on('caption', this.trigger.bind(this, 'caption'));
        pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));
        addPipelineLogRetriggers(this, pipeline);
      };
      this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {
        var pipeline = this.transmuxPipeline_;
        if (!options.keepOriginalTimestamps) {
          this.baseMediaDecodeTime = baseMediaDecodeTime;
        }
        if (audioTrack) {
          audioTrack.timelineStartInfo.dts = undefined;
          audioTrack.timelineStartInfo.pts = undefined;
          trackDecodeInfo.clearDtsInfo(audioTrack);
          if (pipeline.audioTimestampRolloverStream) {
            pipeline.audioTimestampRolloverStream.discontinuity();
          }
        }
        if (videoTrack) {
          if (pipeline.videoSegmentStream) {
            pipeline.videoSegmentStream.gopCache_ = [];
          }
          videoTrack.timelineStartInfo.dts = undefined;
          videoTrack.timelineStartInfo.pts = undefined;
          trackDecodeInfo.clearDtsInfo(videoTrack);
          pipeline.captionStream.reset();
        }
        if (pipeline.timestampRolloverStream) {
          pipeline.timestampRolloverStream.discontinuity();
        }
      };
      this.setAudioAppendStart = function (timestamp) {
        if (audioTrack) {
          this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);
        }
      };
      this.setRemux = function (val) {
        var pipeline = this.transmuxPipeline_;
        options.remux = val;
        if (pipeline && pipeline.coalesceStream) {
          pipeline.coalesceStream.setRemux(val);
        }
      };
      this.alignGopsWith = function (gopsToAlignWith) {
        if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {
          this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);
        }
      };
      this.getLogTrigger_ = function (key) {
        var self = this;
        return function (event) {
          event.stream = key;
          self.trigger('log', event);
        };
      };
      this.push = function (data) {
        if (hasFlushed) {
          var isAac = isLikelyAacData(data);
          if (isAac && this.transmuxPipeline_.type !== 'aac') {
            this.setupAacPipeline();
          } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {
            this.setupTsPipeline();
          }
          hasFlushed = false;
        }
        this.transmuxPipeline_.headOfPipeline.push(data);
      };
      this.flush = function () {
        hasFlushed = true;
        this.transmuxPipeline_.headOfPipeline.flush();
      };
      this.endTimeline = function () {
        this.transmuxPipeline_.headOfPipeline.endTimeline();
      };
      this.reset = function () {
        if (this.transmuxPipeline_.headOfPipeline) {
          this.transmuxPipeline_.headOfPipeline.reset();
        }
      };
      this.resetCaptions = function () {
        if (this.transmuxPipeline_.captionStream) {
          this.transmuxPipeline_.captionStream.reset();
        }
      };
    };
    _Transmuxer.prototype = new stream();
    var transmuxer = {
      Transmuxer: _Transmuxer,
      VideoSegmentStream: _VideoSegmentStream,
      AudioSegmentStream: _AudioSegmentStream,
      AUDIO_PROPERTIES: audioProperties,
      VIDEO_PROPERTIES: videoProperties,
      generateSegmentTimingInfo: generateSegmentTimingInfo
    };
    var toUnsigned$3 = function toUnsigned(value) {
      return value >>> 0;
    };
    var toHexString$1 = function toHexString(value) {
      return ('00' + value.toString(16)).slice(-2);
    };
    var bin = {
      toUnsigned: toUnsigned$3,
      toHexString: toHexString$1
    };
    var parseType$1 = function parseType(buffer) {
      var result = '';
      result += String.fromCharCode(buffer[0]);
      result += String.fromCharCode(buffer[1]);
      result += String.fromCharCode(buffer[2]);
      result += String.fromCharCode(buffer[3]);
      return result;
    };
    var parseType_1 = parseType$1;
    var toUnsigned$2 = bin.toUnsigned;
    var findBox = function findBox(data, path) {
      var results = [],
          i,
          size,
          type,
          end,
          subresults;
      if (!path.length) {
        return null;
      }
      for (i = 0; i < data.byteLength;) {
        size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);
        type = parseType_1(data.subarray(i + 4, i + 8));
        end = size > 1 ? i + size : data.byteLength;
        if (type === path[0]) {
          if (path.length === 1) {
            results.push(data.subarray(i + 8, end));
          } else {
            subresults = findBox(data.subarray(i + 8, end), path.slice(1));
            if (subresults.length) {
              results = results.concat(subresults);
            }
          }
        }
        i = end;
      }
      return results;
    };
    var findBox_1 = findBox;
    var toUnsigned$1 = bin.toUnsigned;
    var getUint64$1 = numbers.getUint64;
    var tfdt = function tfdt(data) {
      var result = {
        version: data[0],
        flags: new Uint8Array(data.subarray(1, 4))
      };
      if (result.version === 1) {
        result.baseMediaDecodeTime = getUint64$1(data.subarray(4));
      } else {
        result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);
      }
      return result;
    };
    var parseTfdt = tfdt;
    var parseSampleFlags = function parseSampleFlags(flags) {
      return {
        isLeading: (flags[0] & 0x0c) >>> 2,
        dependsOn: flags[0] & 0x03,
        isDependedOn: (flags[1] & 0xc0) >>> 6,
        hasRedundancy: (flags[1] & 0x30) >>> 4,
        paddingValue: (flags[1] & 0x0e) >>> 1,
        isNonSyncSample: flags[1] & 0x01,
        degradationPriority: flags[2] << 8 | flags[3]
      };
    };
    var parseSampleFlags_1 = parseSampleFlags;
    var trun = function trun(data) {
      var result = {
        version: data[0],
        flags: new Uint8Array(data.subarray(1, 4)),
        samples: []
      },
          view = new DataView(data.buffer, data.byteOffset, data.byteLength),
      dataOffsetPresent = result.flags[2] & 0x01,
      firstSampleFlagsPresent = result.flags[2] & 0x04,
      sampleDurationPresent = result.flags[1] & 0x01,
      sampleSizePresent = result.flags[1] & 0x02,
      sampleFlagsPresent = result.flags[1] & 0x04,
      sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,
      sampleCount = view.getUint32(4),
          offset = 8,
          sample;
      if (dataOffsetPresent) {
        result.dataOffset = view.getInt32(offset);
        offset += 4;
      }
      if (firstSampleFlagsPresent && sampleCount) {
        sample = {
          flags: parseSampleFlags_1(data.subarray(offset, offset + 4))
        };
        offset += 4;
        if (sampleDurationPresent) {
          sample.duration = view.getUint32(offset);
          offset += 4;
        }
        if (sampleSizePresent) {
          sample.size = view.getUint32(offset);
          offset += 4;
        }
        if (sampleCompositionTimeOffsetPresent) {
          if (result.version === 1) {
            sample.compositionTimeOffset = view.getInt32(offset);
          } else {
            sample.compositionTimeOffset = view.getUint32(offset);
          }
          offset += 4;
        }
        result.samples.push(sample);
        sampleCount--;
      }
      while (sampleCount--) {
        sample = {};
        if (sampleDurationPresent) {
          sample.duration = view.getUint32(offset);
          offset += 4;
        }
        if (sampleSizePresent) {
          sample.size = view.getUint32(offset);
          offset += 4;
        }
        if (sampleFlagsPresent) {
          sample.flags = parseSampleFlags_1(data.subarray(offset, offset + 4));
          offset += 4;
        }
        if (sampleCompositionTimeOffsetPresent) {
          if (result.version === 1) {
            sample.compositionTimeOffset = view.getInt32(offset);
          } else {
            sample.compositionTimeOffset = view.getUint32(offset);
          }
          offset += 4;
        }
        result.samples.push(sample);
      }
      return result;
    };
    var parseTrun = trun;
    var tfhd = function tfhd(data) {
      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
          result = {
        version: data[0],
        flags: new Uint8Array(data.subarray(1, 4)),
        trackId: view.getUint32(4)
      },
          baseDataOffsetPresent = result.flags[2] & 0x01,
          sampleDescriptionIndexPresent = result.flags[2] & 0x02,
          defaultSampleDurationPresent = result.flags[2] & 0x08,
          defaultSampleSizePresent = result.flags[2] & 0x10,
          defaultSampleFlagsPresent = result.flags[2] & 0x20,
          durationIsEmpty = result.flags[0] & 0x010000,
          defaultBaseIsMoof = result.flags[0] & 0x020000,
          i;
      i = 8;
      if (baseDataOffsetPresent) {
        i += 4;
        result.baseDataOffset = view.getUint32(12);
        i += 4;
      }
      if (sampleDescriptionIndexPresent) {
        result.sampleDescriptionIndex = view.getUint32(i);
        i += 4;
      }
      if (defaultSampleDurationPresent) {
        result.defaultSampleDuration = view.getUint32(i);
        i += 4;
      }
      if (defaultSampleSizePresent) {
        result.defaultSampleSize = view.getUint32(i);
        i += 4;
      }
      if (defaultSampleFlagsPresent) {
        result.defaultSampleFlags = view.getUint32(i);
      }
      if (durationIsEmpty) {
        result.durationIsEmpty = true;
      }
      if (!baseDataOffsetPresent && defaultBaseIsMoof) {
        result.baseDataOffsetIsMoof = true;
      }
      return result;
    };
    var parseTfhd = tfhd;
    var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof commonjsGlobal$1 !== "undefined") {
      win = commonjsGlobal$1;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    var window_1 = win;
    var discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes;
    var CaptionStream = captionStream.CaptionStream;
    var mapToSample = function mapToSample(offset, samples) {
      var approximateOffset = offset;
      for (var i = 0; i < samples.length; i++) {
        var sample = samples[i];
        if (approximateOffset < sample.size) {
          return sample;
        }
        approximateOffset -= sample.size;
      }
      return null;
    };
    var findSeiNals = function findSeiNals(avcStream, samples, trackId) {
      var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),
          result = {
        logs: [],
        seiNals: []
      },
          seiNal,
          i,
          length,
          lastMatchedSample;
      for (i = 0; i + 4 < avcStream.length; i += length) {
        length = avcView.getUint32(i);
        i += 4;
        if (length <= 0) {
          continue;
        }
        switch (avcStream[i] & 0x1F) {
          case 0x06:
            var data = avcStream.subarray(i + 1, i + 1 + length);
            var matchingSample = mapToSample(i, samples);
            seiNal = {
              nalUnitType: 'sei_rbsp',
              size: length,
              data: data,
              escapedRBSP: discardEmulationPreventionBytes(data),
              trackId: trackId
            };
            if (matchingSample) {
              seiNal.pts = matchingSample.pts;
              seiNal.dts = matchingSample.dts;
              lastMatchedSample = matchingSample;
            } else if (lastMatchedSample) {
              seiNal.pts = lastMatchedSample.pts;
              seiNal.dts = lastMatchedSample.dts;
            } else {
              result.logs.push({
                level: 'warn',
                message: 'We\'ve encountered a nal unit without data at ' + i + ' for trackId ' + trackId + '. See mux.js#223.'
              });
              break;
            }
            result.seiNals.push(seiNal);
            break;
        }
      }
      return result;
    };
    var parseSamples = function parseSamples(truns, baseMediaDecodeTime, tfhd) {
      var currentDts = baseMediaDecodeTime;
      var defaultSampleDuration = tfhd.defaultSampleDuration || 0;
      var defaultSampleSize = tfhd.defaultSampleSize || 0;
      var trackId = tfhd.trackId;
      var allSamples = [];
      truns.forEach(function (trun) {
        var trackRun = parseTrun(trun);
        var samples = trackRun.samples;
        samples.forEach(function (sample) {
          if (sample.duration === undefined) {
            sample.duration = defaultSampleDuration;
          }
          if (sample.size === undefined) {
            sample.size = defaultSampleSize;
          }
          sample.trackId = trackId;
          sample.dts = currentDts;
          if (sample.compositionTimeOffset === undefined) {
            sample.compositionTimeOffset = 0;
          }
          if (typeof currentDts === 'bigint') {
            sample.pts = currentDts + window_1.BigInt(sample.compositionTimeOffset);
            currentDts += window_1.BigInt(sample.duration);
          } else {
            sample.pts = currentDts + sample.compositionTimeOffset;
            currentDts += sample.duration;
          }
        });
        allSamples = allSamples.concat(samples);
      });
      return allSamples;
    };
    var parseCaptionNals = function parseCaptionNals(segment, videoTrackId) {
      var trafs = findBox_1(segment, ['moof', 'traf']);
      var mdats = findBox_1(segment, ['mdat']);
      var captionNals = {};
      var mdatTrafPairs = [];
      mdats.forEach(function (mdat, index) {
        var matchingTraf = trafs[index];
        mdatTrafPairs.push({
          mdat: mdat,
          traf: matchingTraf
        });
      });
      mdatTrafPairs.forEach(function (pair) {
        var mdat = pair.mdat;
        var traf = pair.traf;
        var tfhd = findBox_1(traf, ['tfhd']);
        var headerInfo = parseTfhd(tfhd[0]);
        var trackId = headerInfo.trackId;
        var tfdt = findBox_1(traf, ['tfdt']);
        var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;
        var truns = findBox_1(traf, ['trun']);
        var samples;
        var result;
        if (videoTrackId === trackId && truns.length > 0) {
          samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);
          result = findSeiNals(mdat, samples, trackId);
          if (!captionNals[trackId]) {
            captionNals[trackId] = {
              seiNals: [],
              logs: []
            };
          }
          captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);
          captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);
        }
      });
      return captionNals;
    };
    var parseEmbeddedCaptions = function parseEmbeddedCaptions(segment, trackId, timescale) {
      var captionNals;
      if (trackId === null) {
        return null;
      }
      captionNals = parseCaptionNals(segment, trackId);
      var trackNals = captionNals[trackId] || {};
      return {
        seiNals: trackNals.seiNals,
        logs: trackNals.logs,
        timescale: timescale
      };
    };
    var CaptionParser = function CaptionParser() {
      var isInitialized = false;
      var captionStream;
      var segmentCache;
      var trackId;
      var timescale;
      var parsedCaptions;
      var parsingPartial;
      this.isInitialized = function () {
        return isInitialized;
      };
      this.init = function (options) {
        captionStream = new CaptionStream();
        isInitialized = true;
        parsingPartial = options ? options.isPartial : false;
        captionStream.on('data', function (event) {
          event.startTime = event.startPts / timescale;
          event.endTime = event.endPts / timescale;
          parsedCaptions.captions.push(event);
          parsedCaptions.captionStreams[event.stream] = true;
        });
        captionStream.on('log', function (log) {
          parsedCaptions.logs.push(log);
        });
      };
      this.isNewInit = function (videoTrackIds, timescales) {
        if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === 'object' && Object.keys(timescales).length === 0) {
          return false;
        }
        return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];
      };
      this.parse = function (segment, videoTrackIds, timescales) {
        var parsedData;
        if (!this.isInitialized()) {
          return null;
        } else if (!videoTrackIds || !timescales) {
          return null;
        } else if (this.isNewInit(videoTrackIds, timescales)) {
          trackId = videoTrackIds[0];
          timescale = timescales[trackId];
        } else if (trackId === null || !timescale) {
          segmentCache.push(segment);
          return null;
        }
        while (segmentCache.length > 0) {
          var cachedSegment = segmentCache.shift();
          this.parse(cachedSegment, videoTrackIds, timescales);
        }
        parsedData = parseEmbeddedCaptions(segment, trackId, timescale);
        if (parsedData && parsedData.logs) {
          parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);
        }
        if (parsedData === null || !parsedData.seiNals) {
          if (parsedCaptions.logs.length) {
            return {
              logs: parsedCaptions.logs,
              captions: [],
              captionStreams: []
            };
          }
          return null;
        }
        this.pushNals(parsedData.seiNals);
        this.flushStream();
        return parsedCaptions;
      };
      this.pushNals = function (nals) {
        if (!this.isInitialized() || !nals || nals.length === 0) {
          return null;
        }
        nals.forEach(function (nal) {
          captionStream.push(nal);
        });
      };
      this.flushStream = function () {
        if (!this.isInitialized()) {
          return null;
        }
        if (!parsingPartial) {
          captionStream.flush();
        } else {
          captionStream.partialFlush();
        }
      };
      this.clearParsedCaptions = function () {
        parsedCaptions.captions = [];
        parsedCaptions.captionStreams = {};
        parsedCaptions.logs = [];
      };
      this.resetCaptionStream = function () {
        if (!this.isInitialized()) {
          return null;
        }
        captionStream.reset();
      };
      this.clearAllCaptions = function () {
        this.clearParsedCaptions();
        this.resetCaptionStream();
      };
      this.reset = function () {
        segmentCache = [];
        trackId = null;
        timescale = null;
        if (!parsedCaptions) {
          parsedCaptions = {
            captions: [],
            captionStreams: {},
            logs: []
          };
        } else {
          this.clearParsedCaptions();
        }
        this.resetCaptionStream();
      };
      this.reset();
    };
    var captionParser = CaptionParser;
    var toUnsigned = bin.toUnsigned;
    var toHexString = bin.toHexString;
    var getUint64 = numbers.getUint64;
    var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader;
    timescale = function timescale(init) {
      var result = {},
          traks = findBox_1(init, ['moov', 'trak']);
      return traks.reduce(function (result, trak) {
        var tkhd, version, index, id, mdhd;
        tkhd = findBox_1(trak, ['tkhd'])[0];
        if (!tkhd) {
          return null;
        }
        version = tkhd[0];
        index = version === 0 ? 12 : 20;
        id = toUnsigned(tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]);
        mdhd = findBox_1(trak, ['mdia', 'mdhd'])[0];
        if (!mdhd) {
          return null;
        }
        version = mdhd[0];
        index = version === 0 ? 12 : 20;
        result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);
        return result;
      }, result);
    };
    startTime = function startTime(timescale, fragment) {
      var trafs;
      trafs = findBox_1(fragment, ['moof', 'traf']);
      var lowestTime = trafs.reduce(function (acc, traf) {
        var tfhd = findBox_1(traf, ['tfhd'])[0];
        var id = toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7]);
        var scale = timescale[id] || 90e3;
        var tfdt = findBox_1(traf, ['tfdt'])[0];
        var dv = new DataView(tfdt.buffer, tfdt.byteOffset, tfdt.byteLength);
        var baseTime;
        if (tfdt[0] === 1) {
          baseTime = getUint64(tfdt.subarray(4, 12));
        } else {
          baseTime = dv.getUint32(4);
        }
        var seconds;
        if (typeof baseTime === 'bigint') {
          seconds = baseTime / window_1.BigInt(scale);
        } else if (typeof baseTime === 'number' && !isNaN(baseTime)) {
          seconds = baseTime / scale;
        }
        if (seconds < Number.MAX_SAFE_INTEGER) {
          seconds = Number(seconds);
        }
        if (seconds < acc) {
          acc = seconds;
        }
        return acc;
      }, Infinity);
      return typeof lowestTime === 'bigint' || isFinite(lowestTime) ? lowestTime : 0;
    };
    compositionStartTime = function compositionStartTime(timescales, fragment) {
      var trafBoxes = findBox_1(fragment, ['moof', 'traf']);
      var baseMediaDecodeTime = 0;
      var compositionTimeOffset = 0;
      var trackId;
      if (trafBoxes && trafBoxes.length) {
        var tfhd = findBox_1(trafBoxes[0], ['tfhd'])[0];
        var trun = findBox_1(trafBoxes[0], ['trun'])[0];
        var tfdt = findBox_1(trafBoxes[0], ['tfdt'])[0];
        if (tfhd) {
          var parsedTfhd = parseTfhd(tfhd);
          trackId = parsedTfhd.trackId;
        }
        if (tfdt) {
          var parsedTfdt = parseTfdt(tfdt);
          baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;
        }
        if (trun) {
          var parsedTrun = parseTrun(trun);
          if (parsedTrun.samples && parsedTrun.samples.length) {
            compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;
          }
        }
      }
      var timescale = timescales[trackId] || 90e3;
      if (typeof baseMediaDecodeTime === 'bigint') {
        compositionTimeOffset = window_1.BigInt(compositionTimeOffset);
        timescale = window_1.BigInt(timescale);
      }
      var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale;
      if (typeof result === 'bigint' && result < Number.MAX_SAFE_INTEGER) {
        result = Number(result);
      }
      return result;
    };
    getVideoTrackIds = function getVideoTrackIds(init) {
      var traks = findBox_1(init, ['moov', 'trak']);
      var videoTrackIds = [];
      traks.forEach(function (trak) {
        var hdlrs = findBox_1(trak, ['mdia', 'hdlr']);
        var tkhds = findBox_1(trak, ['tkhd']);
        hdlrs.forEach(function (hdlr, index) {
          var handlerType = parseType_1(hdlr.subarray(8, 12));
          var tkhd = tkhds[index];
          var view;
          var version;
          var trackId;
          if (handlerType === 'vide') {
            view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);
            version = view.getUint8(0);
            trackId = version === 0 ? view.getUint32(12) : view.getUint32(20);
            videoTrackIds.push(trackId);
          }
        });
      });
      return videoTrackIds;
    };
    getTimescaleFromMediaHeader = function getTimescaleFromMediaHeader(mdhd) {
      var version = mdhd[0];
      var index = version === 0 ? 12 : 20;
      return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);
    };
    getTracks = function getTracks(init) {
      var traks = findBox_1(init, ['moov', 'trak']);
      var tracks = [];
      traks.forEach(function (trak) {
        var track = {};
        var tkhd = findBox_1(trak, ['tkhd'])[0];
        var view, tkhdVersion;
        if (tkhd) {
          view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);
          tkhdVersion = view.getUint8(0);
          track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);
        }
        var hdlr = findBox_1(trak, ['mdia', 'hdlr'])[0];
        if (hdlr) {
          var type = parseType_1(hdlr.subarray(8, 12));
          if (type === 'vide') {
            track.type = 'video';
          } else if (type === 'soun') {
            track.type = 'audio';
          } else {
            track.type = type;
          }
        }
        var stsd = findBox_1(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];
        if (stsd) {
          var sampleDescriptions = stsd.subarray(8);
          track.codec = parseType_1(sampleDescriptions.subarray(4, 8));
          var codecBox = findBox_1(sampleDescriptions, [track.codec])[0];
          var codecConfig, codecConfigType;
          if (codecBox) {
            if (/^[asm]vc[1-9]$/i.test(track.codec)) {
              codecConfig = codecBox.subarray(78);
              codecConfigType = parseType_1(codecConfig.subarray(4, 8));
              if (codecConfigType === 'avcC' && codecConfig.length > 11) {
                track.codec += '.';
                track.codec += toHexString(codecConfig[9]);
                track.codec += toHexString(codecConfig[10]);
                track.codec += toHexString(codecConfig[11]);
              } else {
                track.codec = 'avc1.4d400d';
              }
            } else if (/^mp4[a,v]$/i.test(track.codec)) {
              codecConfig = codecBox.subarray(28);
              codecConfigType = parseType_1(codecConfig.subarray(4, 8));
              if (codecConfigType === 'esds' && codecConfig.length > 20 && codecConfig[19] !== 0) {
                track.codec += '.' + toHexString(codecConfig[19]);
                track.codec += '.' + toHexString(codecConfig[20] >>> 2 & 0x3f).replace(/^0/, '');
              } else {
                track.codec = 'mp4a.40.2';
              }
            } else {
              track.codec = track.codec.toLowerCase();
            }
          }
        }
        var mdhd = findBox_1(trak, ['mdia', 'mdhd'])[0];
        if (mdhd) {
          track.timescale = getTimescaleFromMediaHeader(mdhd);
        }
        tracks.push(track);
      });
      return tracks;
    };
    var probe$2 = {
      findBox: findBox_1,
      parseType: parseType_1,
      timescale: timescale,
      startTime: startTime,
      compositionStartTime: compositionStartTime,
      videoTrackIds: getVideoTrackIds,
      tracks: getTracks,
      getTimescaleFromMediaHeader: getTimescaleFromMediaHeader
    };
    var parsePid = function parsePid(packet) {
      var pid = packet[1] & 0x1f;
      pid <<= 8;
      pid |= packet[2];
      return pid;
    };
    var parsePayloadUnitStartIndicator = function parsePayloadUnitStartIndicator(packet) {
      return !!(packet[1] & 0x40);
    };
    var parseAdaptionField = function parseAdaptionField(packet) {
      var offset = 0;
      if ((packet[3] & 0x30) >>> 4 > 0x01) {
        offset += packet[4] + 1;
      }
      return offset;
    };
    var parseType = function parseType(packet, pmtPid) {
      var pid = parsePid(packet);
      if (pid === 0) {
        return 'pat';
      } else if (pid === pmtPid) {
        return 'pmt';
      } else if (pmtPid) {
        return 'pes';
      }
      return null;
    };
    var parsePat = function parsePat(packet) {
      var pusi = parsePayloadUnitStartIndicator(packet);
      var offset = 4 + parseAdaptionField(packet);
      if (pusi) {
        offset += packet[offset] + 1;
      }
      return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];
    };
    var parsePmt = function parsePmt(packet) {
      var programMapTable = {};
      var pusi = parsePayloadUnitStartIndicator(packet);
      var payloadOffset = 4 + parseAdaptionField(packet);
      if (pusi) {
        payloadOffset += packet[payloadOffset] + 1;
      }
      if (!(packet[payloadOffset + 5] & 0x01)) {
        return;
      }
      var sectionLength, tableEnd, programInfoLength;
      sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];
      tableEnd = 3 + sectionLength - 4;
      programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11];
      var offset = 12 + programInfoLength;
      while (offset < tableEnd) {
        var i = payloadOffset + offset;
        programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i];
        offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;
      }
      return programMapTable;
    };
    var parsePesType = function parsePesType(packet, programMapTable) {
      var pid = parsePid(packet);
      var type = programMapTable[pid];
      switch (type) {
        case streamTypes.H264_STREAM_TYPE:
          return 'video';
        case streamTypes.ADTS_STREAM_TYPE:
          return 'audio';
        case streamTypes.METADATA_STREAM_TYPE:
          return 'timed-metadata';
        default:
          return null;
      }
    };
    var parsePesTime = function parsePesTime(packet) {
      var pusi = parsePayloadUnitStartIndicator(packet);
      if (!pusi) {
        return null;
      }
      var offset = 4 + parseAdaptionField(packet);
      if (offset >= packet.byteLength) {
        return null;
      }
      var pes = null;
      var ptsDtsFlags;
      ptsDtsFlags = packet[offset + 7];
      if (ptsDtsFlags & 0xC0) {
        pes = {};
        pes.pts = (packet[offset + 9] & 0x0E) << 27 | (packet[offset + 10] & 0xFF) << 20 | (packet[offset + 11] & 0xFE) << 12 | (packet[offset + 12] & 0xFF) << 5 | (packet[offset + 13] & 0xFE) >>> 3;
        pes.pts *= 4;
        pes.pts += (packet[offset + 13] & 0x06) >>> 1;
        pes.dts = pes.pts;
        if (ptsDtsFlags & 0x40) {
          pes.dts = (packet[offset + 14] & 0x0E) << 27 | (packet[offset + 15] & 0xFF) << 20 | (packet[offset + 16] & 0xFE) << 12 | (packet[offset + 17] & 0xFF) << 5 | (packet[offset + 18] & 0xFE) >>> 3;
          pes.dts *= 4;
          pes.dts += (packet[offset + 18] & 0x06) >>> 1;
        }
      }
      return pes;
    };
    var parseNalUnitType = function parseNalUnitType(type) {
      switch (type) {
        case 0x05:
          return 'slice_layer_without_partitioning_rbsp_idr';
        case 0x06:
          return 'sei_rbsp';
        case 0x07:
          return 'seq_parameter_set_rbsp';
        case 0x08:
          return 'pic_parameter_set_rbsp';
        case 0x09:
          return 'access_unit_delimiter_rbsp';
        default:
          return null;
      }
    };
    var videoPacketContainsKeyFrame = function videoPacketContainsKeyFrame(packet) {
      var offset = 4 + parseAdaptionField(packet);
      var frameBuffer = packet.subarray(offset);
      var frameI = 0;
      var frameSyncPoint = 0;
      var foundKeyFrame = false;
      var nalType;
      for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {
        if (frameBuffer[frameSyncPoint + 2] === 1) {
          frameI = frameSyncPoint + 5;
          break;
        }
      }
      while (frameI < frameBuffer.byteLength) {
        switch (frameBuffer[frameI]) {
          case 0:
            if (frameBuffer[frameI - 1] !== 0) {
              frameI += 2;
              break;
            } else if (frameBuffer[frameI - 2] !== 0) {
              frameI++;
              break;
            }
            if (frameSyncPoint + 3 !== frameI - 2) {
              nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);
              if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {
                foundKeyFrame = true;
              }
            }
            do {
              frameI++;
            } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);
            frameSyncPoint = frameI - 2;
            frameI += 3;
            break;
          case 1:
            if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {
              frameI += 3;
              break;
            }
            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);
            if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {
              foundKeyFrame = true;
            }
            frameSyncPoint = frameI - 2;
            frameI += 3;
            break;
          default:
            frameI += 3;
            break;
        }
      }
      frameBuffer = frameBuffer.subarray(frameSyncPoint);
      frameI -= frameSyncPoint;
      frameSyncPoint = 0;
      if (frameBuffer && frameBuffer.byteLength > 3) {
        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);
        if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {
          foundKeyFrame = true;
        }
      }
      return foundKeyFrame;
    };
    var probe$1 = {
      parseType: parseType,
      parsePat: parsePat,
      parsePmt: parsePmt,
      parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,
      parsePesType: parsePesType,
      parsePesTime: parsePesTime,
      videoPacketContainsKeyFrame: videoPacketContainsKeyFrame
    };
    var handleRollover = timestampRolloverStream.handleRollover;
    var probe = {};
    probe.ts = probe$1;
    probe.aac = utils;
    var ONE_SECOND_IN_TS = clock.ONE_SECOND_IN_TS;
    var MP2T_PACKET_LENGTH = 188,
    SYNC_BYTE = 0x47;
    var parsePsi_ = function parsePsi_(bytes, pmt) {
      var startIndex = 0,
          endIndex = MP2T_PACKET_LENGTH,
          packet,
          type;
      while (endIndex < bytes.byteLength) {
        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
          packet = bytes.subarray(startIndex, endIndex);
          type = probe.ts.parseType(packet, pmt.pid);
          switch (type) {
            case 'pat':
              pmt.pid = probe.ts.parsePat(packet);
              break;
            case 'pmt':
              var table = probe.ts.parsePmt(packet);
              pmt.table = pmt.table || {};
              Object.keys(table).forEach(function (key) {
                pmt.table[key] = table[key];
              });
              break;
          }
          startIndex += MP2T_PACKET_LENGTH;
          endIndex += MP2T_PACKET_LENGTH;
          continue;
        }
        startIndex++;
        endIndex++;
      }
    };
    var parseAudioPes_ = function parseAudioPes_(bytes, pmt, result) {
      var startIndex = 0,
          endIndex = MP2T_PACKET_LENGTH,
          packet,
          type,
          pesType,
          pusi,
          parsed;
      var endLoop = false;
      while (endIndex <= bytes.byteLength) {
        if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
          packet = bytes.subarray(startIndex, endIndex);
          type = probe.ts.parseType(packet, pmt.pid);
          switch (type) {
            case 'pes':
              pesType = probe.ts.parsePesType(packet, pmt.table);
              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
              if (pesType === 'audio' && pusi) {
                parsed = probe.ts.parsePesTime(packet);
                if (parsed) {
                  parsed.type = 'audio';
                  result.audio.push(parsed);
                  endLoop = true;
                }
              }
              break;
          }
          if (endLoop) {
            break;
          }
          startIndex += MP2T_PACKET_LENGTH;
          endIndex += MP2T_PACKET_LENGTH;
          continue;
        }
        startIndex++;
        endIndex++;
      }
      endIndex = bytes.byteLength;
      startIndex = endIndex - MP2T_PACKET_LENGTH;
      endLoop = false;
      while (startIndex >= 0) {
        if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
          packet = bytes.subarray(startIndex, endIndex);
          type = probe.ts.parseType(packet, pmt.pid);
          switch (type) {
            case 'pes':
              pesType = probe.ts.parsePesType(packet, pmt.table);
              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
              if (pesType === 'audio' && pusi) {
                parsed = probe.ts.parsePesTime(packet);
                if (parsed) {
                  parsed.type = 'audio';
                  result.audio.push(parsed);
                  endLoop = true;
                }
              }
              break;
          }
          if (endLoop) {
            break;
          }
          startIndex -= MP2T_PACKET_LENGTH;
          endIndex -= MP2T_PACKET_LENGTH;
          continue;
        }
        startIndex--;
        endIndex--;
      }
    };
    var parseVideoPes_ = function parseVideoPes_(bytes, pmt, result) {
      var startIndex = 0,
          endIndex = MP2T_PACKET_LENGTH,
          packet,
          type,
          pesType,
          pusi,
          parsed,
          frame,
          i,
          pes;
      var endLoop = false;
      var currentFrame = {
        data: [],
        size: 0
      };
      while (endIndex < bytes.byteLength) {
        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
          packet = bytes.subarray(startIndex, endIndex);
          type = probe.ts.parseType(packet, pmt.pid);
          switch (type) {
            case 'pes':
              pesType = probe.ts.parsePesType(packet, pmt.table);
              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
              if (pesType === 'video') {
                if (pusi && !endLoop) {
                  parsed = probe.ts.parsePesTime(packet);
                  if (parsed) {
                    parsed.type = 'video';
                    result.video.push(parsed);
                    endLoop = true;
                  }
                }
                if (!result.firstKeyFrame) {
                  if (pusi) {
                    if (currentFrame.size !== 0) {
                      frame = new Uint8Array(currentFrame.size);
                      i = 0;
                      while (currentFrame.data.length) {
                        pes = currentFrame.data.shift();
                        frame.set(pes, i);
                        i += pes.byteLength;
                      }
                      if (probe.ts.videoPacketContainsKeyFrame(frame)) {
                        var firstKeyFrame = probe.ts.parsePesTime(frame);
                        if (firstKeyFrame) {
                          result.firstKeyFrame = firstKeyFrame;
                          result.firstKeyFrame.type = 'video';
                        } else {
                          console.warn('Failed to extract PTS/DTS from PES at first keyframe. ' + 'This could be an unusual TS segment, or else mux.js did not ' + 'parse your TS segment correctly. If you know your TS ' + 'segments do contain PTS/DTS on keyframes please file a bug ' + 'report! You can try ffprobe to double check for yourself.');
                        }
                      }
                      currentFrame.size = 0;
                    }
                  }
                  currentFrame.data.push(packet);
                  currentFrame.size += packet.byteLength;
                }
              }
              break;
          }
          if (endLoop && result.firstKeyFrame) {
            break;
          }
          startIndex += MP2T_PACKET_LENGTH;
          endIndex += MP2T_PACKET_LENGTH;
          continue;
        }
        startIndex++;
        endIndex++;
      }
      endIndex = bytes.byteLength;
      startIndex = endIndex - MP2T_PACKET_LENGTH;
      endLoop = false;
      while (startIndex >= 0) {
        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
          packet = bytes.subarray(startIndex, endIndex);
          type = probe.ts.parseType(packet, pmt.pid);
          switch (type) {
            case 'pes':
              pesType = probe.ts.parsePesType(packet, pmt.table);
              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
              if (pesType === 'video' && pusi) {
                parsed = probe.ts.parsePesTime(packet);
                if (parsed) {
                  parsed.type = 'video';
                  result.video.push(parsed);
                  endLoop = true;
                }
              }
              break;
          }
          if (endLoop) {
            break;
          }
          startIndex -= MP2T_PACKET_LENGTH;
          endIndex -= MP2T_PACKET_LENGTH;
          continue;
        }
        startIndex--;
        endIndex--;
      }
    };
    var adjustTimestamp_ = function adjustTimestamp_(segmentInfo, baseTimestamp) {
      if (segmentInfo.audio && segmentInfo.audio.length) {
        var audioBaseTimestamp = baseTimestamp;
        if (typeof audioBaseTimestamp === 'undefined' || isNaN(audioBaseTimestamp)) {
          audioBaseTimestamp = segmentInfo.audio[0].dts;
        }
        segmentInfo.audio.forEach(function (info) {
          info.dts = handleRollover(info.dts, audioBaseTimestamp);
          info.pts = handleRollover(info.pts, audioBaseTimestamp);
          info.dtsTime = info.dts / ONE_SECOND_IN_TS;
          info.ptsTime = info.pts / ONE_SECOND_IN_TS;
        });
      }
      if (segmentInfo.video && segmentInfo.video.length) {
        var videoBaseTimestamp = baseTimestamp;
        if (typeof videoBaseTimestamp === 'undefined' || isNaN(videoBaseTimestamp)) {
          videoBaseTimestamp = segmentInfo.video[0].dts;
        }
        segmentInfo.video.forEach(function (info) {
          info.dts = handleRollover(info.dts, videoBaseTimestamp);
          info.pts = handleRollover(info.pts, videoBaseTimestamp);
          info.dtsTime = info.dts / ONE_SECOND_IN_TS;
          info.ptsTime = info.pts / ONE_SECOND_IN_TS;
        });
        if (segmentInfo.firstKeyFrame) {
          var frame = segmentInfo.firstKeyFrame;
          frame.dts = handleRollover(frame.dts, videoBaseTimestamp);
          frame.pts = handleRollover(frame.pts, videoBaseTimestamp);
          frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;
          frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;
        }
      }
    };
    var inspectAac_ = function inspectAac_(bytes) {
      var endLoop = false,
          audioCount = 0,
          sampleRate = null,
          timestamp = null,
          frameSize = 0,
          byteIndex = 0,
          packet;
      while (bytes.length - byteIndex >= 3) {
        var type = probe.aac.parseType(bytes, byteIndex);
        switch (type) {
          case 'timed-metadata':
            if (bytes.length - byteIndex < 10) {
              endLoop = true;
              break;
            }
            frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);
            if (frameSize > bytes.length) {
              endLoop = true;
              break;
            }
            if (timestamp === null) {
              packet = bytes.subarray(byteIndex, byteIndex + frameSize);
              timestamp = probe.aac.parseAacTimestamp(packet);
            }
            byteIndex += frameSize;
            break;
          case 'audio':
            if (bytes.length - byteIndex < 7) {
              endLoop = true;
              break;
            }
            frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);
            if (frameSize > bytes.length) {
              endLoop = true;
              break;
            }
            if (sampleRate === null) {
              packet = bytes.subarray(byteIndex, byteIndex + frameSize);
              sampleRate = probe.aac.parseSampleRate(packet);
            }
            audioCount++;
            byteIndex += frameSize;
            break;
          default:
            byteIndex++;
            break;
        }
        if (endLoop) {
          return null;
        }
      }
      if (sampleRate === null || timestamp === null) {
        return null;
      }
      var audioTimescale = ONE_SECOND_IN_TS / sampleRate;
      var result = {
        audio: [{
          type: 'audio',
          dts: timestamp,
          pts: timestamp
        }, {
          type: 'audio',
          dts: timestamp + audioCount * 1024 * audioTimescale,
          pts: timestamp + audioCount * 1024 * audioTimescale
        }]
      };
      return result;
    };
    var inspectTs_ = function inspectTs_(bytes) {
      var pmt = {
        pid: null,
        table: null
      };
      var result = {};
      parsePsi_(bytes, pmt);
      for (var pid in pmt.table) {
        if (pmt.table.hasOwnProperty(pid)) {
          var type = pmt.table[pid];
          switch (type) {
            case streamTypes.H264_STREAM_TYPE:
              result.video = [];
              parseVideoPes_(bytes, pmt, result);
              if (result.video.length === 0) {
                delete result.video;
              }
              break;
            case streamTypes.ADTS_STREAM_TYPE:
              result.audio = [];
              parseAudioPes_(bytes, pmt, result);
              if (result.audio.length === 0) {
                delete result.audio;
              }
              break;
          }
        }
      }
      return result;
    };
    var inspect = function inspect(bytes, baseTimestamp) {
      var isAacData = probe.aac.isLikelyAacData(bytes);
      var result;
      if (isAacData) {
        result = inspectAac_(bytes);
      } else {
        result = inspectTs_(bytes);
      }
      if (!result || !result.audio && !result.video) {
        return null;
      }
      adjustTimestamp_(result, baseTimestamp);
      return result;
    };
    var tsInspector = {
      inspect: inspect,
      parseAudioPes_: parseAudioPes_
    };
    var wireTransmuxerEvents = function wireTransmuxerEvents(self, transmuxer) {
      transmuxer.on('data', function (segment) {
        var initArray = segment.initSegment;
        segment.initSegment = {
          data: initArray.buffer,
          byteOffset: initArray.byteOffset,
          byteLength: initArray.byteLength
        };
        var typedArray = segment.data;
        segment.data = typedArray.buffer;
        self.postMessage({
          action: 'data',
          segment: segment,
          byteOffset: typedArray.byteOffset,
          byteLength: typedArray.byteLength
        }, [segment.data]);
      });
      transmuxer.on('done', function (data) {
        self.postMessage({
          action: 'done'
        });
      });
      transmuxer.on('gopInfo', function (gopInfo) {
        self.postMessage({
          action: 'gopInfo',
          gopInfo: gopInfo
        });
      });
      transmuxer.on('videoSegmentTimingInfo', function (timingInfo) {
        var videoSegmentTimingInfo = {
          start: {
            decode: clock.videoTsToSeconds(timingInfo.start.dts),
            presentation: clock.videoTsToSeconds(timingInfo.start.pts)
          },
          end: {
            decode: clock.videoTsToSeconds(timingInfo.end.dts),
            presentation: clock.videoTsToSeconds(timingInfo.end.pts)
          },
          baseMediaDecodeTime: clock.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
        };
        if (timingInfo.prependedContentDuration) {
          videoSegmentTimingInfo.prependedContentDuration = clock.videoTsToSeconds(timingInfo.prependedContentDuration);
        }
        self.postMessage({
          action: 'videoSegmentTimingInfo',
          videoSegmentTimingInfo: videoSegmentTimingInfo
        });
      });
      transmuxer.on('audioSegmentTimingInfo', function (timingInfo) {
        var audioSegmentTimingInfo = {
          start: {
            decode: clock.videoTsToSeconds(timingInfo.start.dts),
            presentation: clock.videoTsToSeconds(timingInfo.start.pts)
          },
          end: {
            decode: clock.videoTsToSeconds(timingInfo.end.dts),
            presentation: clock.videoTsToSeconds(timingInfo.end.pts)
          },
          baseMediaDecodeTime: clock.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
        };
        if (timingInfo.prependedContentDuration) {
          audioSegmentTimingInfo.prependedContentDuration = clock.videoTsToSeconds(timingInfo.prependedContentDuration);
        }
        self.postMessage({
          action: 'audioSegmentTimingInfo',
          audioSegmentTimingInfo: audioSegmentTimingInfo
        });
      });
      transmuxer.on('id3Frame', function (id3Frame) {
        self.postMessage({
          action: 'id3Frame',
          id3Frame: id3Frame
        });
      });
      transmuxer.on('caption', function (caption) {
        self.postMessage({
          action: 'caption',
          caption: caption
        });
      });
      transmuxer.on('trackinfo', function (trackInfo) {
        self.postMessage({
          action: 'trackinfo',
          trackInfo: trackInfo
        });
      });
      transmuxer.on('audioTimingInfo', function (audioTimingInfo) {
        self.postMessage({
          action: 'audioTimingInfo',
          audioTimingInfo: {
            start: clock.videoTsToSeconds(audioTimingInfo.start),
            end: clock.videoTsToSeconds(audioTimingInfo.end)
          }
        });
      });
      transmuxer.on('videoTimingInfo', function (videoTimingInfo) {
        self.postMessage({
          action: 'videoTimingInfo',
          videoTimingInfo: {
            start: clock.videoTsToSeconds(videoTimingInfo.start),
            end: clock.videoTsToSeconds(videoTimingInfo.end)
          }
        });
      });
      transmuxer.on('log', function (log) {
        self.postMessage({
          action: 'log',
          log: log
        });
      });
    };
    var MessageHandlers = function () {
      function MessageHandlers(self, options) {
        this.options = options || {};
        this.self = self;
        this.init();
      }
      var _proto = MessageHandlers.prototype;
      _proto.init = function init() {
        if (this.transmuxer) {
          this.transmuxer.dispose();
        }
        this.transmuxer = new transmuxer.Transmuxer(this.options);
        wireTransmuxerEvents(this.self, this.transmuxer);
      };
      _proto.pushMp4Captions = function pushMp4Captions(data) {
        if (!this.captionParser) {
          this.captionParser = new captionParser();
          this.captionParser.init();
        }
        var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
        var parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);
        this.self.postMessage({
          action: 'mp4Captions',
          captions: parsed && parsed.captions || [],
          logs: parsed && parsed.logs || [],
          data: segment.buffer
        }, [segment.buffer]);
      };
      _proto.probeMp4StartTime = function probeMp4StartTime(_ref) {
        var timescales = _ref.timescales,
            data = _ref.data;
        var startTime = probe$2.startTime(timescales, data);
        this.self.postMessage({
          action: 'probeMp4StartTime',
          startTime: startTime,
          data: data
        }, [data.buffer]);
      };
      _proto.probeMp4Tracks = function probeMp4Tracks(_ref2) {
        var data = _ref2.data;
        var tracks = probe$2.tracks(data);
        this.self.postMessage({
          action: 'probeMp4Tracks',
          tracks: tracks,
          data: data
        }, [data.buffer]);
      }
      ;
      _proto.probeTs = function probeTs(_ref3) {
        var data = _ref3.data,
            baseStartTime = _ref3.baseStartTime;
        var tsStartTime = typeof baseStartTime === 'number' && !isNaN(baseStartTime) ? baseStartTime * clock.ONE_SECOND_IN_TS : void 0;
        var timeInfo = tsInspector.inspect(data, tsStartTime);
        var result = null;
        if (timeInfo) {
          result = {
            hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,
            hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false
          };
          if (result.hasVideo) {
            result.videoStart = timeInfo.video[0].ptsTime;
          }
          if (result.hasAudio) {
            result.audioStart = timeInfo.audio[0].ptsTime;
          }
        }
        this.self.postMessage({
          action: 'probeTs',
          result: result,
          data: data
        }, [data.buffer]);
      };
      _proto.clearAllMp4Captions = function clearAllMp4Captions() {
        if (this.captionParser) {
          this.captionParser.clearAllCaptions();
        }
      };
      _proto.clearParsedMp4Captions = function clearParsedMp4Captions() {
        if (this.captionParser) {
          this.captionParser.clearParsedCaptions();
        }
      }
      ;
      _proto.push = function push(data) {
        var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
        this.transmuxer.push(segment);
      }
      ;
      _proto.reset = function reset() {
        this.transmuxer.reset();
      }
      ;
      _proto.setTimestampOffset = function setTimestampOffset(data) {
        var timestampOffset = data.timestampOffset || 0;
        this.transmuxer.setBaseMediaDecodeTime(Math.round(clock.secondsToVideoTs(timestampOffset)));
      };
      _proto.setAudioAppendStart = function setAudioAppendStart(data) {
        this.transmuxer.setAudioAppendStart(Math.ceil(clock.secondsToVideoTs(data.appendStart)));
      };
      _proto.setRemux = function setRemux(data) {
        this.transmuxer.setRemux(data.remux);
      }
      ;
      _proto.flush = function flush(data) {
        this.transmuxer.flush();
        self.postMessage({
          action: 'done',
          type: 'transmuxed'
        });
      };
      _proto.endTimeline = function endTimeline() {
        this.transmuxer.endTimeline();
        self.postMessage({
          action: 'endedtimeline',
          type: 'transmuxed'
        });
      };
      _proto.alignGopsWith = function alignGopsWith(data) {
        this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());
      };
      return MessageHandlers;
    }();
    self.onmessage = function (event) {
      if (event.data.action === 'init' && event.data.options) {
        this.messageHandlers = new MessageHandlers(self, event.data.options);
        return;
      }
      if (!this.messageHandlers) {
        this.messageHandlers = new MessageHandlers(self);
      }
      if (event.data && event.data.action && event.data.action !== 'init') {
        if (this.messageHandlers[event.data.action]) {
          this.messageHandlers[event.data.action](event.data);
        }
      }
    };
  }));
  var TransmuxWorker = factory(workerCode$1);
  var handleData_ = function handleData_(event, transmuxedData, callback) {
    var _event$data$segment = event.data.segment,
        type = _event$data$segment.type,
        initSegment = _event$data$segment.initSegment,
        captions = _event$data$segment.captions,
        captionStreams = _event$data$segment.captionStreams,
        metadata = _event$data$segment.metadata,
        videoFrameDtsTime = _event$data$segment.videoFrameDtsTime,
        videoFramePtsTime = _event$data$segment.videoFramePtsTime;
    transmuxedData.buffer.push({
      captions: captions,
      captionStreams: captionStreams,
      metadata: metadata
    });
    var boxes = event.data.segment.boxes || {
      data: event.data.segment.data
    };
    var result = {
      type: type,
      data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),
      initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)
    };
    if (typeof videoFrameDtsTime !== 'undefined') {
      result.videoFrameDtsTime = videoFrameDtsTime;
    }
    if (typeof videoFramePtsTime !== 'undefined') {
      result.videoFramePtsTime = videoFramePtsTime;
    }
    callback(result);
  };
  var handleDone_ = function handleDone_(_ref) {
    var transmuxedData = _ref.transmuxedData,
        callback = _ref.callback;
    transmuxedData.buffer = [];
    callback(transmuxedData);
  };
  var handleGopInfo_ = function handleGopInfo_(event, transmuxedData) {
    transmuxedData.gopInfo = event.data.gopInfo;
  };
  var processTransmux = function processTransmux(options) {
    var transmuxer = options.transmuxer,
        bytes = options.bytes,
        audioAppendStart = options.audioAppendStart,
        gopsToAlignWith = options.gopsToAlignWith,
        remux = options.remux,
        onData = options.onData,
        onTrackInfo = options.onTrackInfo,
        onAudioTimingInfo = options.onAudioTimingInfo,
        onVideoTimingInfo = options.onVideoTimingInfo,
        onVideoSegmentTimingInfo = options.onVideoSegmentTimingInfo,
        onAudioSegmentTimingInfo = options.onAudioSegmentTimingInfo,
        onId3 = options.onId3,
        onCaptions = options.onCaptions,
        onDone = options.onDone,
        onEndedTimeline = options.onEndedTimeline,
        onTransmuxerLog = options.onTransmuxerLog,
        isEndOfTimeline = options.isEndOfTimeline;
    var transmuxedData = {
      buffer: []
    };
    var waitForEndedTimelineEvent = isEndOfTimeline;
    var handleMessage = function handleMessage(event) {
      if (transmuxer.currentTransmux !== options) {
        return;
      }
      if (event.data.action === 'data') {
        handleData_(event, transmuxedData, onData);
      }
      if (event.data.action === 'trackinfo') {
        onTrackInfo(event.data.trackInfo);
      }
      if (event.data.action === 'gopInfo') {
        handleGopInfo_(event, transmuxedData);
      }
      if (event.data.action === 'audioTimingInfo') {
        onAudioTimingInfo(event.data.audioTimingInfo);
      }
      if (event.data.action === 'videoTimingInfo') {
        onVideoTimingInfo(event.data.videoTimingInfo);
      }
      if (event.data.action === 'videoSegmentTimingInfo') {
        onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);
      }
      if (event.data.action === 'audioSegmentTimingInfo') {
        onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo);
      }
      if (event.data.action === 'id3Frame') {
        onId3([event.data.id3Frame], event.data.id3Frame.dispatchType);
      }
      if (event.data.action === 'caption') {
        onCaptions(event.data.caption);
      }
      if (event.data.action === 'endedtimeline') {
        waitForEndedTimelineEvent = false;
        onEndedTimeline();
      }
      if (event.data.action === 'log') {
        onTransmuxerLog(event.data.log);
      }
      if (event.data.type !== 'transmuxed') {
        return;
      }
      if (waitForEndedTimelineEvent) {
        return;
      }
      transmuxer.onmessage = null;
      handleDone_({
        transmuxedData: transmuxedData,
        callback: onDone
      });
      dequeue(transmuxer);
    };
    transmuxer.onmessage = handleMessage;
    if (audioAppendStart) {
      transmuxer.postMessage({
        action: 'setAudioAppendStart',
        appendStart: audioAppendStart
      });
    }
    if (Array.isArray(gopsToAlignWith)) {
      transmuxer.postMessage({
        action: 'alignGopsWith',
        gopsToAlignWith: gopsToAlignWith
      });
    }
    if (typeof remux !== 'undefined') {
      transmuxer.postMessage({
        action: 'setRemux',
        remux: remux
      });
    }
    if (bytes.byteLength) {
      var buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;
      var byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;
      transmuxer.postMessage({
        action: 'push',
        data: buffer,
        byteOffset: byteOffset,
        byteLength: bytes.byteLength
      }, [buffer]);
    }
    if (isEndOfTimeline) {
      transmuxer.postMessage({
        action: 'endTimeline'
      });
    }
    transmuxer.postMessage({
      action: 'flush'
    });
  };
  var dequeue = function dequeue(transmuxer) {
    transmuxer.currentTransmux = null;
    if (transmuxer.transmuxQueue.length) {
      transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();
      if (typeof transmuxer.currentTransmux === 'function') {
        transmuxer.currentTransmux();
      } else {
        processTransmux(transmuxer.currentTransmux);
      }
    }
  };
  var processAction = function processAction(transmuxer, action) {
    transmuxer.postMessage({
      action: action
    });
    dequeue(transmuxer);
  };
  var enqueueAction = function enqueueAction(action, transmuxer) {
    if (!transmuxer.currentTransmux) {
      transmuxer.currentTransmux = action;
      processAction(transmuxer, action);
      return;
    }
    transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));
  };
  var reset = function reset(transmuxer) {
    enqueueAction('reset', transmuxer);
  };
  var endTimeline = function endTimeline(transmuxer) {
    enqueueAction('endTimeline', transmuxer);
  };
  var transmux = function transmux(options) {
    if (!options.transmuxer.currentTransmux) {
      options.transmuxer.currentTransmux = options;
      processTransmux(options);
      return;
    }
    options.transmuxer.transmuxQueue.push(options);
  };
  var createTransmuxer = function createTransmuxer(options) {
    var transmuxer = new TransmuxWorker();
    transmuxer.currentTransmux = null;
    transmuxer.transmuxQueue = [];
    var term = transmuxer.terminate;
    transmuxer.terminate = function () {
      transmuxer.currentTransmux = null;
      transmuxer.transmuxQueue.length = 0;
      return term.call(transmuxer);
    };
    transmuxer.postMessage({
      action: 'init',
      options: options
    });
    return transmuxer;
  };
  var segmentTransmuxer = {
    reset: reset,
    endTimeline: endTimeline,
    transmux: transmux,
    createTransmuxer: createTransmuxer
  };
  var workerCallback = function workerCallback(options) {
    var transmuxer = options.transmuxer;
    var endAction = options.endAction || options.action;
    var callback = options.callback;
    var message = _extends_1({}, options, {
      endAction: null,
      transmuxer: null,
      callback: null
    });
    var listenForEndEvent = function listenForEndEvent(event) {
      if (event.data.action !== endAction) {
        return;
      }
      transmuxer.removeEventListener('message', listenForEndEvent);
      if (event.data.data) {
        event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength);
        if (options.data) {
          options.data = event.data.data;
        }
      }
      callback(event.data);
    };
    transmuxer.addEventListener('message', listenForEndEvent);
    if (options.data) {
      var isArrayBuffer = options.data instanceof ArrayBuffer;
      message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;
      message.byteLength = options.data.byteLength;
      var transfers = [isArrayBuffer ? options.data : options.data.buffer];
      transmuxer.postMessage(message, transfers);
    } else {
      transmuxer.postMessage(message);
    }
  };
  var REQUEST_ERRORS = {
    FAILURE: 2,
    TIMEOUT: -101,
    ABORTED: -102
  };
  var abortAll = function abortAll(activeXhrs) {
    activeXhrs.forEach(function (xhr) {
      xhr.abort();
    });
  };
  var getRequestStats = function getRequestStats(request) {
    return {
      bandwidth: request.bandwidth,
      bytesReceived: request.bytesReceived || 0,
      roundTripTime: request.roundTripTime || 0
    };
  };
  var getProgressStats = function getProgressStats(progressEvent) {
    var request = progressEvent.target;
    var roundTripTime = Date.now() - request.requestTime;
    var stats = {
      bandwidth: Infinity,
      bytesReceived: 0,
      roundTripTime: roundTripTime || 0
    };
    stats.bytesReceived = progressEvent.loaded;
    stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1000);
    return stats;
  };
  var handleErrors = function handleErrors(error, request) {
    if (request.timedout) {
      return {
        status: request.status,
        message: 'HLS request timed-out at URL: ' + request.uri,
        code: REQUEST_ERRORS.TIMEOUT,
        xhr: request
      };
    }
    if (request.aborted) {
      return {
        status: request.status,
        message: 'HLS request aborted at URL: ' + request.uri,
        code: REQUEST_ERRORS.ABORTED,
        xhr: request
      };
    }
    if (error) {
      return {
        status: request.status,
        message: 'HLS request errored at URL: ' + request.uri,
        code: REQUEST_ERRORS.FAILURE,
        xhr: request
      };
    }
    if (request.responseType === 'arraybuffer' && request.response.byteLength === 0) {
      return {
        status: request.status,
        message: 'Empty HLS response at URL: ' + request.uri,
        code: REQUEST_ERRORS.FAILURE,
        xhr: request
      };
    }
    return null;
  };
  var handleKeyResponse = function handleKeyResponse(segment, objects, finishProcessingFn) {
    return function (error, request) {
      var response = request.response;
      var errorObj = handleErrors(error, request);
      if (errorObj) {
        return finishProcessingFn(errorObj, segment);
      }
      if (response.byteLength !== 16) {
        return finishProcessingFn({
          status: request.status,
          message: 'Invalid HLS key at URL: ' + request.uri,
          code: REQUEST_ERRORS.FAILURE,
          xhr: request
        }, segment);
      }
      var view = new DataView(response);
      var bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);
      for (var i = 0; i < objects.length; i++) {
        objects[i].bytes = bytes;
      }
      return finishProcessingFn(null, segment);
    };
  };
  var parseInitSegment = function parseInitSegment(segment, _callback) {
    var type = detectContainerForBytes(segment.map.bytes);
    if (type !== 'mp4') {
      var uri = segment.map.resolvedUri || segment.map.uri;
      return _callback({
        internal: true,
        message: "Found unsupported " + (type || 'unknown') + " container for initialization segment at URL: " + uri,
        code: REQUEST_ERRORS.FAILURE
      });
    }
    workerCallback({
      action: 'probeMp4Tracks',
      data: segment.map.bytes,
      transmuxer: segment.transmuxer,
      callback: function callback(_ref) {
        var tracks = _ref.tracks,
            data = _ref.data;
        segment.map.bytes = data;
        tracks.forEach(function (track) {
          segment.map.tracks = segment.map.tracks || {};
          if (segment.map.tracks[track.type]) {
            return;
          }
          segment.map.tracks[track.type] = track;
          if (typeof track.id === 'number' && track.timescale) {
            segment.map.timescales = segment.map.timescales || {};
            segment.map.timescales[track.id] = track.timescale;
          }
        });
        return _callback(null);
      }
    });
  };
  var handleInitSegmentResponse = function handleInitSegmentResponse(_ref2) {
    var segment = _ref2.segment,
        finishProcessingFn = _ref2.finishProcessingFn;
    return function (error, request) {
      var errorObj = handleErrors(error, request);
      if (errorObj) {
        return finishProcessingFn(errorObj, segment);
      }
      var bytes = new Uint8Array(request.response);
      if (segment.map.key) {
        segment.map.encryptedBytes = bytes;
        return finishProcessingFn(null, segment);
      }
      segment.map.bytes = bytes;
      parseInitSegment(segment, function (parseError) {
        if (parseError) {
          parseError.xhr = request;
          parseError.status = request.status;
          return finishProcessingFn(parseError, segment);
        }
        finishProcessingFn(null, segment);
      });
    };
  };
  var handleSegmentResponse = function handleSegmentResponse(_ref3) {
    var segment = _ref3.segment,
        finishProcessingFn = _ref3.finishProcessingFn,
        responseType = _ref3.responseType;
    return function (error, request) {
      var errorObj = handleErrors(error, request);
      if (errorObj) {
        return finishProcessingFn(errorObj, segment);
      }
      var newBytes =
      responseType === 'arraybuffer' || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0));
      segment.stats = getRequestStats(request);
      if (segment.key) {
        segment.encryptedBytes = new Uint8Array(newBytes);
      } else {
        segment.bytes = new Uint8Array(newBytes);
      }
      return finishProcessingFn(null, segment);
    };
  };
  var transmuxAndNotify = function transmuxAndNotify(_ref4) {
    var segment = _ref4.segment,
        bytes = _ref4.bytes,
        trackInfoFn = _ref4.trackInfoFn,
        timingInfoFn = _ref4.timingInfoFn,
        videoSegmentTimingInfoFn = _ref4.videoSegmentTimingInfoFn,
        audioSegmentTimingInfoFn = _ref4.audioSegmentTimingInfoFn,
        id3Fn = _ref4.id3Fn,
        captionsFn = _ref4.captionsFn,
        isEndOfTimeline = _ref4.isEndOfTimeline,
        endedTimelineFn = _ref4.endedTimelineFn,
        dataFn = _ref4.dataFn,
        doneFn = _ref4.doneFn,
        onTransmuxerLog = _ref4.onTransmuxerLog;
    var fmp4Tracks = segment.map && segment.map.tracks || {};
    var isMuxed = Boolean(fmp4Tracks.audio && fmp4Tracks.video);
    var audioStartFn = timingInfoFn.bind(null, segment, 'audio', 'start');
    var audioEndFn = timingInfoFn.bind(null, segment, 'audio', 'end');
    var videoStartFn = timingInfoFn.bind(null, segment, 'video', 'start');
    var videoEndFn = timingInfoFn.bind(null, segment, 'video', 'end');
    var finish = function finish() {
      return transmux({
        bytes: bytes,
        transmuxer: segment.transmuxer,
        audioAppendStart: segment.audioAppendStart,
        gopsToAlignWith: segment.gopsToAlignWith,
        remux: isMuxed,
        onData: function onData(result) {
          result.type = result.type === 'combined' ? 'video' : result.type;
          dataFn(segment, result);
        },
        onTrackInfo: function onTrackInfo(trackInfo) {
          if (trackInfoFn) {
            if (isMuxed) {
              trackInfo.isMuxed = true;
            }
            trackInfoFn(segment, trackInfo);
          }
        },
        onAudioTimingInfo: function onAudioTimingInfo(audioTimingInfo) {
          if (audioStartFn && typeof audioTimingInfo.start !== 'undefined') {
            audioStartFn(audioTimingInfo.start);
            audioStartFn = null;
          }
          if (audioEndFn && typeof audioTimingInfo.end !== 'undefined') {
            audioEndFn(audioTimingInfo.end);
          }
        },
        onVideoTimingInfo: function onVideoTimingInfo(videoTimingInfo) {
          if (videoStartFn && typeof videoTimingInfo.start !== 'undefined') {
            videoStartFn(videoTimingInfo.start);
            videoStartFn = null;
          }
          if (videoEndFn && typeof videoTimingInfo.end !== 'undefined') {
            videoEndFn(videoTimingInfo.end);
          }
        },
        onVideoSegmentTimingInfo: function onVideoSegmentTimingInfo(videoSegmentTimingInfo) {
          videoSegmentTimingInfoFn(videoSegmentTimingInfo);
        },
        onAudioSegmentTimingInfo: function onAudioSegmentTimingInfo(audioSegmentTimingInfo) {
          audioSegmentTimingInfoFn(audioSegmentTimingInfo);
        },
        onId3: function onId3(id3Frames, dispatchType) {
          id3Fn(segment, id3Frames, dispatchType);
        },
        onCaptions: function onCaptions(captions) {
          captionsFn(segment, [captions]);
        },
        isEndOfTimeline: isEndOfTimeline,
        onEndedTimeline: function onEndedTimeline() {
          endedTimelineFn();
        },
        onTransmuxerLog: onTransmuxerLog,
        onDone: function onDone(result) {
          if (!doneFn) {
            return;
          }
          result.type = result.type === 'combined' ? 'video' : result.type;
          doneFn(null, segment, result);
        }
      });
    };
    workerCallback({
      action: 'probeTs',
      transmuxer: segment.transmuxer,
      data: bytes,
      baseStartTime: segment.baseStartTime,
      callback: function callback(data) {
        segment.bytes = bytes = data.data;
        var probeResult = data.result;
        if (probeResult) {
          trackInfoFn(segment, {
            hasAudio: probeResult.hasAudio,
            hasVideo: probeResult.hasVideo,
            isMuxed: isMuxed
          });
          trackInfoFn = null;
          if (probeResult.hasAudio && !isMuxed) {
            audioStartFn(probeResult.audioStart);
          }
          if (probeResult.hasVideo) {
            videoStartFn(probeResult.videoStart);
          }
          audioStartFn = null;
          videoStartFn = null;
        }
        finish();
      }
    });
  };
  var handleSegmentBytes = function handleSegmentBytes(_ref5) {
    var segment = _ref5.segment,
        bytes = _ref5.bytes,
        trackInfoFn = _ref5.trackInfoFn,
        timingInfoFn = _ref5.timingInfoFn,
        videoSegmentTimingInfoFn = _ref5.videoSegmentTimingInfoFn,
        audioSegmentTimingInfoFn = _ref5.audioSegmentTimingInfoFn,
        id3Fn = _ref5.id3Fn,
        captionsFn = _ref5.captionsFn,
        isEndOfTimeline = _ref5.isEndOfTimeline,
        endedTimelineFn = _ref5.endedTimelineFn,
        dataFn = _ref5.dataFn,
        doneFn = _ref5.doneFn,
        onTransmuxerLog = _ref5.onTransmuxerLog;
    var bytesAsUint8Array = new Uint8Array(bytes);
    if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {
      segment.isFmp4 = true;
      var tracks = segment.map.tracks;
      var trackInfo = {
        isFmp4: true,
        hasVideo: !!tracks.video,
        hasAudio: !!tracks.audio
      };
      if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== 'enca') {
        trackInfo.audioCodec = tracks.audio.codec;
      }
      if (tracks.video && tracks.video.codec && tracks.video.codec !== 'encv') {
        trackInfo.videoCodec = tracks.video.codec;
      }
      if (tracks.video && tracks.audio) {
        trackInfo.isMuxed = true;
      }
      trackInfoFn(segment, trackInfo);
      var finishLoading = function finishLoading(captions) {
        dataFn(segment, {
          data: bytesAsUint8Array,
          type: trackInfo.hasAudio && !trackInfo.isMuxed ? 'audio' : 'video'
        });
        if (captions && captions.length) {
          captionsFn(segment, captions);
        }
        doneFn(null, segment, {});
      };
      workerCallback({
        action: 'probeMp4StartTime',
        timescales: segment.map.timescales,
        data: bytesAsUint8Array,
        transmuxer: segment.transmuxer,
        callback: function callback(_ref6) {
          var data = _ref6.data,
              startTime = _ref6.startTime;
          bytes = data.buffer;
          segment.bytes = bytesAsUint8Array = data;
          if (trackInfo.hasAudio && !trackInfo.isMuxed) {
            timingInfoFn(segment, 'audio', 'start', startTime);
          }
          if (trackInfo.hasVideo) {
            timingInfoFn(segment, 'video', 'start', startTime);
          }
          if (!tracks.video || !data.byteLength || !segment.transmuxer) {
            finishLoading();
            return;
          }
          workerCallback({
            action: 'pushMp4Captions',
            endAction: 'mp4Captions',
            transmuxer: segment.transmuxer,
            data: bytesAsUint8Array,
            timescales: segment.map.timescales,
            trackIds: [tracks.video.id],
            callback: function callback(message) {
              bytes = message.data.buffer;
              segment.bytes = bytesAsUint8Array = message.data;
              message.logs.forEach(function (log) {
                onTransmuxerLog(videojs.mergeOptions(log, {
                  stream: 'mp4CaptionParser'
                }));
              });
              finishLoading(message.captions);
            }
          });
        }
      });
      return;
    }
    if (!segment.transmuxer) {
      doneFn(null, segment, {});
      return;
    }
    if (typeof segment.container === 'undefined') {
      segment.container = detectContainerForBytes(bytesAsUint8Array);
    }
    if (segment.container !== 'ts' && segment.container !== 'aac') {
      trackInfoFn(segment, {
        hasAudio: false,
        hasVideo: false
      });
      doneFn(null, segment, {});
      return;
    }
    transmuxAndNotify({
      segment: segment,
      bytes: bytes,
      trackInfoFn: trackInfoFn,
      timingInfoFn: timingInfoFn,
      videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
      audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
      id3Fn: id3Fn,
      captionsFn: captionsFn,
      isEndOfTimeline: isEndOfTimeline,
      endedTimelineFn: endedTimelineFn,
      dataFn: dataFn,
      doneFn: doneFn,
      onTransmuxerLog: onTransmuxerLog
    });
  };
  var decrypt = function decrypt(_ref7, callback) {
    var id = _ref7.id,
        key = _ref7.key,
        encryptedBytes = _ref7.encryptedBytes,
        decryptionWorker = _ref7.decryptionWorker;
    var decryptionHandler = function decryptionHandler(event) {
      if (event.data.source === id) {
        decryptionWorker.removeEventListener('message', decryptionHandler);
        var decrypted = event.data.decrypted;
        callback(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));
      }
    };
    decryptionWorker.addEventListener('message', decryptionHandler);
    var keyBytes;
    if (key.bytes.slice) {
      keyBytes = key.bytes.slice();
    } else {
      keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));
    }
    decryptionWorker.postMessage(createTransferableMessage({
      source: id,
      encrypted: encryptedBytes,
      key: keyBytes,
      iv: key.iv
    }), [encryptedBytes.buffer, keyBytes.buffer]);
  };
  var decryptSegment = function decryptSegment(_ref8) {
    var decryptionWorker = _ref8.decryptionWorker,
        segment = _ref8.segment,
        trackInfoFn = _ref8.trackInfoFn,
        timingInfoFn = _ref8.timingInfoFn,
        videoSegmentTimingInfoFn = _ref8.videoSegmentTimingInfoFn,
        audioSegmentTimingInfoFn = _ref8.audioSegmentTimingInfoFn,
        id3Fn = _ref8.id3Fn,
        captionsFn = _ref8.captionsFn,
        isEndOfTimeline = _ref8.isEndOfTimeline,
        endedTimelineFn = _ref8.endedTimelineFn,
        dataFn = _ref8.dataFn,
        doneFn = _ref8.doneFn,
        onTransmuxerLog = _ref8.onTransmuxerLog;
    decrypt({
      id: segment.requestId,
      key: segment.key,
      encryptedBytes: segment.encryptedBytes,
      decryptionWorker: decryptionWorker
    }, function (decryptedBytes) {
      segment.bytes = decryptedBytes;
      handleSegmentBytes({
        segment: segment,
        bytes: segment.bytes,
        trackInfoFn: trackInfoFn,
        timingInfoFn: timingInfoFn,
        videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
        audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
        id3Fn: id3Fn,
        captionsFn: captionsFn,
        isEndOfTimeline: isEndOfTimeline,
        endedTimelineFn: endedTimelineFn,
        dataFn: dataFn,
        doneFn: doneFn,
        onTransmuxerLog: onTransmuxerLog
      });
    });
  };
  var waitForCompletion = function waitForCompletion(_ref9) {
    var activeXhrs = _ref9.activeXhrs,
        decryptionWorker = _ref9.decryptionWorker,
        trackInfoFn = _ref9.trackInfoFn,
        timingInfoFn = _ref9.timingInfoFn,
        videoSegmentTimingInfoFn = _ref9.videoSegmentTimingInfoFn,
        audioSegmentTimingInfoFn = _ref9.audioSegmentTimingInfoFn,
        id3Fn = _ref9.id3Fn,
        captionsFn = _ref9.captionsFn,
        isEndOfTimeline = _ref9.isEndOfTimeline,
        endedTimelineFn = _ref9.endedTimelineFn,
        dataFn = _ref9.dataFn,
        doneFn = _ref9.doneFn,
        onTransmuxerLog = _ref9.onTransmuxerLog;
    var count = 0;
    var didError = false;
    return function (error, segment) {
      if (didError) {
        return;
      }
      if (error) {
        didError = true;
        abortAll(activeXhrs);
        return doneFn(error, segment);
      }
      count += 1;
      if (count === activeXhrs.length) {
        var segmentFinish = function segmentFinish() {
          if (segment.encryptedBytes) {
            return decryptSegment({
              decryptionWorker: decryptionWorker,
              segment: segment,
              trackInfoFn: trackInfoFn,
              timingInfoFn: timingInfoFn,
              videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
              audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
              id3Fn: id3Fn,
              captionsFn: captionsFn,
              isEndOfTimeline: isEndOfTimeline,
              endedTimelineFn: endedTimelineFn,
              dataFn: dataFn,
              doneFn: doneFn,
              onTransmuxerLog: onTransmuxerLog
            });
          }
          handleSegmentBytes({
            segment: segment,
            bytes: segment.bytes,
            trackInfoFn: trackInfoFn,
            timingInfoFn: timingInfoFn,
            videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
            audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
            id3Fn: id3Fn,
            captionsFn: captionsFn,
            isEndOfTimeline: isEndOfTimeline,
            endedTimelineFn: endedTimelineFn,
            dataFn: dataFn,
            doneFn: doneFn,
            onTransmuxerLog: onTransmuxerLog
          });
        };
        segment.endOfAllRequests = Date.now();
        if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {
          return decrypt({
            decryptionWorker: decryptionWorker,
            id: segment.requestId + '-init',
            encryptedBytes: segment.map.encryptedBytes,
            key: segment.map.key
          }, function (decryptedBytes) {
            segment.map.bytes = decryptedBytes;
            parseInitSegment(segment, function (parseError) {
              if (parseError) {
                abortAll(activeXhrs);
                return doneFn(parseError, segment);
              }
              segmentFinish();
            });
          });
        }
        segmentFinish();
      }
    };
  };
  var handleLoadEnd = function handleLoadEnd(_ref10) {
    var loadendState = _ref10.loadendState,
        abortFn = _ref10.abortFn;
    return function (event) {
      var request = event.target;
      if (request.aborted && abortFn && !loadendState.calledAbortFn) {
        abortFn();
        loadendState.calledAbortFn = true;
      }
    };
  };
  var handleProgress = function handleProgress(_ref11) {
    var segment = _ref11.segment,
        progressFn = _ref11.progressFn;
    _ref11.trackInfoFn;
    _ref11.timingInfoFn;
    _ref11.videoSegmentTimingInfoFn;
    _ref11.audioSegmentTimingInfoFn;
    _ref11.id3Fn;
    _ref11.captionsFn;
    _ref11.isEndOfTimeline;
    _ref11.endedTimelineFn;
    _ref11.dataFn;
    return function (event) {
      var request = event.target;
      if (request.aborted) {
        return;
      }
      segment.stats = videojs.mergeOptions(segment.stats, getProgressStats(event));
      if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {
        segment.stats.firstBytesReceivedAt = Date.now();
      }
      return progressFn(event, segment);
    };
  };
  var mediaSegmentRequest = function mediaSegmentRequest(_ref12) {
    var xhr = _ref12.xhr,
        xhrOptions = _ref12.xhrOptions,
        decryptionWorker = _ref12.decryptionWorker,
        segment = _ref12.segment,
        abortFn = _ref12.abortFn,
        progressFn = _ref12.progressFn,
        trackInfoFn = _ref12.trackInfoFn,
        timingInfoFn = _ref12.timingInfoFn,
        videoSegmentTimingInfoFn = _ref12.videoSegmentTimingInfoFn,
        audioSegmentTimingInfoFn = _ref12.audioSegmentTimingInfoFn,
        id3Fn = _ref12.id3Fn,
        captionsFn = _ref12.captionsFn,
        isEndOfTimeline = _ref12.isEndOfTimeline,
        endedTimelineFn = _ref12.endedTimelineFn,
        dataFn = _ref12.dataFn,
        doneFn = _ref12.doneFn,
        onTransmuxerLog = _ref12.onTransmuxerLog;
    var activeXhrs = [];
    var finishProcessingFn = waitForCompletion({
      activeXhrs: activeXhrs,
      decryptionWorker: decryptionWorker,
      trackInfoFn: trackInfoFn,
      timingInfoFn: timingInfoFn,
      videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
      audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
      id3Fn: id3Fn,
      captionsFn: captionsFn,
      isEndOfTimeline: isEndOfTimeline,
      endedTimelineFn: endedTimelineFn,
      dataFn: dataFn,
      doneFn: doneFn,
      onTransmuxerLog: onTransmuxerLog
    });
    if (segment.key && !segment.key.bytes) {
      var objects = [segment.key];
      if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) {
        objects.push(segment.map.key);
      }
      var keyRequestOptions = videojs.mergeOptions(xhrOptions, {
        uri: segment.key.resolvedUri,
        responseType: 'arraybuffer'
      });
      var keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn);
      var keyXhr = xhr(keyRequestOptions, keyRequestCallback);
      activeXhrs.push(keyXhr);
    }
    if (segment.map && !segment.map.bytes) {
      var differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);
      if (differentMapKey) {
        var mapKeyRequestOptions = videojs.mergeOptions(xhrOptions, {
          uri: segment.map.key.resolvedUri,
          responseType: 'arraybuffer'
        });
        var mapKeyRequestCallback = handleKeyResponse(segment, [segment.map.key], finishProcessingFn);
        var mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);
        activeXhrs.push(mapKeyXhr);
      }
      var initSegmentOptions = videojs.mergeOptions(xhrOptions, {
        uri: segment.map.resolvedUri,
        responseType: 'arraybuffer',
        headers: segmentXhrHeaders(segment.map)
      });
      var initSegmentRequestCallback = handleInitSegmentResponse({
        segment: segment,
        finishProcessingFn: finishProcessingFn
      });
      var initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);
      activeXhrs.push(initSegmentXhr);
    }
    var segmentRequestOptions = videojs.mergeOptions(xhrOptions, {
      uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,
      responseType: 'arraybuffer',
      headers: segmentXhrHeaders(segment)
    });
    var segmentRequestCallback = handleSegmentResponse({
      segment: segment,
      finishProcessingFn: finishProcessingFn,
      responseType: segmentRequestOptions.responseType
    });
    var segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);
    segmentXhr.addEventListener('progress', handleProgress({
      segment: segment,
      progressFn: progressFn,
      trackInfoFn: trackInfoFn,
      timingInfoFn: timingInfoFn,
      videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,
      audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,
      id3Fn: id3Fn,
      captionsFn: captionsFn,
      isEndOfTimeline: isEndOfTimeline,
      endedTimelineFn: endedTimelineFn,
      dataFn: dataFn
    }));
    activeXhrs.push(segmentXhr);
    var loadendState = {};
    activeXhrs.forEach(function (activeXhr) {
      activeXhr.addEventListener('loadend', handleLoadEnd({
        loadendState: loadendState,
        abortFn: abortFn
      }));
    });
    return function () {
      return abortAll(activeXhrs);
    };
  };
  var logFn$1 = logger('CodecUtils');
  var getCodecs = function getCodecs(media) {
    var mediaAttributes = media.attributes || {};
    if (mediaAttributes.CODECS) {
      return parseCodecs(mediaAttributes.CODECS);
    }
  };
  var isMaat = function isMaat(master, media) {
    var mediaAttributes = media.attributes || {};
    return master && master.mediaGroups && master.mediaGroups.AUDIO && mediaAttributes.AUDIO && master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
  };
  var isMuxed = function isMuxed(master, media) {
    if (!isMaat(master, media)) {
      return true;
    }
    var mediaAttributes = media.attributes || {};
    var audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
    for (var groupId in audioGroup) {
      if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {
        return true;
      }
    }
    return false;
  };
  var unwrapCodecList = function unwrapCodecList(codecList) {
    var codecs = {};
    codecList.forEach(function (_ref) {
      var mediaType = _ref.mediaType,
          type = _ref.type,
          details = _ref.details;
      codecs[mediaType] = codecs[mediaType] || [];
      codecs[mediaType].push(translateLegacyCodec("" + type + details));
    });
    Object.keys(codecs).forEach(function (mediaType) {
      if (codecs[mediaType].length > 1) {
        logFn$1("multiple " + mediaType + " codecs found as attributes: " + codecs[mediaType].join(', ') + ". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.");
        codecs[mediaType] = null;
        return;
      }
      codecs[mediaType] = codecs[mediaType][0];
    });
    return codecs;
  };
  var codecCount = function codecCount(codecObj) {
    var count = 0;
    if (codecObj.audio) {
      count++;
    }
    if (codecObj.video) {
      count++;
    }
    return count;
  };
  var codecsForPlaylist = function codecsForPlaylist(master, media) {
    var mediaAttributes = media.attributes || {};
    var codecInfo = unwrapCodecList(getCodecs(media) || []);
    if (isMaat(master, media) && !codecInfo.audio) {
      if (!isMuxed(master, media)) {
        var defaultCodecs = unwrapCodecList(codecsFromDefault(master, mediaAttributes.AUDIO) || []);
        if (defaultCodecs.audio) {
          codecInfo.audio = defaultCodecs.audio;
        }
      }
    }
    return codecInfo;
  };
  var logFn = logger('PlaylistSelector');
  var representationToString = function representationToString(representation) {
    if (!representation || !representation.playlist) {
      return;
    }
    var playlist = representation.playlist;
    return JSON.stringify({
      id: playlist.id,
      bandwidth: representation.bandwidth,
      width: representation.width,
      height: representation.height,
      codecs: playlist.attributes && playlist.attributes.CODECS || ''
    });
  };
  var safeGetComputedStyle = function safeGetComputedStyle(el, property) {
    if (!el) {
      return '';
    }
    var result = window.getComputedStyle(el);
    if (!result) {
      return '';
    }
    return result[property];
  };
  var stableSort = function stableSort(array, sortFn) {
    var newArray = array.slice();
    array.sort(function (left, right) {
      var cmp = sortFn(left, right);
      if (cmp === 0) {
        return newArray.indexOf(left) - newArray.indexOf(right);
      }
      return cmp;
    });
  };
  var comparePlaylistBandwidth = function comparePlaylistBandwidth(left, right) {
    var leftBandwidth;
    var rightBandwidth;
    if (left.attributes.BANDWIDTH) {
      leftBandwidth = left.attributes.BANDWIDTH;
    }
    leftBandwidth = leftBandwidth || window.Number.MAX_VALUE;
    if (right.attributes.BANDWIDTH) {
      rightBandwidth = right.attributes.BANDWIDTH;
    }
    rightBandwidth = rightBandwidth || window.Number.MAX_VALUE;
    return leftBandwidth - rightBandwidth;
  };
  var comparePlaylistResolution = function comparePlaylistResolution(left, right) {
    var leftWidth;
    var rightWidth;
    if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {
      leftWidth = left.attributes.RESOLUTION.width;
    }
    leftWidth = leftWidth || window.Number.MAX_VALUE;
    if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {
      rightWidth = right.attributes.RESOLUTION.width;
    }
    rightWidth = rightWidth || window.Number.MAX_VALUE;
    if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {
      return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;
    }
    return leftWidth - rightWidth;
  };
  var simpleSelector = function simpleSelector(master, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, masterPlaylistController) {
    if (!master) {
      return;
    }
    var options = {
      bandwidth: playerBandwidth,
      width: playerWidth,
      height: playerHeight,
      limitRenditionByPlayerDimensions: limitRenditionByPlayerDimensions
    };
    var playlists = master.playlists;
    if (Playlist.isAudioOnly(master)) {
      playlists = masterPlaylistController.getAudioTrackPlaylists_();
      options.audioOnly = true;
    }
    var sortedPlaylistReps = playlists.map(function (playlist) {
      var bandwidth;
      var width = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;
      var height = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;
      bandwidth = playlist.attributes && playlist.attributes.BANDWIDTH;
      bandwidth = bandwidth || window.Number.MAX_VALUE;
      return {
        bandwidth: bandwidth,
        width: width,
        height: height,
        playlist: playlist
      };
    });
    stableSort(sortedPlaylistReps, function (left, right) {
      return left.bandwidth - right.bandwidth;
    });
    sortedPlaylistReps = sortedPlaylistReps.filter(function (rep) {
      return !Playlist.isIncompatible(rep.playlist);
    });
    var enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {
      return Playlist.isEnabled(rep.playlist);
    });
    if (!enabledPlaylistReps.length) {
      enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {
        return !Playlist.isDisabled(rep.playlist);
      });
    }
    var bandwidthPlaylistReps = enabledPlaylistReps.filter(function (rep) {
      return rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth;
    });
    var highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];
    var bandwidthBestRep = bandwidthPlaylistReps.filter(function (rep) {
      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
    })[0];
    if (limitRenditionByPlayerDimensions === false) {
      var _chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
      if (_chosenRep && _chosenRep.playlist) {
        var type = 'sortedPlaylistReps';
        if (bandwidthBestRep) {
          type = 'bandwidthBestRep';
        }
        if (enabledPlaylistReps[0]) {
          type = 'enabledPlaylistReps';
        }
        logFn("choosing " + representationToString(_chosenRep) + " using " + type + " with options", options);
        return _chosenRep.playlist;
      }
      logFn('could not choose a playlist with options', options);
      return null;
    }
    var haveResolution = bandwidthPlaylistReps.filter(function (rep) {
      return rep.width && rep.height;
    });
    stableSort(haveResolution, function (left, right) {
      return left.width - right.width;
    });
    var resolutionBestRepList = haveResolution.filter(function (rep) {
      return rep.width === playerWidth && rep.height === playerHeight;
    });
    highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];
    var resolutionBestRep = resolutionBestRepList.filter(function (rep) {
      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
    })[0];
    var resolutionPlusOneList;
    var resolutionPlusOneSmallest;
    var resolutionPlusOneRep;
    if (!resolutionBestRep) {
      resolutionPlusOneList = haveResolution.filter(function (rep) {
        return rep.width > playerWidth || rep.height > playerHeight;
      });
      resolutionPlusOneSmallest = resolutionPlusOneList.filter(function (rep) {
        return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;
      });
      highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];
      resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function (rep) {
        return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
      })[0];
    }
    var leastPixelDiffRep;
    if (masterPlaylistController.experimentalLeastPixelDiffSelector) {
      var leastPixelDiffList = haveResolution.map(function (rep) {
        rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);
        return rep;
      });
      stableSort(leastPixelDiffList, function (left, right) {
        if (left.pixelDiff === right.pixelDiff) {
          return right.bandwidth - left.bandwidth;
        }
        return left.pixelDiff - right.pixelDiff;
      });
      leastPixelDiffRep = leastPixelDiffList[0];
    }
    var chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
    if (chosenRep && chosenRep.playlist) {
      var _type = 'sortedPlaylistReps';
      if (leastPixelDiffRep) {
        _type = 'leastPixelDiffRep';
      } else if (resolutionPlusOneRep) {
        _type = 'resolutionPlusOneRep';
      } else if (resolutionBestRep) {
        _type = 'resolutionBestRep';
      } else if (bandwidthBestRep) {
        _type = 'bandwidthBestRep';
      } else if (enabledPlaylistReps[0]) {
        _type = 'enabledPlaylistReps';
      }
      logFn("choosing " + representationToString(chosenRep) + " using " + _type + " with options", options);
      return chosenRep.playlist;
    }
    logFn('could not choose a playlist with options', options);
    return null;
  };
  var lastBandwidthSelector = function lastBandwidthSelector() {
    var pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;
    return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
  };
  var movingAverageBandwidthSelector = function movingAverageBandwidthSelector(decay) {
    var average = -1;
    var lastSystemBandwidth = -1;
    if (decay < 0 || decay > 1) {
      throw new Error('Moving average bandwidth decay must be between 0 and 1.');
    }
    return function () {
      var pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;
      if (average < 0) {
        average = this.systemBandwidth;
        lastSystemBandwidth = this.systemBandwidth;
      }
      if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {
        average = decay * this.systemBandwidth + (1 - decay) * average;
        lastSystemBandwidth = this.systemBandwidth;
      }
      return simpleSelector(this.playlists.master, average, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
    };
  };
  var minRebufferMaxBandwidthSelector = function minRebufferMaxBandwidthSelector(settings) {
    var master = settings.master,
        currentTime = settings.currentTime,
        bandwidth = settings.bandwidth,
        duration = settings.duration,
        segmentDuration = settings.segmentDuration,
        timeUntilRebuffer = settings.timeUntilRebuffer,
        currentTimeline = settings.currentTimeline,
        syncController = settings.syncController;
    var compatiblePlaylists = master.playlists.filter(function (playlist) {
      return !Playlist.isIncompatible(playlist);
    });
    var enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);
    if (!enabledPlaylists.length) {
      enabledPlaylists = compatiblePlaylists.filter(function (playlist) {
        return !Playlist.isDisabled(playlist);
      });
    }
    var bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, 'BANDWIDTH'));
    var rebufferingEstimates = bandwidthPlaylists.map(function (playlist) {
      var syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime);
      var numRequests = syncPoint ? 1 : 2;
      var requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);
      var rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;
      return {
        playlist: playlist,
        rebufferingImpact: rebufferingImpact
      };
    });
    var noRebufferingPlaylists = rebufferingEstimates.filter(function (estimate) {
      return estimate.rebufferingImpact <= 0;
    });
    stableSort(noRebufferingPlaylists, function (a, b) {
      return comparePlaylistBandwidth(b.playlist, a.playlist);
    });
    if (noRebufferingPlaylists.length) {
      return noRebufferingPlaylists[0];
    }
    stableSort(rebufferingEstimates, function (a, b) {
      return a.rebufferingImpact - b.rebufferingImpact;
    });
    return rebufferingEstimates[0] || null;
  };
  var lowestBitrateCompatibleVariantSelector = function lowestBitrateCompatibleVariantSelector() {
    var _this = this;
    var playlists = this.playlists.master.playlists.filter(Playlist.isEnabled);
    stableSort(playlists, function (a, b) {
      return comparePlaylistBandwidth(a, b);
    });
    var playlistsWithVideo = playlists.filter(function (playlist) {
      return !!codecsForPlaylist(_this.playlists.master, playlist).video;
    });
    return playlistsWithVideo[0] || null;
  };
  var concatSegments = function concatSegments(segmentObj) {
    var offset = 0;
    var tempBuffer;
    if (segmentObj.bytes) {
      tempBuffer = new Uint8Array(segmentObj.bytes);
      segmentObj.segments.forEach(function (segment) {
        tempBuffer.set(segment, offset);
        offset += segment.byteLength;
      });
    }
    return tempBuffer;
  };
  var createCaptionsTrackIfNotExists = function createCaptionsTrackIfNotExists(inbandTextTracks, tech, captionStream) {
    if (!inbandTextTracks[captionStream]) {
      tech.trigger({
        type: 'usage',
        name: 'vhs-608'
      });
      tech.trigger({
        type: 'usage',
        name: 'hls-608'
      });
      var instreamId = captionStream;
      if (/^cc708_/.test(captionStream)) {
        instreamId = 'SERVICE' + captionStream.split('_')[1];
      }
      var track = tech.textTracks().getTrackById(instreamId);
      if (track) {
        inbandTextTracks[captionStream] = track;
      } else {
        var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
        var label = captionStream;
        var language = captionStream;
        var def = false;
        var captionService = captionServices[instreamId];
        if (captionService) {
          label = captionService.label;
          language = captionService.language;
          def = captionService["default"];
        }
        inbandTextTracks[captionStream] = tech.addRemoteTextTrack({
          kind: 'captions',
          id: instreamId,
          "default": def,
          label: label,
          language: language
        }, false).track;
      }
    }
  };
  var addCaptionData = function addCaptionData(_ref) {
    var inbandTextTracks = _ref.inbandTextTracks,
        captionArray = _ref.captionArray,
        timestampOffset = _ref.timestampOffset;
    if (!captionArray) {
      return;
    }
    var Cue = window.WebKitDataCue || window.VTTCue;
    captionArray.forEach(function (caption) {
      var track = caption.stream;
      inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));
    });
  };
  var deprecateOldCue = function deprecateOldCue(cue) {
    Object.defineProperties(cue.frame, {
      id: {
        get: function get() {
          videojs.log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');
          return cue.value.key;
        }
      },
      value: {
        get: function get() {
          videojs.log.warn('cue.frame.value is deprecated. Use cue.value.data instead.');
          return cue.value.data;
        }
      },
      privateData: {
        get: function get() {
          videojs.log.warn('cue.frame.privateData is deprecated. Use cue.value.data instead.');
          return cue.value.data;
        }
      }
    });
  };
  var addMetadata = function addMetadata(_ref2) {
    var inbandTextTracks = _ref2.inbandTextTracks,
        metadataArray = _ref2.metadataArray,
        timestampOffset = _ref2.timestampOffset,
        videoDuration = _ref2.videoDuration;
    if (!metadataArray) {
      return;
    }
    var Cue = window.WebKitDataCue || window.VTTCue;
    var metadataTrack = inbandTextTracks.metadataTrack_;
    if (!metadataTrack) {
      return;
    }
    metadataArray.forEach(function (metadata) {
      var time = metadata.cueTime + timestampOffset;
      if (typeof time !== 'number' || window.isNaN(time) || time < 0 || !(time < Infinity)) {
        return;
      }
      metadata.frames.forEach(function (frame) {
        var cue = new Cue(time, time, frame.value || frame.url || frame.data || '');
        cue.frame = frame;
        cue.value = frame;
        deprecateOldCue(cue);
        metadataTrack.addCue(cue);
      });
    });
    if (!metadataTrack.cues || !metadataTrack.cues.length) {
      return;
    }
    var cues = metadataTrack.cues;
    var cuesArray = [];
    for (var i = 0; i < cues.length; i++) {
      if (cues[i]) {
        cuesArray.push(cues[i]);
      }
    }
    var cuesGroupedByStartTime = cuesArray.reduce(function (obj, cue) {
      var timeSlot = obj[cue.startTime] || [];
      timeSlot.push(cue);
      obj[cue.startTime] = timeSlot;
      return obj;
    }, {});
    var sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(function (a, b) {
      return Number(a) - Number(b);
    });
    sortedStartTimes.forEach(function (startTime, idx) {
      var cueGroup = cuesGroupedByStartTime[startTime];
      var nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration;
      cueGroup.forEach(function (cue) {
        cue.endTime = nextTime;
      });
    });
  };
  var createMetadataTrackIfNotExists = function createMetadataTrackIfNotExists(inbandTextTracks, dispatchType, tech) {
    if (inbandTextTracks.metadataTrack_) {
      return;
    }
    inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({
      kind: 'metadata',
      label: 'Timed Metadata'
    }, false).track;
    inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;
  };
  var removeCuesFromTrack = function removeCuesFromTrack(start, end, track) {
    var i;
    var cue;
    if (!track) {
      return;
    }
    if (!track.cues) {
      return;
    }
    i = track.cues.length;
    while (i--) {
      cue = track.cues[i];
      if (cue.startTime >= start && cue.endTime <= end) {
        track.removeCue(cue);
      }
    }
  };
  var removeDuplicateCuesFromTrack = function removeDuplicateCuesFromTrack(track) {
    var cues = track.cues;
    if (!cues) {
      return;
    }
    for (var i = 0; i < cues.length; i++) {
      var duplicates = [];
      var occurrences = 0;
      for (var j = 0; j < cues.length; j++) {
        if (cues[i].startTime === cues[j].startTime && cues[i].endTime === cues[j].endTime && cues[i].text === cues[j].text) {
          occurrences++;
          if (occurrences > 1) {
            duplicates.push(cues[j]);
          }
        }
      }
      if (duplicates.length) {
        duplicates.forEach(function (dupe) {
          return track.removeCue(dupe);
        });
      }
    }
  };
  var gopsSafeToAlignWith = function gopsSafeToAlignWith(buffer, currentTime, mapping) {
    if (typeof currentTime === 'undefined' || currentTime === null || !buffer.length) {
      return [];
    }
    var currentTimePts = Math.ceil((currentTime - mapping + 3) * clock_1);
    var i;
    for (i = 0; i < buffer.length; i++) {
      if (buffer[i].pts > currentTimePts) {
        break;
      }
    }
    return buffer.slice(i);
  };
  var updateGopBuffer = function updateGopBuffer(buffer, gops, replace) {
    if (!gops.length) {
      return buffer;
    }
    if (replace) {
      return gops.slice();
    }
    var start = gops[0].pts;
    var i = 0;
    for (i; i < buffer.length; i++) {
      if (buffer[i].pts >= start) {
        break;
      }
    }
    return buffer.slice(0, i).concat(gops);
  };
  var removeGopBuffer = function removeGopBuffer(buffer, start, end, mapping) {
    var startPts = Math.ceil((start - mapping) * clock_1);
    var endPts = Math.ceil((end - mapping) * clock_1);
    var updatedBuffer = buffer.slice();
    var i = buffer.length;
    while (i--) {
      if (buffer[i].pts <= endPts) {
        break;
      }
    }
    if (i === -1) {
      return updatedBuffer;
    }
    var j = i + 1;
    while (j--) {
      if (buffer[j].pts <= startPts) {
        break;
      }
    }
    j = Math.max(j, 0);
    updatedBuffer.splice(j, i - j + 1);
    return updatedBuffer;
  };
  var shallowEqual = function shallowEqual(a, b) {
    if (!a && !b || !a && b || a && !b) {
      return false;
    }
    if (a === b) {
      return true;
    }
    var akeys = Object.keys(a).sort();
    var bkeys = Object.keys(b).sort();
    if (akeys.length !== bkeys.length) {
      return false;
    }
    for (var i = 0; i < akeys.length; i++) {
      var key = akeys[i];
      if (key !== bkeys[i]) {
        return false;
      }
      if (a[key] !== b[key]) {
        return false;
      }
    }
    return true;
  };
  var QUOTA_EXCEEDED_ERR = 22;
  var getSyncSegmentCandidate = function getSyncSegmentCandidate(currentTimeline, segments, targetTime) {
    segments = segments || [];
    var timelineSegments = [];
    var time = 0;
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      if (currentTimeline === segment.timeline) {
        timelineSegments.push(i);
        time += segment.duration;
        if (time > targetTime) {
          return i;
        }
      }
    }
    if (timelineSegments.length === 0) {
      return 0;
    }
    return timelineSegments[timelineSegments.length - 1];
  };
  var MIN_BACK_BUFFER = 1;
  var CHECK_BUFFER_DELAY = 500;
  var finite = function finite(num) {
    return typeof num === 'number' && isFinite(num);
  };
  var MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;
  var illegalMediaSwitch = function illegalMediaSwitch(loaderType, startingMedia, trackInfo) {
    if (loaderType !== 'main' || !startingMedia || !trackInfo) {
      return null;
    }
    if (!trackInfo.hasAudio && !trackInfo.hasVideo) {
      return 'Neither audio nor video found in segment.';
    }
    if (startingMedia.hasVideo && !trackInfo.hasVideo) {
      return 'Only audio found in segment when we expected video.' + ' We can\'t switch to audio only from a stream that had video.' + ' To get rid of this message, please add codec information to the manifest.';
    }
    if (!startingMedia.hasVideo && trackInfo.hasVideo) {
      return 'Video found in segment when we expected only audio.' + ' We can\'t switch to a stream with video from an audio only stream.' + ' To get rid of this message, please add codec information to the manifest.';
    }
    return null;
  };
  var safeBackBufferTrimTime = function safeBackBufferTrimTime(seekable, currentTime, targetDuration) {
    var trimTime = currentTime - Config.BACK_BUFFER_LENGTH;
    if (seekable.length) {
      trimTime = Math.max(trimTime, seekable.start(0));
    }
    var maxTrimTime = currentTime - targetDuration;
    return Math.min(maxTrimTime, trimTime);
  };
  var segmentInfoString = function segmentInfoString(segmentInfo) {
    var startOfSegment = segmentInfo.startOfSegment,
        duration = segmentInfo.duration,
        segment = segmentInfo.segment,
        part = segmentInfo.part,
        _segmentInfo$playlist = segmentInfo.playlist,
        seq = _segmentInfo$playlist.mediaSequence,
        id = _segmentInfo$playlist.id,
        _segmentInfo$playlist2 = _segmentInfo$playlist.segments,
        segments = _segmentInfo$playlist2 === void 0 ? [] : _segmentInfo$playlist2,
        index = segmentInfo.mediaIndex,
        partIndex = segmentInfo.partIndex,
        timeline = segmentInfo.timeline;
    var segmentLen = segments.length - 1;
    var selection = 'mediaIndex/partIndex increment';
    if (segmentInfo.getMediaInfoForTime) {
      selection = "getMediaInfoForTime (" + segmentInfo.getMediaInfoForTime + ")";
    } else if (segmentInfo.isSyncRequest) {
      selection = 'getSyncSegmentCandidate (isSyncRequest)';
    }
    if (segmentInfo.independent) {
      selection += " with independent " + segmentInfo.independent;
    }
    var hasPartIndex = typeof partIndex === 'number';
    var name = segmentInfo.segment.uri ? 'segment' : 'pre-segment';
    var zeroBasedPartCount = hasPartIndex ? getKnownPartCount({
      preloadSegment: segment
    }) - 1 : 0;
    return name + " [" + (seq + index) + "/" + (seq + segmentLen) + "]" + (hasPartIndex ? " part [" + partIndex + "/" + zeroBasedPartCount + "]" : '') + (" segment start/end [" + segment.start + " => " + segment.end + "]") + (hasPartIndex ? " part start/end [" + part.start + " => " + part.end + "]" : '') + (" startOfSegment [" + startOfSegment + "]") + (" duration [" + duration + "]") + (" timeline [" + timeline + "]") + (" selected by [" + selection + "]") + (" playlist [" + id + "]");
  };
  var timingInfoPropertyForMedia = function timingInfoPropertyForMedia(mediaType) {
    return mediaType + "TimingInfo";
  };
  var timestampOffsetForSegment = function timestampOffsetForSegment(_ref) {
    var segmentTimeline = _ref.segmentTimeline,
        currentTimeline = _ref.currentTimeline,
        startOfSegment = _ref.startOfSegment,
        buffered = _ref.buffered,
        overrideCheck = _ref.overrideCheck;
    if (!overrideCheck && segmentTimeline === currentTimeline) {
      return null;
    }
    if (segmentTimeline < currentTimeline) {
      return startOfSegment;
    }
    return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;
  };
  var shouldWaitForTimelineChange = function shouldWaitForTimelineChange(_ref2) {
    var timelineChangeController = _ref2.timelineChangeController,
        currentTimeline = _ref2.currentTimeline,
        segmentTimeline = _ref2.segmentTimeline,
        loaderType = _ref2.loaderType,
        audioDisabled = _ref2.audioDisabled;
    if (currentTimeline === segmentTimeline) {
      return false;
    }
    if (loaderType === 'audio') {
      var lastMainTimelineChange = timelineChangeController.lastTimelineChange({
        type: 'main'
      });
      return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;
    }
    if (loaderType === 'main' && audioDisabled) {
      var pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
        type: 'audio'
      });
      if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {
        return false;
      }
      return true;
    }
    return false;
  };
  var mediaDuration = function mediaDuration(timingInfos) {
    var maxDuration = 0;
    ['video', 'audio'].forEach(function (type) {
      var typeTimingInfo = timingInfos[type + "TimingInfo"];
      if (!typeTimingInfo) {
        return;
      }
      var start = typeTimingInfo.start,
          end = typeTimingInfo.end;
      var duration;
      if (typeof start === 'bigint' || typeof end === 'bigint') {
        duration = window.BigInt(end) - window.BigInt(start);
      } else if (typeof start === 'number' && typeof end === 'number') {
        duration = end - start;
      }
      if (typeof duration !== 'undefined' && duration > maxDuration) {
        maxDuration = duration;
      }
    });
    if (typeof maxDuration === 'bigint' && maxDuration < Number.MAX_SAFE_INTEGER) {
      maxDuration = Number(maxDuration);
    }
    return maxDuration;
  };
  var segmentTooLong = function segmentTooLong(_ref3) {
    var segmentDuration = _ref3.segmentDuration,
        maxDuration = _ref3.maxDuration;
    if (!segmentDuration) {
      return false;
    }
    return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;
  };
  var getTroublesomeSegmentDurationMessage = function getTroublesomeSegmentDurationMessage(segmentInfo, sourceType) {
    if (sourceType !== 'hls') {
      return null;
    }
    var segmentDuration = mediaDuration({
      audioTimingInfo: segmentInfo.audioTimingInfo,
      videoTimingInfo: segmentInfo.videoTimingInfo
    });
    if (!segmentDuration) {
      return null;
    }
    var targetDuration = segmentInfo.playlist.targetDuration;
    var isSegmentWayTooLong = segmentTooLong({
      segmentDuration: segmentDuration,
      maxDuration: targetDuration * 2
    });
    var isSegmentSlightlyTooLong = segmentTooLong({
      segmentDuration: segmentDuration,
      maxDuration: targetDuration
    });
    var segmentTooLongMessage = "Segment with index " + segmentInfo.mediaIndex + " " + ("from playlist " + segmentInfo.playlist.id + " ") + ("has a duration of " + segmentDuration + " ") + ("when the reported duration is " + segmentInfo.duration + " ") + ("and the target duration is " + targetDuration + ". ") + 'For HLS content, a duration in excess of the target duration may result in ' + 'playback issues. See the HLS specification section on EXT-X-TARGETDURATION for ' + 'more details: ' + 'https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1';
    if (isSegmentWayTooLong || isSegmentSlightlyTooLong) {
      return {
        severity: isSegmentWayTooLong ? 'warn' : 'info',
        message: segmentTooLongMessage
      };
    }
    return null;
  };
  var SegmentLoader = function (_videojs$EventTarget) {
    inheritsLoose(SegmentLoader, _videojs$EventTarget);
    function SegmentLoader(settings, options) {
      var _this;
      _this = _videojs$EventTarget.call(this) || this;
      if (!settings) {
        throw new TypeError('Initialization settings are required');
      }
      if (typeof settings.currentTime !== 'function') {
        throw new TypeError('No currentTime getter specified');
      }
      if (!settings.mediaSource) {
        throw new TypeError('No MediaSource specified');
      }
      _this.bandwidth = settings.bandwidth;
      _this.throughput = {
        rate: 0,
        count: 0
      };
      _this.roundTrip = NaN;
      _this.resetStats_();
      _this.mediaIndex = null;
      _this.partIndex = null;
      _this.hasPlayed_ = settings.hasPlayed;
      _this.currentTime_ = settings.currentTime;
      _this.seekable_ = settings.seekable;
      _this.seeking_ = settings.seeking;
      _this.duration_ = settings.duration;
      _this.mediaSource_ = settings.mediaSource;
      _this.vhs_ = settings.vhs;
      _this.loaderType_ = settings.loaderType;
      _this.currentMediaInfo_ = void 0;
      _this.startingMediaInfo_ = void 0;
      _this.segmentMetadataTrack_ = settings.segmentMetadataTrack;
      _this.goalBufferLength_ = settings.goalBufferLength;
      _this.sourceType_ = settings.sourceType;
      _this.sourceUpdater_ = settings.sourceUpdater;
      _this.inbandTextTracks_ = settings.inbandTextTracks;
      _this.state_ = 'INIT';
      _this.timelineChangeController_ = settings.timelineChangeController;
      _this.shouldSaveSegmentTimingInfo_ = true;
      _this.parse708captions_ = settings.parse708captions;
      _this.captionServices_ = settings.captionServices;
      _this.experimentalExactManifestTimings = settings.experimentalExactManifestTimings;
      _this.checkBufferTimeout_ = null;
      _this.error_ = void 0;
      _this.currentTimeline_ = -1;
      _this.pendingSegment_ = null;
      _this.xhrOptions_ = null;
      _this.pendingSegments_ = [];
      _this.audioDisabled_ = false;
      _this.isPendingTimestampOffset_ = false;
      _this.gopBuffer_ = [];
      _this.timeMapping_ = 0;
      _this.safeAppend_ = videojs.browser.IE_VERSION >= 11;
      _this.appendInitSegment_ = {
        audio: true,
        video: true
      };
      _this.playlistOfLastInitSegment_ = {
        audio: null,
        video: null
      };
      _this.callQueue_ = [];
      _this.loadQueue_ = [];
      _this.metadataQueue_ = {
        id3: [],
        caption: []
      };
      _this.waitingOnRemove_ = false;
      _this.quotaExceededErrorRetryTimeout_ = null;
      _this.activeInitSegmentId_ = null;
      _this.initSegments_ = {};
      _this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;
      _this.keyCache_ = {};
      _this.decrypter_ = settings.decrypter;
      _this.syncController_ = settings.syncController;
      _this.syncPoint_ = {
        segmentIndex: 0,
        time: 0
      };
      _this.transmuxer_ = _this.createTransmuxer_();
      _this.triggerSyncInfoUpdate_ = function () {
        return _this.trigger('syncinfoupdate');
      };
      _this.syncController_.on('syncinfoupdate', _this.triggerSyncInfoUpdate_);
      _this.mediaSource_.addEventListener('sourceopen', function () {
        if (!_this.isEndOfStream_()) {
          _this.ended_ = false;
        }
      });
      _this.fetchAtBuffer_ = false;
      _this.logger_ = logger("SegmentLoader[" + _this.loaderType_ + "]");
      Object.defineProperty(assertThisInitialized(_this), 'state', {
        get: function get() {
          return this.state_;
        },
        set: function set(newState) {
          if (newState !== this.state_) {
            this.logger_(this.state_ + " -> " + newState);
            this.state_ = newState;
            this.trigger('statechange');
          }
        }
      });
      _this.sourceUpdater_.on('ready', function () {
        if (_this.hasEnoughInfoToAppend_()) {
          _this.processCallQueue_();
        }
      });
      if (_this.loaderType_ === 'main') {
        _this.timelineChangeController_.on('pendingtimelinechange', function () {
          if (_this.hasEnoughInfoToAppend_()) {
            _this.processCallQueue_();
          }
        });
      }
      if (_this.loaderType_ === 'audio') {
        _this.timelineChangeController_.on('timelinechange', function () {
          if (_this.hasEnoughInfoToLoad_()) {
            _this.processLoadQueue_();
          }
          if (_this.hasEnoughInfoToAppend_()) {
            _this.processCallQueue_();
          }
        });
      }
      return _this;
    }
    var _proto = SegmentLoader.prototype;
    _proto.createTransmuxer_ = function createTransmuxer_() {
      return segmentTransmuxer.createTransmuxer({
        remux: false,
        alignGopsAtEnd: this.safeAppend_,
        keepOriginalTimestamps: true,
        parse708captions: this.parse708captions_,
        captionServices: this.captionServices_
      });
    }
    ;
    _proto.resetStats_ = function resetStats_() {
      this.mediaBytesTransferred = 0;
      this.mediaRequests = 0;
      this.mediaRequestsAborted = 0;
      this.mediaRequestsTimedout = 0;
      this.mediaRequestsErrored = 0;
      this.mediaTransferDuration = 0;
      this.mediaSecondsLoaded = 0;
      this.mediaAppends = 0;
    }
    ;
    _proto.dispose = function dispose() {
      this.trigger('dispose');
      this.state = 'DISPOSED';
      this.pause();
      this.abort_();
      if (this.transmuxer_) {
        this.transmuxer_.terminate();
      }
      this.resetStats_();
      if (this.checkBufferTimeout_) {
        window.clearTimeout(this.checkBufferTimeout_);
      }
      if (this.syncController_ && this.triggerSyncInfoUpdate_) {
        this.syncController_.off('syncinfoupdate', this.triggerSyncInfoUpdate_);
      }
      this.off();
    };
    _proto.setAudio = function setAudio(enable) {
      this.audioDisabled_ = !enable;
      if (enable) {
        this.appendInitSegment_.audio = true;
      } else {
        this.sourceUpdater_.removeAudio(0, this.duration_());
      }
    }
    ;
    _proto.abort = function abort() {
      if (this.state !== 'WAITING') {
        if (this.pendingSegment_) {
          this.pendingSegment_ = null;
        }
        return;
      }
      this.abort_();
      this.state = 'READY';
      if (!this.paused()) {
        this.monitorBuffer_();
      }
    }
    ;
    _proto.abort_ = function abort_() {
      if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {
        this.pendingSegment_.abortRequests();
      }
      this.pendingSegment_ = null;
      this.callQueue_ = [];
      this.loadQueue_ = [];
      this.metadataQueue_.id3 = [];
      this.metadataQueue_.caption = [];
      this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
      this.waitingOnRemove_ = false;
      window.clearTimeout(this.quotaExceededErrorRetryTimeout_);
      this.quotaExceededErrorRetryTimeout_ = null;
    };
    _proto.checkForAbort_ = function checkForAbort_(requestId) {
      if (this.state === 'APPENDING' && !this.pendingSegment_) {
        this.state = 'READY';
        return true;
      }
      if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {
        return true;
      }
      return false;
    }
    ;
    _proto.error = function error(_error) {
      if (typeof _error !== 'undefined') {
        this.logger_('error occurred:', _error);
        this.error_ = _error;
      }
      this.pendingSegment_ = null;
      return this.error_;
    };
    _proto.endOfStream = function endOfStream() {
      this.ended_ = true;
      if (this.transmuxer_) {
        segmentTransmuxer.reset(this.transmuxer_);
      }
      this.gopBuffer_.length = 0;
      this.pause();
      this.trigger('ended');
    }
    ;
    _proto.buffered_ = function buffered_() {
      var trackInfo = this.getMediaInfo_();
      if (!this.sourceUpdater_ || !trackInfo) {
        return videojs.createTimeRanges();
      }
      if (this.loaderType_ === 'main') {
        var hasAudio = trackInfo.hasAudio,
            hasVideo = trackInfo.hasVideo,
            isMuxed = trackInfo.isMuxed;
        if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed) {
          return this.sourceUpdater_.buffered();
        }
        if (hasVideo) {
          return this.sourceUpdater_.videoBuffered();
        }
      }
      return this.sourceUpdater_.audioBuffered();
    }
    ;
    _proto.initSegmentForMap = function initSegmentForMap(map, set) {
      if (set === void 0) {
        set = false;
      }
      if (!map) {
        return null;
      }
      var id = initSegmentId(map);
      var storedMap = this.initSegments_[id];
      if (set && !storedMap && map.bytes) {
        this.initSegments_[id] = storedMap = {
          resolvedUri: map.resolvedUri,
          byterange: map.byterange,
          bytes: map.bytes,
          tracks: map.tracks,
          timescales: map.timescales
        };
      }
      return storedMap || map;
    }
    ;
    _proto.segmentKey = function segmentKey(key, set) {
      if (set === void 0) {
        set = false;
      }
      if (!key) {
        return null;
      }
      var id = segmentKeyId(key);
      var storedKey = this.keyCache_[id];
      if (this.cacheEncryptionKeys_ && set && !storedKey && key.bytes) {
        this.keyCache_[id] = storedKey = {
          resolvedUri: key.resolvedUri,
          bytes: key.bytes
        };
      }
      var result = {
        resolvedUri: (storedKey || key).resolvedUri
      };
      if (storedKey) {
        result.bytes = storedKey.bytes;
      }
      return result;
    }
    ;
    _proto.couldBeginLoading_ = function couldBeginLoading_() {
      return this.playlist_ && !this.paused();
    }
    ;
    _proto.load = function load() {
      this.monitorBuffer_();
      if (!this.playlist_) {
        return;
      }
      if (this.state === 'INIT' && this.couldBeginLoading_()) {
        return this.init_();
      }
      if (!this.couldBeginLoading_() || this.state !== 'READY' && this.state !== 'INIT') {
        return;
      }
      this.state = 'READY';
    }
    ;
    _proto.init_ = function init_() {
      this.state = 'READY';
      this.resetEverything();
      return this.monitorBuffer_();
    }
    ;
    _proto.playlist = function playlist(newPlaylist, options) {
      if (options === void 0) {
        options = {};
      }
      if (!newPlaylist) {
        return;
      }
      var oldPlaylist = this.playlist_;
      var segmentInfo = this.pendingSegment_;
      this.playlist_ = newPlaylist;
      this.xhrOptions_ = options;
      if (this.state === 'INIT') {
        newPlaylist.syncInfo = {
          mediaSequence: newPlaylist.mediaSequence,
          time: 0
        };
        if (this.loaderType_ === 'main') {
          this.syncController_.setDateTimeMappingForStart(newPlaylist);
        }
      }
      var oldId = null;
      if (oldPlaylist) {
        if (oldPlaylist.id) {
          oldId = oldPlaylist.id;
        } else if (oldPlaylist.uri) {
          oldId = oldPlaylist.uri;
        }
      }
      this.logger_("playlist update [" + oldId + " => " + (newPlaylist.id || newPlaylist.uri) + "]");
      this.trigger('syncinfoupdate');
      if (this.state === 'INIT' && this.couldBeginLoading_()) {
        return this.init_();
      }
      if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {
        if (this.mediaIndex !== null) {
          if (!newPlaylist.endList) {
            this.resetLoader();
          } else {
            this.resyncLoader();
          }
        }
        this.currentMediaInfo_ = void 0;
        this.trigger('playlistupdate');
        return;
      }
      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
      this.logger_("live window shift [" + mediaSequenceDiff + "]");
      if (this.mediaIndex !== null) {
        this.mediaIndex -= mediaSequenceDiff;
        if (this.mediaIndex < 0) {
          this.mediaIndex = null;
          this.partIndex = null;
        } else {
          var segment = this.playlist_.segments[this.mediaIndex];
          if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {
            var mediaIndex = this.mediaIndex;
            this.logger_("currently processing part (index " + this.partIndex + ") no longer exists.");
            this.resetLoader();
            this.mediaIndex = mediaIndex;
          }
        }
      }
      if (segmentInfo) {
        segmentInfo.mediaIndex -= mediaSequenceDiff;
        if (segmentInfo.mediaIndex < 0) {
          segmentInfo.mediaIndex = null;
          segmentInfo.partIndex = null;
        } else {
          if (segmentInfo.mediaIndex >= 0) {
            segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];
          }
          if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) {
            segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];
          }
        }
      }
      this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);
    }
    ;
    _proto.pause = function pause() {
      if (this.checkBufferTimeout_) {
        window.clearTimeout(this.checkBufferTimeout_);
        this.checkBufferTimeout_ = null;
      }
    }
    ;
    _proto.paused = function paused() {
      return this.checkBufferTimeout_ === null;
    }
    ;
    _proto.resetEverything = function resetEverything(done) {
      this.ended_ = false;
      this.appendInitSegment_ = {
        audio: true,
        video: true
      };
      this.resetLoader();
      this.remove(0, Infinity, done);
      if (this.transmuxer_) {
        this.transmuxer_.postMessage({
          action: 'clearAllMp4Captions'
        });
        this.transmuxer_.postMessage({
          action: 'reset'
        });
      }
    }
    ;
    _proto.resetLoader = function resetLoader() {
      this.fetchAtBuffer_ = false;
      this.resyncLoader();
    }
    ;
    _proto.resyncLoader = function resyncLoader() {
      if (this.transmuxer_) {
        segmentTransmuxer.reset(this.transmuxer_);
      }
      this.mediaIndex = null;
      this.partIndex = null;
      this.syncPoint_ = null;
      this.isPendingTimestampOffset_ = false;
      this.callQueue_ = [];
      this.loadQueue_ = [];
      this.metadataQueue_.id3 = [];
      this.metadataQueue_.caption = [];
      this.abort();
      if (this.transmuxer_) {
        this.transmuxer_.postMessage({
          action: 'clearParsedMp4Captions'
        });
      }
    }
    ;
    _proto.remove = function remove(start, end, done, force) {
      if (done === void 0) {
        done = function done() {};
      }
      if (force === void 0) {
        force = false;
      }
      if (end === Infinity) {
        end = this.duration_();
      }
      if (end <= start) {
        this.logger_('skipping remove because end ${end} is <= start ${start}');
        return;
      }
      if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
        this.logger_('skipping remove because no source updater or starting media info');
        return;
      }
      var removesRemaining = 1;
      var removeFinished = function removeFinished() {
        removesRemaining--;
        if (removesRemaining === 0) {
          done();
        }
      };
      if (force || !this.audioDisabled_) {
        removesRemaining++;
        this.sourceUpdater_.removeAudio(start, end, removeFinished);
      }
      if (force || this.loaderType_ === 'main') {
        this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);
        removesRemaining++;
        this.sourceUpdater_.removeVideo(start, end, removeFinished);
      }
      for (var track in this.inbandTextTracks_) {
        removeCuesFromTrack(start, end, this.inbandTextTracks_[track]);
      }
      removeCuesFromTrack(start, end, this.segmentMetadataTrack_);
      removeFinished();
    }
    ;
    _proto.monitorBuffer_ = function monitorBuffer_() {
      if (this.checkBufferTimeout_) {
        window.clearTimeout(this.checkBufferTimeout_);
      }
      this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 1);
    }
    ;
    _proto.monitorBufferTick_ = function monitorBufferTick_() {
      if (this.state === 'READY') {
        this.fillBuffer_();
      }
      if (this.checkBufferTimeout_) {
        window.clearTimeout(this.checkBufferTimeout_);
      }
      this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);
    }
    ;
    _proto.fillBuffer_ = function fillBuffer_() {
      if (this.sourceUpdater_.updating()) {
        return;
      }
      var segmentInfo = this.chooseNextRequest_();
      if (!segmentInfo) {
        return;
      }
      if (typeof segmentInfo.timestampOffset === 'number') {
        this.isPendingTimestampOffset_ = false;
        this.timelineChangeController_.pendingTimelineChange({
          type: this.loaderType_,
          from: this.currentTimeline_,
          to: segmentInfo.timeline
        });
      }
      this.loadSegment_(segmentInfo);
    }
    ;
    _proto.isEndOfStream_ = function isEndOfStream_(mediaIndex, playlist, partIndex) {
      if (mediaIndex === void 0) {
        mediaIndex = this.mediaIndex;
      }
      if (playlist === void 0) {
        playlist = this.playlist_;
      }
      if (partIndex === void 0) {
        partIndex = this.partIndex;
      }
      if (!playlist || !this.mediaSource_) {
        return false;
      }
      var segment = typeof mediaIndex === 'number' && playlist.segments[mediaIndex];
      var appendedLastSegment = mediaIndex + 1 === playlist.segments.length;
      var appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length;
      return playlist.endList && this.mediaSource_.readyState === 'open' && appendedLastSegment && appendedLastPart;
    }
    ;
    _proto.chooseNextRequest_ = function chooseNextRequest_() {
      var buffered = this.buffered_();
      var bufferedEnd = lastBufferedEnd(buffered) || 0;
      var bufferedTime = timeAheadOf(buffered, this.currentTime_());
      var preloaded = !this.hasPlayed_() && bufferedTime >= 1;
      var haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();
      var segments = this.playlist_.segments;
      if (!segments.length || preloaded || haveEnoughBuffer) {
        return null;
      }
      this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());
      var next = {
        partIndex: null,
        mediaIndex: null,
        startOfSegment: null,
        playlist: this.playlist_,
        isSyncRequest: Boolean(!this.syncPoint_)
      };
      if (next.isSyncRequest) {
        next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);
      } else if (this.mediaIndex !== null) {
        var segment = segments[this.mediaIndex];
        var partIndex = typeof this.partIndex === 'number' ? this.partIndex : -1;
        next.startOfSegment = segment.end ? segment.end : bufferedEnd;
        if (segment.parts && segment.parts[partIndex + 1]) {
          next.mediaIndex = this.mediaIndex;
          next.partIndex = partIndex + 1;
        } else {
          next.mediaIndex = this.mediaIndex + 1;
        }
      } else {
        var _Playlist$getMediaInf = Playlist.getMediaInfoForTime({
          experimentalExactManifestTimings: this.experimentalExactManifestTimings,
          playlist: this.playlist_,
          currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),
          startingPartIndex: this.syncPoint_.partIndex,
          startingSegmentIndex: this.syncPoint_.segmentIndex,
          startTime: this.syncPoint_.time
        }),
            segmentIndex = _Playlist$getMediaInf.segmentIndex,
            startTime = _Playlist$getMediaInf.startTime,
            _partIndex = _Playlist$getMediaInf.partIndex;
        next.getMediaInfoForTime = this.fetchAtBuffer_ ? "bufferedEnd " + bufferedEnd : "currentTime " + this.currentTime_();
        next.mediaIndex = segmentIndex;
        next.startOfSegment = startTime;
        next.partIndex = _partIndex;
      }
      var nextSegment = segments[next.mediaIndex];
      var nextPart = nextSegment && typeof next.partIndex === 'number' && nextSegment.parts && nextSegment.parts[next.partIndex];
      if (!nextSegment || typeof next.partIndex === 'number' && !nextPart) {
        return null;
      }
      if (typeof next.partIndex !== 'number' && nextSegment.parts) {
        next.partIndex = 0;
        nextPart = nextSegment.parts[0];
      }
      if (!bufferedTime && nextPart && !nextPart.independent) {
        if (next.partIndex === 0) {
          var lastSegment = segments[next.mediaIndex - 1];
          var lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];
          if (lastSegmentLastPart && lastSegmentLastPart.independent) {
            next.mediaIndex -= 1;
            next.partIndex = lastSegment.parts.length - 1;
            next.independent = 'previous segment';
          }
        } else if (nextSegment.parts[next.partIndex - 1].independent) {
          next.partIndex -= 1;
          next.independent = 'previous part';
        }
      }
      var ended = this.mediaSource_ && this.mediaSource_.readyState === 'ended';
      if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) {
        return null;
      }
      return this.generateSegmentInfo_(next);
    };
    _proto.generateSegmentInfo_ = function generateSegmentInfo_(options) {
      var independent = options.independent,
          playlist = options.playlist,
          mediaIndex = options.mediaIndex,
          startOfSegment = options.startOfSegment,
          isSyncRequest = options.isSyncRequest,
          partIndex = options.partIndex,
          forceTimestampOffset = options.forceTimestampOffset,
          getMediaInfoForTime = options.getMediaInfoForTime;
      var segment = playlist.segments[mediaIndex];
      var part = typeof partIndex === 'number' && segment.parts[partIndex];
      var segmentInfo = {
        requestId: 'segment-loader-' + Math.random(),
        uri: part && part.resolvedUri || segment.resolvedUri,
        mediaIndex: mediaIndex,
        partIndex: part ? partIndex : null,
        isSyncRequest: isSyncRequest,
        startOfSegment: startOfSegment,
        playlist: playlist,
        bytes: null,
        encryptedBytes: null,
        timestampOffset: null,
        timeline: segment.timeline,
        duration: part && part.duration || segment.duration,
        segment: segment,
        part: part,
        byteLength: 0,
        transmuxer: this.transmuxer_,
        getMediaInfoForTime: getMediaInfoForTime,
        independent: independent
      };
      var overrideCheck = typeof forceTimestampOffset !== 'undefined' ? forceTimestampOffset : this.isPendingTimestampOffset_;
      segmentInfo.timestampOffset = this.timestampOffsetForSegment_({
        segmentTimeline: segment.timeline,
        currentTimeline: this.currentTimeline_,
        startOfSegment: startOfSegment,
        buffered: this.buffered_(),
        overrideCheck: overrideCheck
      });
      var audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());
      if (typeof audioBufferedEnd === 'number') {
        segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();
      }
      if (this.sourceUpdater_.videoBuffered().length) {
        segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(this.gopBuffer_,
        this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_);
      }
      return segmentInfo;
    }
    ;
    _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_(options) {
      return timestampOffsetForSegment(options);
    }
    ;
    _proto.earlyAbortWhenNeeded_ = function earlyAbortWhenNeeded_(stats) {
      if (this.vhs_.tech_.paused() ||
      !this.xhrOptions_.timeout ||
      !this.playlist_.attributes.BANDWIDTH) {
        return;
      }
      if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1000) {
        return;
      }
      var currentTime = this.currentTime_();
      var measuredBandwidth = stats.bandwidth;
      var segmentDuration = this.pendingSegment_.duration;
      var requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);
      var timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1;
      if (requestTimeRemaining <= timeUntilRebuffer$1) {
        return;
      }
      var switchCandidate = minRebufferMaxBandwidthSelector({
        master: this.vhs_.playlists.master,
        currentTime: currentTime,
        bandwidth: measuredBandwidth,
        duration: this.duration_(),
        segmentDuration: segmentDuration,
        timeUntilRebuffer: timeUntilRebuffer$1,
        currentTimeline: this.currentTimeline_,
        syncController: this.syncController_
      });
      if (!switchCandidate) {
        return;
      }
      var rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;
      var timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;
      var minimumTimeSaving = 0.5;
      if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {
        minimumTimeSaving = 1;
      }
      if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {
        return;
      }
      this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;
      this.trigger('earlyabort');
    };
    _proto.handleAbort_ = function handleAbort_(segmentInfo) {
      this.logger_("Aborting " + segmentInfoString(segmentInfo));
      this.mediaRequestsAborted += 1;
    }
    ;
    _proto.handleProgress_ = function handleProgress_(event, simpleSegment) {
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      this.trigger('progress');
    };
    _proto.handleTrackInfo_ = function handleTrackInfo_(simpleSegment, trackInfo) {
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      if (this.checkForIllegalMediaSwitch(trackInfo)) {
        return;
      }
      trackInfo = trackInfo || {};
      if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {
        this.appendInitSegment_ = {
          audio: true,
          video: true
        };
        this.startingMediaInfo_ = trackInfo;
        this.currentMediaInfo_ = trackInfo;
        this.logger_('trackinfo update', trackInfo);
        this.trigger('trackinfo');
      }
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      this.pendingSegment_.trackInfo = trackInfo;
      if (this.hasEnoughInfoToAppend_()) {
        this.processCallQueue_();
      }
    };
    _proto.handleTimingInfo_ = function handleTimingInfo_(simpleSegment, mediaType, timeType, time) {
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      var segmentInfo = this.pendingSegment_;
      var timingInfoProperty = timingInfoPropertyForMedia(mediaType);
      segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};
      segmentInfo[timingInfoProperty][timeType] = time;
      this.logger_("timinginfo: " + mediaType + " - " + timeType + " - " + time);
      if (this.hasEnoughInfoToAppend_()) {
        this.processCallQueue_();
      }
    };
    _proto.handleCaptions_ = function handleCaptions_(simpleSegment, captionData) {
      var _this2 = this;
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      if (captionData.length === 0) {
        this.logger_('SegmentLoader received no captions from a caption event');
        return;
      }
      var segmentInfo = this.pendingSegment_;
      if (!segmentInfo.hasAppendedData_) {
        this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));
        return;
      }
      var timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
      var captionTracks = {};
      captionData.forEach(function (caption) {
        captionTracks[caption.stream] = captionTracks[caption.stream] || {
          startTime: Infinity,
          captions: [],
          endTime: 0
        };
        var captionTrack = captionTracks[caption.stream];
        captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset);
        captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset);
        captionTrack.captions.push(caption);
      });
      Object.keys(captionTracks).forEach(function (trackName) {
        var _captionTracks$trackN = captionTracks[trackName],
            startTime = _captionTracks$trackN.startTime,
            endTime = _captionTracks$trackN.endTime,
            captions = _captionTracks$trackN.captions;
        var inbandTextTracks = _this2.inbandTextTracks_;
        _this2.logger_("adding cues from " + startTime + " -> " + endTime + " for " + trackName);
        createCaptionsTrackIfNotExists(inbandTextTracks, _this2.vhs_.tech_, trackName);
        removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);
        addCaptionData({
          captionArray: captions,
          inbandTextTracks: inbandTextTracks,
          timestampOffset: timestampOffset
        });
      });
      if (this.transmuxer_) {
        this.transmuxer_.postMessage({
          action: 'clearParsedMp4Captions'
        });
      }
    };
    _proto.handleId3_ = function handleId3_(simpleSegment, id3Frames, dispatchType) {
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      var segmentInfo = this.pendingSegment_;
      if (!segmentInfo.hasAppendedData_) {
        this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));
        return;
      }
      var timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
      createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.vhs_.tech_);
      addMetadata({
        inbandTextTracks: this.inbandTextTracks_,
        metadataArray: id3Frames,
        timestampOffset: timestampOffset,
        videoDuration: this.duration_()
      });
    };
    _proto.processMetadataQueue_ = function processMetadataQueue_() {
      this.metadataQueue_.id3.forEach(function (fn) {
        return fn();
      });
      this.metadataQueue_.caption.forEach(function (fn) {
        return fn();
      });
      this.metadataQueue_.id3 = [];
      this.metadataQueue_.caption = [];
    };
    _proto.processCallQueue_ = function processCallQueue_() {
      var callQueue = this.callQueue_;
      this.callQueue_ = [];
      callQueue.forEach(function (fun) {
        return fun();
      });
    };
    _proto.processLoadQueue_ = function processLoadQueue_() {
      var loadQueue = this.loadQueue_;
      this.loadQueue_ = [];
      loadQueue.forEach(function (fun) {
        return fun();
      });
    }
    ;
    _proto.hasEnoughInfoToLoad_ = function hasEnoughInfoToLoad_() {
      if (this.loaderType_ !== 'audio') {
        return true;
      }
      var segmentInfo = this.pendingSegment_;
      if (!segmentInfo) {
        return false;
      }
      if (!this.getCurrentMediaInfo_()) {
        return true;
      }
      if (
      shouldWaitForTimelineChange({
        timelineChangeController: this.timelineChangeController_,
        currentTimeline: this.currentTimeline_,
        segmentTimeline: segmentInfo.timeline,
        loaderType: this.loaderType_,
        audioDisabled: this.audioDisabled_
      })) {
        return false;
      }
      return true;
    };
    _proto.getCurrentMediaInfo_ = function getCurrentMediaInfo_(segmentInfo) {
      if (segmentInfo === void 0) {
        segmentInfo = this.pendingSegment_;
      }
      return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;
    };
    _proto.getMediaInfo_ = function getMediaInfo_(segmentInfo) {
      if (segmentInfo === void 0) {
        segmentInfo = this.pendingSegment_;
      }
      return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;
    };
    _proto.hasEnoughInfoToAppend_ = function hasEnoughInfoToAppend_() {
      if (!this.sourceUpdater_.ready()) {
        return false;
      }
      if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) {
        return false;
      }
      var segmentInfo = this.pendingSegment_;
      var trackInfo = this.getCurrentMediaInfo_();
      if (!segmentInfo || !trackInfo) {
        return false;
      }
      var hasAudio = trackInfo.hasAudio,
          hasVideo = trackInfo.hasVideo,
          isMuxed = trackInfo.isMuxed;
      if (hasVideo && !segmentInfo.videoTimingInfo) {
        return false;
      }
      if (hasAudio && !this.audioDisabled_ && !isMuxed && !segmentInfo.audioTimingInfo) {
        return false;
      }
      if (shouldWaitForTimelineChange({
        timelineChangeController: this.timelineChangeController_,
        currentTimeline: this.currentTimeline_,
        segmentTimeline: segmentInfo.timeline,
        loaderType: this.loaderType_,
        audioDisabled: this.audioDisabled_
      })) {
        return false;
      }
      return true;
    };
    _proto.handleData_ = function handleData_(simpleSegment, result) {
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
        this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));
        return;
      }
      var segmentInfo = this.pendingSegment_;
      this.setTimeMapping_(segmentInfo.timeline);
      this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment);
      if (this.mediaSource_.readyState === 'closed') {
        return;
      }
      if (simpleSegment.map) {
        simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true);
        segmentInfo.segment.map = simpleSegment.map;
      }
      if (simpleSegment.key) {
        this.segmentKey(simpleSegment.key, true);
      }
      segmentInfo.isFmp4 = simpleSegment.isFmp4;
      segmentInfo.timingInfo = segmentInfo.timingInfo || {};
      if (segmentInfo.isFmp4) {
        this.trigger('fmp4');
        segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;
      } else {
        var trackInfo = this.getCurrentMediaInfo_();
        var useVideoTimingInfo = this.loaderType_ === 'main' && trackInfo && trackInfo.hasVideo;
        var firstVideoFrameTimeForData;
        if (useVideoTimingInfo) {
          firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;
        }
        segmentInfo.timingInfo.start = this.trueSegmentStart_({
          currentStart: segmentInfo.timingInfo.start,
          playlist: segmentInfo.playlist,
          mediaIndex: segmentInfo.mediaIndex,
          currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
          useVideoTimingInfo: useVideoTimingInfo,
          firstVideoFrameTimeForData: firstVideoFrameTimeForData,
          videoTimingInfo: segmentInfo.videoTimingInfo,
          audioTimingInfo: segmentInfo.audioTimingInfo
        });
      }
      this.updateAppendInitSegmentStatus(segmentInfo, result.type);
      this.updateSourceBufferTimestampOffset_(segmentInfo);
      if (segmentInfo.isSyncRequest) {
        this.updateTimingInfoEnd_(segmentInfo);
        this.syncController_.saveSegmentTimingInfo({
          segmentInfo: segmentInfo,
          shouldSaveTimelineMapping: this.loaderType_ === 'main'
        });
        var next = this.chooseNextRequest_();
        if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {
          this.logger_('sync segment was incorrect, not appending');
          return;
        }
        this.logger_('sync segment was correct, appending');
      }
      segmentInfo.hasAppendedData_ = true;
      this.processMetadataQueue_();
      this.appendData_(segmentInfo, result);
    };
    _proto.updateAppendInitSegmentStatus = function updateAppendInitSegmentStatus(segmentInfo, type) {
      if (this.loaderType_ === 'main' && typeof segmentInfo.timestampOffset === 'number' &&
      !segmentInfo.changedTimestampOffset) {
        this.appendInitSegment_ = {
          audio: true,
          video: true
        };
      }
      if (this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist) {
        this.appendInitSegment_[type] = true;
      }
    };
    _proto.getInitSegmentAndUpdateState_ = function getInitSegmentAndUpdateState_(_ref4) {
      var type = _ref4.type,
          initSegment = _ref4.initSegment,
          map = _ref4.map,
          playlist = _ref4.playlist;
      if (map) {
        var id = initSegmentId(map);
        if (this.activeInitSegmentId_ === id) {
          return null;
        }
        initSegment = this.initSegmentForMap(map, true).bytes;
        this.activeInitSegmentId_ = id;
      }
      if (initSegment && this.appendInitSegment_[type]) {
        this.playlistOfLastInitSegment_[type] = playlist;
        this.appendInitSegment_[type] = false;
        this.activeInitSegmentId_ = null;
        return initSegment;
      }
      return null;
    };
    _proto.handleQuotaExceededError_ = function handleQuotaExceededError_(_ref5, error) {
      var _this3 = this;
      var segmentInfo = _ref5.segmentInfo,
          type = _ref5.type,
          bytes = _ref5.bytes;
      var audioBuffered = this.sourceUpdater_.audioBuffered();
      var videoBuffered = this.sourceUpdater_.videoBuffered();
      if (audioBuffered.length > 1) {
        this.logger_('On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: ' + timeRangesToArray(audioBuffered).join(', '));
      }
      if (videoBuffered.length > 1) {
        this.logger_('On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: ' + timeRangesToArray(videoBuffered).join(', '));
      }
      var audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;
      var audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;
      var videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;
      var videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;
      if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {
        this.logger_('On QUOTA_EXCEEDED_ERR, single segment too large to append to ' + 'buffer, triggering an error. ' + ("Appended byte length: " + bytes.byteLength + ", ") + ("audio buffer: " + timeRangesToArray(audioBuffered).join(', ') + ", ") + ("video buffer: " + timeRangesToArray(videoBuffered).join(', ') + ", "));
        this.error({
          message: 'Quota exceeded error with append of a single segment of content',
          excludeUntil: Infinity
        });
        this.trigger('error');
        return;
      }
      this.waitingOnRemove_ = true;
      this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
        segmentInfo: segmentInfo,
        type: type,
        bytes: bytes
      }));
      var currentTime = this.currentTime_();
      var timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;
      this.logger_("On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to " + timeToRemoveUntil);
      this.remove(0, timeToRemoveUntil, function () {
        _this3.logger_("On QUOTA_EXCEEDED_ERR, retrying append in " + MIN_BACK_BUFFER + "s");
        _this3.waitingOnRemove_ = false;
        _this3.quotaExceededErrorRetryTimeout_ = window.setTimeout(function () {
          _this3.logger_('On QUOTA_EXCEEDED_ERR, re-processing call queue');
          _this3.quotaExceededErrorRetryTimeout_ = null;
          _this3.processCallQueue_();
        }, MIN_BACK_BUFFER * 1000);
      }, true);
    };
    _proto.handleAppendError_ = function handleAppendError_(_ref6, error) {
      var segmentInfo = _ref6.segmentInfo,
          type = _ref6.type,
          bytes = _ref6.bytes;
      if (!error) {
        return;
      }
      if (error.code === QUOTA_EXCEEDED_ERR) {
        this.handleQuotaExceededError_({
          segmentInfo: segmentInfo,
          type: type,
          bytes: bytes
        });
        return;
      }
      this.logger_('Received non QUOTA_EXCEEDED_ERR on append', error);
      this.error(type + " append of " + bytes.length + "b failed for segment " + ("#" + segmentInfo.mediaIndex + " in playlist " + segmentInfo.playlist.id));
      this.trigger('appenderror');
    };
    _proto.appendToSourceBuffer_ = function appendToSourceBuffer_(_ref7) {
      var segmentInfo = _ref7.segmentInfo,
          type = _ref7.type,
          initSegment = _ref7.initSegment,
          data = _ref7.data,
          bytes = _ref7.bytes;
      if (!bytes) {
        var segments = [data];
        var byteLength = data.byteLength;
        if (initSegment) {
          segments.unshift(initSegment);
          byteLength += initSegment.byteLength;
        }
        bytes = concatSegments({
          bytes: byteLength,
          segments: segments
        });
      }
      this.sourceUpdater_.appendBuffer({
        segmentInfo: segmentInfo,
        type: type,
        bytes: bytes
      }, this.handleAppendError_.bind(this, {
        segmentInfo: segmentInfo,
        type: type,
        bytes: bytes
      }));
    };
    _proto.handleSegmentTimingInfo_ = function handleSegmentTimingInfo_(type, requestId, segmentTimingInfo) {
      if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {
        return;
      }
      var segment = this.pendingSegment_.segment;
      var timingInfoProperty = type + "TimingInfo";
      if (!segment[timingInfoProperty]) {
        segment[timingInfoProperty] = {};
      }
      segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;
      segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;
      segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;
      segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;
      segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode;
      segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;
    };
    _proto.appendData_ = function appendData_(segmentInfo, result) {
      var type = result.type,
          data = result.data;
      if (!data || !data.byteLength) {
        return;
      }
      if (type === 'audio' && this.audioDisabled_) {
        return;
      }
      var initSegment = this.getInitSegmentAndUpdateState_({
        type: type,
        initSegment: result.initSegment,
        playlist: segmentInfo.playlist,
        map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null
      });
      this.appendToSourceBuffer_({
        segmentInfo: segmentInfo,
        type: type,
        initSegment: initSegment,
        data: data
      });
    }
    ;
    _proto.loadSegment_ = function loadSegment_(segmentInfo) {
      var _this4 = this;
      this.state = 'WAITING';
      this.pendingSegment_ = segmentInfo;
      this.trimBackBuffer_(segmentInfo);
      if (typeof segmentInfo.timestampOffset === 'number') {
        if (this.transmuxer_) {
          this.transmuxer_.postMessage({
            action: 'clearAllMp4Captions'
          });
        }
      }
      if (!this.hasEnoughInfoToLoad_()) {
        this.loadQueue_.push(function () {
          var options = _extends_1({}, segmentInfo, {
            forceTimestampOffset: true
          });
          _extends_1(segmentInfo, _this4.generateSegmentInfo_(options));
          _this4.isPendingTimestampOffset_ = false;
          _this4.updateTransmuxerAndRequestSegment_(segmentInfo);
        });
        return;
      }
      this.updateTransmuxerAndRequestSegment_(segmentInfo);
    };
    _proto.updateTransmuxerAndRequestSegment_ = function updateTransmuxerAndRequestSegment_(segmentInfo) {
      var _this5 = this;
      if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {
        this.gopBuffer_.length = 0;
        segmentInfo.gopsToAlignWith = [];
        this.timeMapping_ = 0;
        this.transmuxer_.postMessage({
          action: 'reset'
        });
        this.transmuxer_.postMessage({
          action: 'setTimestampOffset',
          timestampOffset: segmentInfo.timestampOffset
        });
      }
      var simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);
      var isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);
      var isWalkingForward = this.mediaIndex !== null;
      var isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ &&
      segmentInfo.timeline > 0;
      var isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;
      this.logger_("Requesting " + segmentInfoString(segmentInfo));
      if (simpleSegment.map && !simpleSegment.map.bytes) {
        this.logger_('going to request init segment.');
        this.appendInitSegment_ = {
          video: true,
          audio: true
        };
      }
      segmentInfo.abortRequests = mediaSegmentRequest({
        xhr: this.vhs_.xhr,
        xhrOptions: this.xhrOptions_,
        decryptionWorker: this.decrypter_,
        segment: simpleSegment,
        abortFn: this.handleAbort_.bind(this, segmentInfo),
        progressFn: this.handleProgress_.bind(this),
        trackInfoFn: this.handleTrackInfo_.bind(this),
        timingInfoFn: this.handleTimingInfo_.bind(this),
        videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, 'video', segmentInfo.requestId),
        audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, 'audio', segmentInfo.requestId),
        captionsFn: this.handleCaptions_.bind(this),
        isEndOfTimeline: isEndOfTimeline,
        endedTimelineFn: function endedTimelineFn() {
          _this5.logger_('received endedtimeline callback');
        },
        id3Fn: this.handleId3_.bind(this),
        dataFn: this.handleData_.bind(this),
        doneFn: this.segmentRequestFinished_.bind(this),
        onTransmuxerLog: function onTransmuxerLog(_ref8) {
          var message = _ref8.message,
              level = _ref8.level,
              stream = _ref8.stream;
          _this5.logger_(segmentInfoString(segmentInfo) + " logged from transmuxer stream " + stream + " as a " + level + ": " + message);
        }
      });
    }
    ;
    _proto.trimBackBuffer_ = function trimBackBuffer_(segmentInfo) {
      var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
      if (removeToTime > 0) {
        this.remove(0, removeToTime);
      }
    }
    ;
    _proto.createSimplifiedSegmentObj_ = function createSimplifiedSegmentObj_(segmentInfo) {
      var segment = segmentInfo.segment;
      var part = segmentInfo.part;
      var simpleSegment = {
        resolvedUri: part ? part.resolvedUri : segment.resolvedUri,
        byterange: part ? part.byterange : segment.byterange,
        requestId: segmentInfo.requestId,
        transmuxer: segmentInfo.transmuxer,
        audioAppendStart: segmentInfo.audioAppendStart,
        gopsToAlignWith: segmentInfo.gopsToAlignWith,
        part: segmentInfo.part
      };
      var previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];
      if (previousSegment && previousSegment.timeline === segment.timeline) {
        if (previousSegment.videoTimingInfo) {
          simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd;
        } else if (previousSegment.audioTimingInfo) {
          simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;
        }
      }
      if (segment.key) {
        var iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);
        simpleSegment.key = this.segmentKey(segment.key);
        simpleSegment.key.iv = iv;
      }
      if (segment.map) {
        simpleSegment.map = this.initSegmentForMap(segment.map);
      }
      return simpleSegment;
    };
    _proto.saveTransferStats_ = function saveTransferStats_(stats) {
      this.mediaRequests += 1;
      if (stats) {
        this.mediaBytesTransferred += stats.bytesReceived;
        this.mediaTransferDuration += stats.roundTripTime;
      }
    };
    _proto.saveBandwidthRelatedStats_ = function saveBandwidthRelatedStats_(duration, stats) {
      this.pendingSegment_.byteLength = stats.bytesReceived;
      if (duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
        this.logger_("Ignoring segment's bandwidth because its duration of " + duration + (" is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS));
        return;
      }
      this.bandwidth = stats.bandwidth;
      this.roundTrip = stats.roundTripTime;
    };
    _proto.handleTimeout_ = function handleTimeout_() {
      this.mediaRequestsTimedout += 1;
      this.bandwidth = 1;
      this.roundTrip = NaN;
      this.trigger('bandwidthupdate');
    }
    ;
    _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {
      if (this.callQueue_.length) {
        this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));
        return;
      }
      this.saveTransferStats_(simpleSegment.stats);
      if (!this.pendingSegment_) {
        return;
      }
      if (simpleSegment.requestId !== this.pendingSegment_.requestId) {
        return;
      }
      if (error) {
        this.pendingSegment_ = null;
        this.state = 'READY';
        if (error.code === REQUEST_ERRORS.ABORTED) {
          return;
        }
        this.pause();
        if (error.code === REQUEST_ERRORS.TIMEOUT) {
          this.handleTimeout_();
          return;
        }
        this.mediaRequestsErrored += 1;
        this.error(error);
        this.trigger('error');
        return;
      }
      var segmentInfo = this.pendingSegment_;
      this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
      segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;
      if (result.gopInfo) {
        this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);
      }
      this.state = 'APPENDING';
      this.trigger('appending');
      this.waitForAppendsToComplete_(segmentInfo);
    };
    _proto.setTimeMapping_ = function setTimeMapping_(timeline) {
      var timelineMapping = this.syncController_.mappingForTimeline(timeline);
      if (timelineMapping !== null) {
        this.timeMapping_ = timelineMapping;
      }
    };
    _proto.updateMediaSecondsLoaded_ = function updateMediaSecondsLoaded_(segment) {
      if (typeof segment.start === 'number' && typeof segment.end === 'number') {
        this.mediaSecondsLoaded += segment.end - segment.start;
      } else {
        this.mediaSecondsLoaded += segment.duration;
      }
    };
    _proto.shouldUpdateTransmuxerTimestampOffset_ = function shouldUpdateTransmuxerTimestampOffset_(timestampOffset) {
      if (timestampOffset === null) {
        return false;
      }
      if (this.loaderType_ === 'main' && timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
        return true;
      }
      if (!this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
        return true;
      }
      return false;
    };
    _proto.trueSegmentStart_ = function trueSegmentStart_(_ref9) {
      var currentStart = _ref9.currentStart,
          playlist = _ref9.playlist,
          mediaIndex = _ref9.mediaIndex,
          firstVideoFrameTimeForData = _ref9.firstVideoFrameTimeForData,
          currentVideoTimestampOffset = _ref9.currentVideoTimestampOffset,
          useVideoTimingInfo = _ref9.useVideoTimingInfo,
          videoTimingInfo = _ref9.videoTimingInfo,
          audioTimingInfo = _ref9.audioTimingInfo;
      if (typeof currentStart !== 'undefined') {
        return currentStart;
      }
      if (!useVideoTimingInfo) {
        return audioTimingInfo.start;
      }
      var previousSegment = playlist.segments[mediaIndex - 1];
      if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === 'undefined' || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {
        return firstVideoFrameTimeForData;
      }
      return videoTimingInfo.start;
    };
    _proto.waitForAppendsToComplete_ = function waitForAppendsToComplete_(segmentInfo) {
      var trackInfo = this.getCurrentMediaInfo_(segmentInfo);
      if (!trackInfo) {
        this.error({
          message: 'No starting media returned, likely due to an unsupported media format.',
          blacklistDuration: Infinity
        });
        this.trigger('error');
        return;
      }
      var hasAudio = trackInfo.hasAudio,
          hasVideo = trackInfo.hasVideo,
          isMuxed = trackInfo.isMuxed;
      var waitForVideo = this.loaderType_ === 'main' && hasVideo;
      var waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed;
      segmentInfo.waitingOnAppends = 0;
      if (!segmentInfo.hasAppendedData_) {
        if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === 'number') {
          this.isPendingTimestampOffset_ = true;
        }
        segmentInfo.timingInfo = {
          start: 0
        };
        segmentInfo.waitingOnAppends++;
        if (!this.isPendingTimestampOffset_) {
          this.updateSourceBufferTimestampOffset_(segmentInfo);
          this.processMetadataQueue_();
        }
        this.checkAppendsDone_(segmentInfo);
        return;
      }
      if (waitForVideo) {
        segmentInfo.waitingOnAppends++;
      }
      if (waitForAudio) {
        segmentInfo.waitingOnAppends++;
      }
      if (waitForVideo) {
        this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
      }
      if (waitForAudio) {
        this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
      }
    };
    _proto.checkAppendsDone_ = function checkAppendsDone_(segmentInfo) {
      if (this.checkForAbort_(segmentInfo.requestId)) {
        return;
      }
      segmentInfo.waitingOnAppends--;
      if (segmentInfo.waitingOnAppends === 0) {
        this.handleAppendsDone_();
      }
    };
    _proto.checkForIllegalMediaSwitch = function checkForIllegalMediaSwitch(trackInfo) {
      var illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);
      if (illegalMediaSwitchError) {
        this.error({
          message: illegalMediaSwitchError,
          blacklistDuration: Infinity
        });
        this.trigger('error');
        return true;
      }
      return false;
    };
    _proto.updateSourceBufferTimestampOffset_ = function updateSourceBufferTimestampOffset_(segmentInfo) {
      if (segmentInfo.timestampOffset === null ||
      typeof segmentInfo.timingInfo.start !== 'number' ||
      segmentInfo.changedTimestampOffset ||
      this.loaderType_ !== 'main') {
        return;
      }
      var didChange = false;
      segmentInfo.timestampOffset -= segmentInfo.timingInfo.start;
      segmentInfo.changedTimestampOffset = true;
      if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
        this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);
        didChange = true;
      }
      if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
        this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);
        didChange = true;
      }
      if (didChange) {
        this.trigger('timestampoffset');
      }
    };
    _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_(segmentInfo) {
      segmentInfo.timingInfo = segmentInfo.timingInfo || {};
      var trackInfo = this.getMediaInfo_();
      var useVideoTimingInfo = this.loaderType_ === 'main' && trackInfo && trackInfo.hasVideo;
      var prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;
      if (!prioritizedTimingInfo) {
        return;
      }
      segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === 'number' ?
      prioritizedTimingInfo.end : prioritizedTimingInfo.start + segmentInfo.duration;
    }
    ;
    _proto.handleAppendsDone_ = function handleAppendsDone_() {
      if (this.pendingSegment_) {
        this.trigger('appendsdone');
      }
      if (!this.pendingSegment_) {
        this.state = 'READY';
        if (!this.paused()) {
          this.monitorBuffer_();
        }
        return;
      }
      var segmentInfo = this.pendingSegment_;
      this.updateTimingInfoEnd_(segmentInfo);
      if (this.shouldSaveSegmentTimingInfo_) {
        this.syncController_.saveSegmentTimingInfo({
          segmentInfo: segmentInfo,
          shouldSaveTimelineMapping: this.loaderType_ === 'main'
        });
      }
      var segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);
      if (segmentDurationMessage) {
        if (segmentDurationMessage.severity === 'warn') {
          videojs.log.warn(segmentDurationMessage.message);
        } else {
          this.logger_(segmentDurationMessage.message);
        }
      }
      this.recordThroughput_(segmentInfo);
      this.pendingSegment_ = null;
      this.state = 'READY';
      if (segmentInfo.isSyncRequest) {
        this.trigger('syncinfoupdate');
        if (!segmentInfo.hasAppendedData_) {
          this.logger_("Throwing away un-appended sync request " + segmentInfoString(segmentInfo));
          return;
        }
      }
      this.logger_("Appended " + segmentInfoString(segmentInfo));
      this.addSegmentMetadataCue_(segmentInfo);
      this.fetchAtBuffer_ = true;
      if (this.currentTimeline_ !== segmentInfo.timeline) {
        this.timelineChangeController_.lastTimelineChange({
          type: this.loaderType_,
          from: this.currentTimeline_,
          to: segmentInfo.timeline
        });
        if (this.loaderType_ === 'main' && !this.audioDisabled_) {
          this.timelineChangeController_.lastTimelineChange({
            type: 'audio',
            from: this.currentTimeline_,
            to: segmentInfo.timeline
          });
        }
      }
      this.currentTimeline_ = segmentInfo.timeline;
      this.trigger('syncinfoupdate');
      var segment = segmentInfo.segment;
      var part = segmentInfo.part;
      var badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;
      var badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3;
      if (badSegmentGuess || badPartGuess) {
        this.logger_("bad " + (badSegmentGuess ? 'segment' : 'part') + " " + segmentInfoString(segmentInfo));
        this.resetEverything();
        return;
      }
      var isWalkingForward = this.mediaIndex !== null;
      if (isWalkingForward) {
        this.trigger('bandwidthupdate');
      }
      this.trigger('progress');
      this.mediaIndex = segmentInfo.mediaIndex;
      this.partIndex = segmentInfo.partIndex;
      if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) {
        this.endOfStream();
      }
      this.trigger('appended');
      if (segmentInfo.hasAppendedData_) {
        this.mediaAppends++;
      }
      if (!this.paused()) {
        this.monitorBuffer_();
      }
    }
    ;
    _proto.recordThroughput_ = function recordThroughput_(segmentInfo) {
      if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
        this.logger_("Ignoring segment's throughput because its duration of " + segmentInfo.duration + (" is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS));
        return;
      }
      var rate = this.throughput.rate;
      var segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;
      var segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1000);
      this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;
    }
    ;
    _proto.addSegmentMetadataCue_ = function addSegmentMetadataCue_(segmentInfo) {
      if (!this.segmentMetadataTrack_) {
        return;
      }
      var segment = segmentInfo.segment;
      var start = segment.start;
      var end = segment.end;
      if (!finite(start) || !finite(end)) {
        return;
      }
      removeCuesFromTrack(start, end, this.segmentMetadataTrack_);
      var Cue = window.WebKitDataCue || window.VTTCue;
      var value = {
        custom: segment.custom,
        dateTimeObject: segment.dateTimeObject,
        dateTimeString: segment.dateTimeString,
        bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,
        resolution: segmentInfo.playlist.attributes.RESOLUTION,
        codecs: segmentInfo.playlist.attributes.CODECS,
        byteLength: segmentInfo.byteLength,
        uri: segmentInfo.uri,
        timeline: segmentInfo.timeline,
        playlist: segmentInfo.playlist.id,
        start: start,
        end: end
      };
      var data = JSON.stringify(value);
      var cue = new Cue(start, end, data);
      cue.value = value;
      this.segmentMetadataTrack_.addCue(cue);
    };
    return SegmentLoader;
  }(videojs.EventTarget);
  function noop() {}
  var toTitleCase = function toTitleCase(string) {
    if (typeof string !== 'string') {
      return string;
    }
    return string.replace(/./, function (w) {
      return w.toUpperCase();
    });
  };
  var bufferTypes = ['video', 'audio'];
  var _updating = function updating(type, sourceUpdater) {
    var sourceBuffer = sourceUpdater[type + "Buffer"];
    return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];
  };
  var nextQueueIndexOfType = function nextQueueIndexOfType(type, queue) {
    for (var i = 0; i < queue.length; i++) {
      var queueEntry = queue[i];
      if (queueEntry.type === 'mediaSource') {
        return null;
      }
      if (queueEntry.type === type) {
        return i;
      }
    }
    return null;
  };
  var shiftQueue = function shiftQueue(type, sourceUpdater) {
    if (sourceUpdater.queue.length === 0) {
      return;
    }
    var queueIndex = 0;
    var queueEntry = sourceUpdater.queue[queueIndex];
    if (queueEntry.type === 'mediaSource') {
      if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== 'closed') {
        sourceUpdater.queue.shift();
        queueEntry.action(sourceUpdater);
        if (queueEntry.doneFn) {
          queueEntry.doneFn();
        }
        shiftQueue('audio', sourceUpdater);
        shiftQueue('video', sourceUpdater);
      }
      return;
    }
    if (type === 'mediaSource') {
      return;
    }
    if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === 'closed' || _updating(type, sourceUpdater)) {
      return;
    }
    if (queueEntry.type !== type) {
      queueIndex = nextQueueIndexOfType(type, sourceUpdater.queue);
      if (queueIndex === null) {
        return;
      }
      queueEntry = sourceUpdater.queue[queueIndex];
    }
    sourceUpdater.queue.splice(queueIndex, 1);
    sourceUpdater.queuePending[type] = queueEntry;
    queueEntry.action(type, sourceUpdater);
    if (!queueEntry.doneFn) {
      sourceUpdater.queuePending[type] = null;
      shiftQueue(type, sourceUpdater);
      return;
    }
  };
  var cleanupBuffer = function cleanupBuffer(type, sourceUpdater) {
    var buffer = sourceUpdater[type + "Buffer"];
    var titleType = toTitleCase(type);
    if (!buffer) {
      return;
    }
    buffer.removeEventListener('updateend', sourceUpdater["on" + titleType + "UpdateEnd_"]);
    buffer.removeEventListener('error', sourceUpdater["on" + titleType + "Error_"]);
    sourceUpdater.codecs[type] = null;
    sourceUpdater[type + "Buffer"] = null;
  };
  var inSourceBuffers = function inSourceBuffers(mediaSource, sourceBuffer) {
    return mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;
  };
  var actions = {
    appendBuffer: function appendBuffer(bytes, segmentInfo, onError) {
      return function (type, sourceUpdater) {
        var sourceBuffer = sourceUpdater[type + "Buffer"];
        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
          return;
        }
        sourceUpdater.logger_("Appending segment " + segmentInfo.mediaIndex + "'s " + bytes.length + " bytes to " + type + "Buffer");
        try {
          sourceBuffer.appendBuffer(bytes);
        } catch (e) {
          sourceUpdater.logger_("Error with code " + e.code + " " + (e.code === QUOTA_EXCEEDED_ERR ? '(QUOTA_EXCEEDED_ERR) ' : '') + ("when appending segment " + segmentInfo.mediaIndex + " to " + type + "Buffer"));
          sourceUpdater.queuePending[type] = null;
          onError(e);
        }
      };
    },
    remove: function remove(start, end) {
      return function (type, sourceUpdater) {
        var sourceBuffer = sourceUpdater[type + "Buffer"];
        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
          return;
        }
        sourceUpdater.logger_("Removing " + start + " to " + end + " from " + type + "Buffer");
        try {
          sourceBuffer.remove(start, end);
        } catch (e) {
          sourceUpdater.logger_("Remove " + start + " to " + end + " from " + type + "Buffer failed");
        }
      };
    },
    timestampOffset: function timestampOffset(offset) {
      return function (type, sourceUpdater) {
        var sourceBuffer = sourceUpdater[type + "Buffer"];
        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
          return;
        }
        sourceUpdater.logger_("Setting " + type + "timestampOffset to " + offset);
        sourceBuffer.timestampOffset = offset;
      };
    },
    callback: function callback(_callback) {
      return function (type, sourceUpdater) {
        _callback();
      };
    },
    endOfStream: function endOfStream(error) {
      return function (sourceUpdater) {
        if (sourceUpdater.mediaSource.readyState !== 'open') {
          return;
        }
        sourceUpdater.logger_("Calling mediaSource endOfStream(" + (error || '') + ")");
        try {
          sourceUpdater.mediaSource.endOfStream(error);
        } catch (e) {
          videojs.log.warn('Failed to call media source endOfStream', e);
        }
      };
    },
    duration: function duration(_duration) {
      return function (sourceUpdater) {
        sourceUpdater.logger_("Setting mediaSource duration to " + _duration);
        try {
          sourceUpdater.mediaSource.duration = _duration;
        } catch (e) {
          videojs.log.warn('Failed to set media source duration', e);
        }
      };
    },
    abort: function abort() {
      return function (type, sourceUpdater) {
        if (sourceUpdater.mediaSource.readyState !== 'open') {
          return;
        }
        var sourceBuffer = sourceUpdater[type + "Buffer"];
        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
          return;
        }
        sourceUpdater.logger_("calling abort on " + type + "Buffer");
        try {
          sourceBuffer.abort();
        } catch (e) {
          videojs.log.warn("Failed to abort on " + type + "Buffer", e);
        }
      };
    },
    addSourceBuffer: function addSourceBuffer(type, codec) {
      return function (sourceUpdater) {
        var titleType = toTitleCase(type);
        var mime = getMimeForCodec(codec);
        sourceUpdater.logger_("Adding " + type + "Buffer with codec " + codec + " to mediaSource");
        var sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);
        sourceBuffer.addEventListener('updateend', sourceUpdater["on" + titleType + "UpdateEnd_"]);
        sourceBuffer.addEventListener('error', sourceUpdater["on" + titleType + "Error_"]);
        sourceUpdater.codecs[type] = codec;
        sourceUpdater[type + "Buffer"] = sourceBuffer;
      };
    },
    removeSourceBuffer: function removeSourceBuffer(type) {
      return function (sourceUpdater) {
        var sourceBuffer = sourceUpdater[type + "Buffer"];
        cleanupBuffer(type, sourceUpdater);
        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
          return;
        }
        sourceUpdater.logger_("Removing " + type + "Buffer with codec " + sourceUpdater.codecs[type] + " from mediaSource");
        try {
          sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);
        } catch (e) {
          videojs.log.warn("Failed to removeSourceBuffer " + type + "Buffer", e);
        }
      };
    },
    changeType: function changeType(codec) {
      return function (type, sourceUpdater) {
        var sourceBuffer = sourceUpdater[type + "Buffer"];
        var mime = getMimeForCodec(codec);
        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
          return;
        }
        if (sourceUpdater.codecs[type] === codec) {
          return;
        }
        sourceUpdater.logger_("changing " + type + "Buffer codec from " + sourceUpdater.codecs[type] + " to " + codec);
        sourceBuffer.changeType(mime);
        sourceUpdater.codecs[type] = codec;
      };
    }
  };
  var pushQueue = function pushQueue(_ref) {
    var type = _ref.type,
        sourceUpdater = _ref.sourceUpdater,
        action = _ref.action,
        doneFn = _ref.doneFn,
        name = _ref.name;
    sourceUpdater.queue.push({
      type: type,
      action: action,
      doneFn: doneFn,
      name: name
    });
    shiftQueue(type, sourceUpdater);
  };
  var onUpdateend = function onUpdateend(type, sourceUpdater) {
    return function (e) {
      if (sourceUpdater.queuePending[type]) {
        var doneFn = sourceUpdater.queuePending[type].doneFn;
        sourceUpdater.queuePending[type] = null;
        if (doneFn) {
          doneFn(sourceUpdater[type + "Error_"]);
        }
      }
      shiftQueue(type, sourceUpdater);
    };
  };
  var SourceUpdater = function (_videojs$EventTarget) {
    inheritsLoose(SourceUpdater, _videojs$EventTarget);
    function SourceUpdater(mediaSource) {
      var _this;
      _this = _videojs$EventTarget.call(this) || this;
      _this.mediaSource = mediaSource;
      _this.sourceopenListener_ = function () {
        return shiftQueue('mediaSource', assertThisInitialized(_this));
      };
      _this.mediaSource.addEventListener('sourceopen', _this.sourceopenListener_);
      _this.logger_ = logger('SourceUpdater');
      _this.audioTimestampOffset_ = 0;
      _this.videoTimestampOffset_ = 0;
      _this.queue = [];
      _this.queuePending = {
        audio: null,
        video: null
      };
      _this.delayedAudioAppendQueue_ = [];
      _this.videoAppendQueued_ = false;
      _this.codecs = {};
      _this.onVideoUpdateEnd_ = onUpdateend('video', assertThisInitialized(_this));
      _this.onAudioUpdateEnd_ = onUpdateend('audio', assertThisInitialized(_this));
      _this.onVideoError_ = function (e) {
        _this.videoError_ = e;
      };
      _this.onAudioError_ = function (e) {
        _this.audioError_ = e;
      };
      _this.createdSourceBuffers_ = false;
      _this.initializedEme_ = false;
      _this.triggeredReady_ = false;
      return _this;
    }
    var _proto = SourceUpdater.prototype;
    _proto.initializedEme = function initializedEme() {
      this.initializedEme_ = true;
      this.triggerReady();
    };
    _proto.hasCreatedSourceBuffers = function hasCreatedSourceBuffers() {
      return this.createdSourceBuffers_;
    };
    _proto.hasInitializedAnyEme = function hasInitializedAnyEme() {
      return this.initializedEme_;
    };
    _proto.ready = function ready() {
      return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
    };
    _proto.createSourceBuffers = function createSourceBuffers(codecs) {
      if (this.hasCreatedSourceBuffers()) {
        return;
      }
      this.addOrChangeSourceBuffers(codecs);
      this.createdSourceBuffers_ = true;
      this.trigger('createdsourcebuffers');
      this.triggerReady();
    };
    _proto.triggerReady = function triggerReady() {
      if (this.ready() && !this.triggeredReady_) {
        this.triggeredReady_ = true;
        this.trigger('ready');
      }
    }
    ;
    _proto.addSourceBuffer = function addSourceBuffer(type, codec) {
      pushQueue({
        type: 'mediaSource',
        sourceUpdater: this,
        action: actions.addSourceBuffer(type, codec),
        name: 'addSourceBuffer'
      });
    }
    ;
    _proto.abort = function abort(type) {
      pushQueue({
        type: type,
        sourceUpdater: this,
        action: actions.abort(type),
        name: 'abort'
      });
    }
    ;
    _proto.removeSourceBuffer = function removeSourceBuffer(type) {
      if (!this.canRemoveSourceBuffer()) {
        videojs.log.error('removeSourceBuffer is not supported!');
        return;
      }
      pushQueue({
        type: 'mediaSource',
        sourceUpdater: this,
        action: actions.removeSourceBuffer(type),
        name: 'removeSourceBuffer'
      });
    }
    ;
    _proto.canRemoveSourceBuffer = function canRemoveSourceBuffer() {
      return !videojs.browser.IE_VERSION && !videojs.browser.IS_FIREFOX && window.MediaSource && window.MediaSource.prototype && typeof window.MediaSource.prototype.removeSourceBuffer === 'function';
    }
    ;
    SourceUpdater.canChangeType = function canChangeType() {
      return window.SourceBuffer && window.SourceBuffer.prototype && typeof window.SourceBuffer.prototype.changeType === 'function';
    }
    ;
    _proto.canChangeType = function canChangeType() {
      return this.constructor.canChangeType();
    }
    ;
    _proto.changeType = function changeType(type, codec) {
      if (!this.canChangeType()) {
        videojs.log.error('changeType is not supported!');
        return;
      }
      pushQueue({
        type: type,
        sourceUpdater: this,
        action: actions.changeType(codec),
        name: 'changeType'
      });
    }
    ;
    _proto.addOrChangeSourceBuffers = function addOrChangeSourceBuffers(codecs) {
      var _this2 = this;
      if (!codecs || typeof codecs !== 'object' || Object.keys(codecs).length === 0) {
        throw new Error('Cannot addOrChangeSourceBuffers to undefined codecs');
      }
      Object.keys(codecs).forEach(function (type) {
        var codec = codecs[type];
        if (!_this2.hasCreatedSourceBuffers()) {
          return _this2.addSourceBuffer(type, codec);
        }
        if (_this2.canChangeType()) {
          _this2.changeType(type, codec);
        }
      });
    }
    ;
    _proto.appendBuffer = function appendBuffer(options, doneFn) {
      var _this3 = this;
      var segmentInfo = options.segmentInfo,
          type = options.type,
          bytes = options.bytes;
      this.processedAppend_ = true;
      if (type === 'audio' && this.videoBuffer && !this.videoAppendQueued_) {
        this.delayedAudioAppendQueue_.push([options, doneFn]);
        this.logger_("delayed audio append of " + bytes.length + " until video append");
        return;
      }
      var onError = doneFn;
      pushQueue({
        type: type,
        sourceUpdater: this,
        action: actions.appendBuffer(bytes, segmentInfo || {
          mediaIndex: -1
        }, onError),
        doneFn: doneFn,
        name: 'appendBuffer'
      });
      if (type === 'video') {
        this.videoAppendQueued_ = true;
        if (!this.delayedAudioAppendQueue_.length) {
          return;
        }
        var queue = this.delayedAudioAppendQueue_.slice();
        this.logger_("queuing delayed audio " + queue.length + " appendBuffers");
        this.delayedAudioAppendQueue_.length = 0;
        queue.forEach(function (que) {
          _this3.appendBuffer.apply(_this3, que);
        });
      }
    }
    ;
    _proto.audioBuffered = function audioBuffered() {
      if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {
        return videojs.createTimeRange();
      }
      return this.audioBuffer.buffered ? this.audioBuffer.buffered : videojs.createTimeRange();
    }
    ;
    _proto.videoBuffered = function videoBuffered() {
      if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {
        return videojs.createTimeRange();
      }
      return this.videoBuffer.buffered ? this.videoBuffer.buffered : videojs.createTimeRange();
    }
    ;
    _proto.buffered = function buffered() {
      var video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;
      var audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
      if (audio && !video) {
        return this.audioBuffered();
      }
      if (video && !audio) {
        return this.videoBuffered();
      }
      return bufferIntersection(this.audioBuffered(), this.videoBuffered());
    }
    ;
    _proto.setDuration = function setDuration(duration, doneFn) {
      if (doneFn === void 0) {
        doneFn = noop;
      }
      pushQueue({
        type: 'mediaSource',
        sourceUpdater: this,
        action: actions.duration(duration),
        name: 'duration',
        doneFn: doneFn
      });
    }
    ;
    _proto.endOfStream = function endOfStream(error, doneFn) {
      if (error === void 0) {
        error = null;
      }
      if (doneFn === void 0) {
        doneFn = noop;
      }
      if (typeof error !== 'string') {
        error = undefined;
      }
      pushQueue({
        type: 'mediaSource',
        sourceUpdater: this,
        action: actions.endOfStream(error),
        name: 'endOfStream',
        doneFn: doneFn
      });
    }
    ;
    _proto.removeAudio = function removeAudio(start, end, done) {
      if (done === void 0) {
        done = noop;
      }
      if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
        done();
        return;
      }
      pushQueue({
        type: 'audio',
        sourceUpdater: this,
        action: actions.remove(start, end),
        doneFn: done,
        name: 'remove'
      });
    }
    ;
    _proto.removeVideo = function removeVideo(start, end, done) {
      if (done === void 0) {
        done = noop;
      }
      if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
        done();
        return;
      }
      pushQueue({
        type: 'video',
        sourceUpdater: this,
        action: actions.remove(start, end),
        doneFn: done,
        name: 'remove'
      });
    }
    ;
    _proto.updating = function updating() {
      if (_updating('audio', this) || _updating('video', this)) {
        return true;
      }
      return false;
    }
    ;
    _proto.audioTimestampOffset = function audioTimestampOffset(offset) {
      if (typeof offset !== 'undefined' && this.audioBuffer &&
      this.audioTimestampOffset_ !== offset) {
        pushQueue({
          type: 'audio',
          sourceUpdater: this,
          action: actions.timestampOffset(offset),
          name: 'timestampOffset'
        });
        this.audioTimestampOffset_ = offset;
      }
      return this.audioTimestampOffset_;
    }
    ;
    _proto.videoTimestampOffset = function videoTimestampOffset(offset) {
      if (typeof offset !== 'undefined' && this.videoBuffer &&
      this.videoTimestampOffset !== offset) {
        pushQueue({
          type: 'video',
          sourceUpdater: this,
          action: actions.timestampOffset(offset),
          name: 'timestampOffset'
        });
        this.videoTimestampOffset_ = offset;
      }
      return this.videoTimestampOffset_;
    }
    ;
    _proto.audioQueueCallback = function audioQueueCallback(callback) {
      if (!this.audioBuffer) {
        return;
      }
      pushQueue({
        type: 'audio',
        sourceUpdater: this,
        action: actions.callback(callback),
        name: 'callback'
      });
    }
    ;
    _proto.videoQueueCallback = function videoQueueCallback(callback) {
      if (!this.videoBuffer) {
        return;
      }
      pushQueue({
        type: 'video',
        sourceUpdater: this,
        action: actions.callback(callback),
        name: 'callback'
      });
    }
    ;
    _proto.dispose = function dispose() {
      var _this4 = this;
      this.trigger('dispose');
      bufferTypes.forEach(function (type) {
        _this4.abort(type);
        if (_this4.canRemoveSourceBuffer()) {
          _this4.removeSourceBuffer(type);
        } else {
          _this4[type + "QueueCallback"](function () {
            return cleanupBuffer(type, _this4);
          });
        }
      });
      this.videoAppendQueued_ = false;
      this.delayedAudioAppendQueue_.length = 0;
      if (this.sourceopenListener_) {
        this.mediaSource.removeEventListener('sourceopen', this.sourceopenListener_);
      }
      this.off();
    };
    return SourceUpdater;
  }(videojs.EventTarget);
  var uint8ToUtf8 = function uint8ToUtf8(uintArray) {
    return decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));
  };
  var VTT_LINE_TERMINATORS = new Uint8Array('\n\n'.split('').map(function (_char3) {
    return _char3.charCodeAt(0);
  }));
  var VTTSegmentLoader = function (_SegmentLoader) {
    inheritsLoose(VTTSegmentLoader, _SegmentLoader);
    function VTTSegmentLoader(settings, options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      _this = _SegmentLoader.call(this, settings, options) || this;
      _this.mediaSource_ = null;
      _this.subtitlesTrack_ = null;
      _this.loaderType_ = 'subtitle';
      _this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks;
      _this.shouldSaveSegmentTimingInfo_ = false;
      return _this;
    }
    var _proto = VTTSegmentLoader.prototype;
    _proto.createTransmuxer_ = function createTransmuxer_() {
      return null;
    }
    ;
    _proto.buffered_ = function buffered_() {
      if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) {
        return videojs.createTimeRanges();
      }
      var cues = this.subtitlesTrack_.cues;
      var start = cues[0].startTime;
      var end = cues[cues.length - 1].startTime;
      return videojs.createTimeRanges([[start, end]]);
    }
    ;
    _proto.initSegmentForMap = function initSegmentForMap(map, set) {
      if (set === void 0) {
        set = false;
      }
      if (!map) {
        return null;
      }
      var id = initSegmentId(map);
      var storedMap = this.initSegments_[id];
      if (set && !storedMap && map.bytes) {
        var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;
        var combinedSegment = new Uint8Array(combinedByteLength);
        combinedSegment.set(map.bytes);
        combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);
        this.initSegments_[id] = storedMap = {
          resolvedUri: map.resolvedUri,
          byterange: map.byterange,
          bytes: combinedSegment
        };
      }
      return storedMap || map;
    }
    ;
    _proto.couldBeginLoading_ = function couldBeginLoading_() {
      return this.playlist_ && this.subtitlesTrack_ && !this.paused();
    }
    ;
    _proto.init_ = function init_() {
      this.state = 'READY';
      this.resetEverything();
      return this.monitorBuffer_();
    }
    ;
    _proto.track = function track(_track) {
      if (typeof _track === 'undefined') {
        return this.subtitlesTrack_;
      }
      this.subtitlesTrack_ = _track;
      if (this.state === 'INIT' && this.couldBeginLoading_()) {
        this.init_();
      }
      return this.subtitlesTrack_;
    }
    ;
    _proto.remove = function remove(start, end) {
      removeCuesFromTrack(start, end, this.subtitlesTrack_);
    }
    ;
    _proto.fillBuffer_ = function fillBuffer_() {
      var _this2 = this;
      var segmentInfo = this.chooseNextRequest_();
      if (!segmentInfo) {
        return;
      }
      if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {
        var checkTimestampOffset = function checkTimestampOffset() {
          _this2.state = 'READY';
          if (!_this2.paused()) {
            _this2.monitorBuffer_();
          }
        };
        this.syncController_.one('timestampoffset', checkTimestampOffset);
        this.state = 'WAITING_ON_TIMELINE';
        return;
      }
      this.loadSegment_(segmentInfo);
    }
    ;
    _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_() {
      return null;
    };
    _proto.chooseNextRequest_ = function chooseNextRequest_() {
      return this.skipEmptySegments_(_SegmentLoader.prototype.chooseNextRequest_.call(this));
    }
    ;
    _proto.skipEmptySegments_ = function skipEmptySegments_(segmentInfo) {
      while (segmentInfo && segmentInfo.segment.empty) {
        if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {
          segmentInfo = null;
          break;
        }
        segmentInfo = this.generateSegmentInfo_({
          playlist: segmentInfo.playlist,
          mediaIndex: segmentInfo.mediaIndex + 1,
          startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,
          isSyncRequest: segmentInfo.isSyncRequest
        });
      }
      return segmentInfo;
    };
    _proto.stopForError = function stopForError(error) {
      this.error(error);
      this.state = 'READY';
      this.pause();
      this.trigger('error');
    }
    ;
    _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {
      var _this3 = this;
      if (!this.subtitlesTrack_) {
        this.state = 'READY';
        return;
      }
      this.saveTransferStats_(simpleSegment.stats);
      if (!this.pendingSegment_) {
        this.state = 'READY';
        this.mediaRequestsAborted += 1;
        return;
      }
      if (error) {
        if (error.code === REQUEST_ERRORS.TIMEOUT) {
          this.handleTimeout_();
        }
        if (error.code === REQUEST_ERRORS.ABORTED) {
          this.mediaRequestsAborted += 1;
        } else {
          this.mediaRequestsErrored += 1;
        }
        this.stopForError(error);
        return;
      }
      var segmentInfo = this.pendingSegment_;
      this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
      this.state = 'APPENDING';
      this.trigger('appending');
      var segment = segmentInfo.segment;
      if (segment.map) {
        segment.map.bytes = simpleSegment.map.bytes;
      }
      segmentInfo.bytes = simpleSegment.bytes;
      if (typeof window.WebVTT !== 'function' && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {
        var loadHandler;
        var errorHandler = function errorHandler() {
          _this3.subtitlesTrack_.tech_.off('vttjsloaded', loadHandler);
          _this3.stopForError({
            message: 'Error loading vtt.js'
          });
          return;
        };
        loadHandler = function loadHandler() {
          _this3.subtitlesTrack_.tech_.off('vttjserror', errorHandler);
          _this3.segmentRequestFinished_(error, simpleSegment, result);
        };
        this.state = 'WAITING_ON_VTTJS';
        this.subtitlesTrack_.tech_.one('vttjsloaded', loadHandler);
        this.subtitlesTrack_.tech_.one('vttjserror', errorHandler);
        return;
      }
      segment.requested = true;
      try {
        this.parseVTTCues_(segmentInfo);
      } catch (e) {
        this.stopForError({
          message: e.message
        });
        return;
      }
      this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);
      if (segmentInfo.cues.length) {
        segmentInfo.timingInfo = {
          start: segmentInfo.cues[0].startTime,
          end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime
        };
      } else {
        segmentInfo.timingInfo = {
          start: segmentInfo.startOfSegment,
          end: segmentInfo.startOfSegment + segmentInfo.duration
        };
      }
      if (segmentInfo.isSyncRequest) {
        this.trigger('syncinfoupdate');
        this.pendingSegment_ = null;
        this.state = 'READY';
        return;
      }
      segmentInfo.byteLength = segmentInfo.bytes.byteLength;
      this.mediaSecondsLoaded += segment.duration;
      segmentInfo.cues.forEach(function (cue) {
        _this3.subtitlesTrack_.addCue(_this3.featuresNativeTextTracks_ ? new window.VTTCue(cue.startTime, cue.endTime, cue.text) : cue);
      });
      removeDuplicateCuesFromTrack(this.subtitlesTrack_);
      this.handleAppendsDone_();
    };
    _proto.handleData_ = function handleData_() {
    };
    _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_() {
    }
    ;
    _proto.parseVTTCues_ = function parseVTTCues_(segmentInfo) {
      var decoder;
      var decodeBytesToString = false;
      if (typeof window.TextDecoder === 'function') {
        decoder = new window.TextDecoder('utf8');
      } else {
        decoder = window.WebVTT.StringDecoder();
        decodeBytesToString = true;
      }
      var parser = new window.WebVTT.Parser(window, window.vttjs, decoder);
      segmentInfo.cues = [];
      segmentInfo.timestampmap = {
        MPEGTS: 0,
        LOCAL: 0
      };
      parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);
      parser.ontimestampmap = function (map) {
        segmentInfo.timestampmap = map;
      };
      parser.onparsingerror = function (error) {
        videojs.log.warn('Error encountered when parsing cues: ' + error.message);
      };
      if (segmentInfo.segment.map) {
        var mapData = segmentInfo.segment.map.bytes;
        if (decodeBytesToString) {
          mapData = uint8ToUtf8(mapData);
        }
        parser.parse(mapData);
      }
      var segmentData = segmentInfo.bytes;
      if (decodeBytesToString) {
        segmentData = uint8ToUtf8(segmentData);
      }
      parser.parse(segmentData);
      parser.flush();
    }
    ;
    _proto.updateTimeMapping_ = function updateTimeMapping_(segmentInfo, mappingObj, playlist) {
      var segment = segmentInfo.segment;
      if (!mappingObj) {
        return;
      }
      if (!segmentInfo.cues.length) {
        segment.empty = true;
        return;
      }
      var timestampmap = segmentInfo.timestampmap;
      var diff = timestampmap.MPEGTS / clock_1 - timestampmap.LOCAL + mappingObj.mapping;
      segmentInfo.cues.forEach(function (cue) {
        cue.startTime += diff;
        cue.endTime += diff;
      });
      if (!playlist.syncInfo) {
        var firstStart = segmentInfo.cues[0].startTime;
        var lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;
        playlist.syncInfo = {
          mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,
          time: Math.min(firstStart, lastStart - segment.duration)
        };
      }
    };
    return VTTSegmentLoader;
  }(SegmentLoader);
  var findAdCue = function findAdCue(track, mediaTime) {
    var cues = track.cues;
    for (var i = 0; i < cues.length; i++) {
      var cue = cues[i];
      if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {
        return cue;
      }
    }
    return null;
  };
  var updateAdCues = function updateAdCues(media, track, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    if (!media.segments) {
      return;
    }
    var mediaTime = offset;
    var cue;
    for (var i = 0; i < media.segments.length; i++) {
      var segment = media.segments[i];
      if (!cue) {
        cue = findAdCue(track, mediaTime + segment.duration / 2);
      }
      if (cue) {
        if ('cueIn' in segment) {
          cue.endTime = mediaTime;
          cue.adEndTime = mediaTime;
          mediaTime += segment.duration;
          cue = null;
          continue;
        }
        if (mediaTime < cue.endTime) {
          mediaTime += segment.duration;
          continue;
        }
        cue.endTime += segment.duration;
      } else {
        if ('cueOut' in segment) {
          cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);
          cue.adStartTime = mediaTime;
          cue.adEndTime = mediaTime + parseFloat(segment.cueOut);
          track.addCue(cue);
        }
        if ('cueOutCont' in segment) {
          var _segment$cueOutCont$s = segment.cueOutCont.split('/').map(parseFloat),
              adOffset = _segment$cueOutCont$s[0],
              adTotal = _segment$cueOutCont$s[1];
          cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, '');
          cue.adStartTime = mediaTime - adOffset;
          cue.adEndTime = cue.adStartTime + adTotal;
          track.addCue(cue);
        }
      }
      mediaTime += segment.duration;
    }
  };
  var MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;
  var syncPointStrategies = [
  {
    name: 'VOD',
    run: function run(syncController, playlist, duration, currentTimeline, currentTime) {
      if (duration !== Infinity) {
        var syncPoint = {
          time: 0,
          segmentIndex: 0,
          partIndex: null
        };
        return syncPoint;
      }
      return null;
    }
  },
  {
    name: 'ProgramDateTime',
    run: function run(syncController, playlist, duration, currentTimeline, currentTime) {
      if (!Object.keys(syncController.timelineToDatetimeMappings).length) {
        return null;
      }
      var syncPoint = null;
      var lastDistance = null;
      var partsAndSegments = getPartsAndSegments(playlist);
      currentTime = currentTime || 0;
      for (var i = 0; i < partsAndSegments.length; i++) {
        var index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
        var partAndSegment = partsAndSegments[index];
        var segment = partAndSegment.segment;
        var datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];
        if (!datetimeMapping || !segment.dateTimeObject) {
          continue;
        }
        var segmentTime = segment.dateTimeObject.getTime() / 1000;
        var start = segmentTime + datetimeMapping;
        if (segment.parts && typeof partAndSegment.partIndex === 'number') {
          for (var z = 0; z < partAndSegment.partIndex; z++) {
            start += segment.parts[z].duration;
          }
        }
        var distance = Math.abs(currentTime - start);
        if (lastDistance !== null && (distance === 0 || lastDistance < distance)) {
          break;
        }
        lastDistance = distance;
        syncPoint = {
          time: start,
          segmentIndex: partAndSegment.segmentIndex,
          partIndex: partAndSegment.partIndex
        };
      }
      return syncPoint;
    }
  },
  {
    name: 'Segment',
    run: function run(syncController, playlist, duration, currentTimeline, currentTime) {
      var syncPoint = null;
      var lastDistance = null;
      currentTime = currentTime || 0;
      var partsAndSegments = getPartsAndSegments(playlist);
      for (var i = 0; i < partsAndSegments.length; i++) {
        var index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
        var partAndSegment = partsAndSegments[index];
        var segment = partAndSegment.segment;
        var start = partAndSegment.part && partAndSegment.part.start || segment && segment.start;
        if (segment.timeline === currentTimeline && typeof start !== 'undefined') {
          var distance = Math.abs(currentTime - start);
          if (lastDistance !== null && lastDistance < distance) {
            break;
          }
          if (!syncPoint || lastDistance === null || lastDistance >= distance) {
            lastDistance = distance;
            syncPoint = {
              time: start,
              segmentIndex: partAndSegment.segmentIndex,
              partIndex: partAndSegment.partIndex
            };
          }
        }
      }
      return syncPoint;
    }
  },
  {
    name: 'Discontinuity',
    run: function run(syncController, playlist, duration, currentTimeline, currentTime) {
      var syncPoint = null;
      currentTime = currentTime || 0;
      if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
        var lastDistance = null;
        for (var i = 0; i < playlist.discontinuityStarts.length; i++) {
          var segmentIndex = playlist.discontinuityStarts[i];
          var discontinuity = playlist.discontinuitySequence + i + 1;
          var discontinuitySync = syncController.discontinuities[discontinuity];
          if (discontinuitySync) {
            var distance = Math.abs(currentTime - discontinuitySync.time);
            if (lastDistance !== null && lastDistance < distance) {
              break;
            }
            if (!syncPoint || lastDistance === null || lastDistance >= distance) {
              lastDistance = distance;
              syncPoint = {
                time: discontinuitySync.time,
                segmentIndex: segmentIndex,
                partIndex: null
              };
            }
          }
        }
      }
      return syncPoint;
    }
  },
  {
    name: 'Playlist',
    run: function run(syncController, playlist, duration, currentTimeline, currentTime) {
      if (playlist.syncInfo) {
        var syncPoint = {
          time: playlist.syncInfo.time,
          segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,
          partIndex: null
        };
        return syncPoint;
      }
      return null;
    }
  }];
  var SyncController = function (_videojs$EventTarget) {
    inheritsLoose(SyncController, _videojs$EventTarget);
    function SyncController(options) {
      var _this;
      _this = _videojs$EventTarget.call(this) || this;
      _this.timelines = [];
      _this.discontinuities = [];
      _this.timelineToDatetimeMappings = {};
      _this.logger_ = logger('SyncController');
      return _this;
    }
    var _proto = SyncController.prototype;
    _proto.getSyncPoint = function getSyncPoint(playlist, duration, currentTimeline, currentTime) {
      var syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime);
      if (!syncPoints.length) {
        return null;
      }
      return this.selectSyncPoint_(syncPoints, {
        key: 'time',
        value: currentTime
      });
    }
    ;
    _proto.getExpiredTime = function getExpiredTime(playlist, duration) {
      if (!playlist || !playlist.segments) {
        return null;
      }
      var syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0);
      if (!syncPoints.length) {
        return null;
      }
      var syncPoint = this.selectSyncPoint_(syncPoints, {
        key: 'segmentIndex',
        value: 0
      });
      if (syncPoint.segmentIndex > 0) {
        syncPoint.time *= -1;
      }
      return Math.abs(syncPoint.time + sumDurations({
        defaultDuration: playlist.targetDuration,
        durationList: playlist.segments,
        startIndex: syncPoint.segmentIndex,
        endIndex: 0
      }));
    }
    ;
    _proto.runStrategies_ = function runStrategies_(playlist, duration, currentTimeline, currentTime) {
      var syncPoints = [];
      for (var i = 0; i < syncPointStrategies.length; i++) {
        var strategy = syncPointStrategies[i];
        var syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime);
        if (syncPoint) {
          syncPoint.strategy = strategy.name;
          syncPoints.push({
            strategy: strategy.name,
            syncPoint: syncPoint
          });
        }
      }
      return syncPoints;
    }
    ;
    _proto.selectSyncPoint_ = function selectSyncPoint_(syncPoints, target) {
      var bestSyncPoint = syncPoints[0].syncPoint;
      var bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);
      var bestStrategy = syncPoints[0].strategy;
      for (var i = 1; i < syncPoints.length; i++) {
        var newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          bestSyncPoint = syncPoints[i].syncPoint;
          bestStrategy = syncPoints[i].strategy;
        }
      }
      this.logger_("syncPoint for [" + target.key + ": " + target.value + "] chosen with strategy" + (" [" + bestStrategy + "]: [time:" + bestSyncPoint.time + ",") + (" segmentIndex:" + bestSyncPoint.segmentIndex) + (typeof bestSyncPoint.partIndex === 'number' ? ",partIndex:" + bestSyncPoint.partIndex : '') + ']');
      return bestSyncPoint;
    }
    ;
    _proto.saveExpiredSegmentInfo = function saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {
      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
      if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {
        videojs.log.warn("Not saving expired segment info. Media sequence gap " + mediaSequenceDiff + " is too large.");
        return;
      }
      for (var i = mediaSequenceDiff - 1; i >= 0; i--) {
        var lastRemovedSegment = oldPlaylist.segments[i];
        if (lastRemovedSegment && typeof lastRemovedSegment.start !== 'undefined') {
          newPlaylist.syncInfo = {
            mediaSequence: oldPlaylist.mediaSequence + i,
            time: lastRemovedSegment.start
          };
          this.logger_("playlist refresh sync: [time:" + newPlaylist.syncInfo.time + "," + (" mediaSequence: " + newPlaylist.syncInfo.mediaSequence + "]"));
          this.trigger('syncinfoupdate');
          break;
        }
      }
    }
    ;
    _proto.setDateTimeMappingForStart = function setDateTimeMappingForStart(playlist) {
      this.timelineToDatetimeMappings = {};
      if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {
        var firstSegment = playlist.segments[0];
        var playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1000;
        this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;
      }
    }
    ;
    _proto.saveSegmentTimingInfo = function saveSegmentTimingInfo(_ref) {
      var segmentInfo = _ref.segmentInfo,
          shouldSaveTimelineMapping = _ref.shouldSaveTimelineMapping;
      var didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);
      var segment = segmentInfo.segment;
      if (didCalculateSegmentTimeMapping) {
        this.saveDiscontinuitySyncInfo_(segmentInfo);
        if (!segmentInfo.playlist.syncInfo) {
          segmentInfo.playlist.syncInfo = {
            mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,
            time: segment.start
          };
        }
      }
      var dateTime = segment.dateTimeObject;
      if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) {
        this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1000);
      }
    };
    _proto.timestampOffsetForTimeline = function timestampOffsetForTimeline(timeline) {
      if (typeof this.timelines[timeline] === 'undefined') {
        return null;
      }
      return this.timelines[timeline].time;
    };
    _proto.mappingForTimeline = function mappingForTimeline(timeline) {
      if (typeof this.timelines[timeline] === 'undefined') {
        return null;
      }
      return this.timelines[timeline].mapping;
    }
    ;
    _proto.calculateSegmentTimeMapping_ = function calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {
      var segment = segmentInfo.segment;
      var part = segmentInfo.part;
      var mappingObj = this.timelines[segmentInfo.timeline];
      var start;
      var end;
      if (typeof segmentInfo.timestampOffset === 'number') {
        mappingObj = {
          time: segmentInfo.startOfSegment,
          mapping: segmentInfo.startOfSegment - timingInfo.start
        };
        if (shouldSaveTimelineMapping) {
          this.timelines[segmentInfo.timeline] = mappingObj;
          this.trigger('timestampoffset');
          this.logger_("time mapping for timeline " + segmentInfo.timeline + ": " + ("[time: " + mappingObj.time + "] [mapping: " + mappingObj.mapping + "]"));
        }
        start = segmentInfo.startOfSegment;
        end = timingInfo.end + mappingObj.mapping;
      } else if (mappingObj) {
        start = timingInfo.start + mappingObj.mapping;
        end = timingInfo.end + mappingObj.mapping;
      } else {
        return false;
      }
      if (part) {
        part.start = start;
        part.end = end;
      }
      if (!segment.start || start < segment.start) {
        segment.start = start;
      }
      segment.end = end;
      return true;
    }
    ;
    _proto.saveDiscontinuitySyncInfo_ = function saveDiscontinuitySyncInfo_(segmentInfo) {
      var playlist = segmentInfo.playlist;
      var segment = segmentInfo.segment;
      if (segment.discontinuity) {
        this.discontinuities[segment.timeline] = {
          time: segment.start,
          accuracy: 0
        };
      } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
        for (var i = 0; i < playlist.discontinuityStarts.length; i++) {
          var segmentIndex = playlist.discontinuityStarts[i];
          var discontinuity = playlist.discontinuitySequence + i + 1;
          var mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;
          var accuracy = Math.abs(mediaIndexDiff);
          if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {
            var time = void 0;
            if (mediaIndexDiff < 0) {
              time = segment.start - sumDurations({
                defaultDuration: playlist.targetDuration,
                durationList: playlist.segments,
                startIndex: segmentInfo.mediaIndex,
                endIndex: segmentIndex
              });
            } else {
              time = segment.end + sumDurations({
                defaultDuration: playlist.targetDuration,
                durationList: playlist.segments,
                startIndex: segmentInfo.mediaIndex + 1,
                endIndex: segmentIndex
              });
            }
            this.discontinuities[discontinuity] = {
              time: time,
              accuracy: accuracy
            };
          }
        }
      }
    };
    _proto.dispose = function dispose() {
      this.trigger('dispose');
      this.off();
    };
    return SyncController;
  }(videojs.EventTarget);
  var TimelineChangeController = function (_videojs$EventTarget) {
    inheritsLoose(TimelineChangeController, _videojs$EventTarget);
    function TimelineChangeController() {
      var _this;
      _this = _videojs$EventTarget.call(this) || this;
      _this.pendingTimelineChanges_ = {};
      _this.lastTimelineChanges_ = {};
      return _this;
    }
    var _proto = TimelineChangeController.prototype;
    _proto.clearPendingTimelineChange = function clearPendingTimelineChange(type) {
      this.pendingTimelineChanges_[type] = null;
      this.trigger('pendingtimelinechange');
    };
    _proto.pendingTimelineChange = function pendingTimelineChange(_ref) {
      var type = _ref.type,
          from = _ref.from,
          to = _ref.to;
      if (typeof from === 'number' && typeof to === 'number') {
        this.pendingTimelineChanges_[type] = {
          type: type,
          from: from,
          to: to
        };
        this.trigger('pendingtimelinechange');
      }
      return this.pendingTimelineChanges_[type];
    };
    _proto.lastTimelineChange = function lastTimelineChange(_ref2) {
      var type = _ref2.type,
          from = _ref2.from,
          to = _ref2.to;
      if (typeof from === 'number' && typeof to === 'number') {
        this.lastTimelineChanges_[type] = {
          type: type,
          from: from,
          to: to
        };
        delete this.pendingTimelineChanges_[type];
        this.trigger('timelinechange');
      }
      return this.lastTimelineChanges_[type];
    };
    _proto.dispose = function dispose() {
      this.trigger('dispose');
      this.pendingTimelineChanges_ = {};
      this.lastTimelineChanges_ = {};
      this.off();
    };
    return TimelineChangeController;
  }(videojs.EventTarget);
  var workerCode = transform(getWorkerString(function () {
    function createCommonjsModule(fn, basedir, module) {
      return module = {
        path: basedir,
        exports: {},
        require: function require(path, base) {
          return commonjsRequire(path, base === undefined || base === null ? module.path : base);
        }
      }, fn(module, module.exports), module.exports;
    }
    function commonjsRequire() {
      throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }
    var createClass = createCommonjsModule(function (module) {
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      module.exports = _createClass;
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    });
    var setPrototypeOf = createCommonjsModule(function (module) {
      function _setPrototypeOf(o, p) {
        module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
        module.exports["default"] = module.exports, module.exports.__esModule = true;
        return _setPrototypeOf(o, p);
      }
      module.exports = _setPrototypeOf;
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    });
    var inheritsLoose = createCommonjsModule(function (module) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        setPrototypeOf(subClass, superClass);
      }
      module.exports = _inheritsLoose;
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    });
    var Stream = function () {
      function Stream() {
        this.listeners = {};
      }
      var _proto = Stream.prototype;
      _proto.on = function on(type, listener) {
        if (!this.listeners[type]) {
          this.listeners[type] = [];
        }
        this.listeners[type].push(listener);
      }
      ;
      _proto.off = function off(type, listener) {
        if (!this.listeners[type]) {
          return false;
        }
        var index = this.listeners[type].indexOf(listener);
        this.listeners[type] = this.listeners[type].slice(0);
        this.listeners[type].splice(index, 1);
        return index > -1;
      }
      ;
      _proto.trigger = function trigger(type) {
        var callbacks = this.listeners[type];
        if (!callbacks) {
          return;
        }
        if (arguments.length === 2) {
          var length = callbacks.length;
          for (var i = 0; i < length; ++i) {
            callbacks[i].call(this, arguments[1]);
          }
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var _length = callbacks.length;
          for (var _i = 0; _i < _length; ++_i) {
            callbacks[_i].apply(this, args);
          }
        }
      }
      ;
      _proto.dispose = function dispose() {
        this.listeners = {};
      }
      ;
      _proto.pipe = function pipe(destination) {
        this.on('data', function (data) {
          destination.push(data);
        });
      };
      return Stream;
    }();
    /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */
    function unpad(padded) {
      return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
    }
    /*! @name aes-decrypter @version 3.1.2 @license Apache-2.0 */
    var precompute = function precompute() {
      var tables = [[[], [], [], [], []], [[], [], [], [], []]];
      var encTable = tables[0];
      var decTable = tables[1];
      var sbox = encTable[4];
      var sboxInv = decTable[4];
      var i;
      var x;
      var xInv;
      var d = [];
      var th = [];
      var x2;
      var x4;
      var x8;
      var s;
      var tEnc;
      var tDec;
      for (i = 0; i < 256; i++) {
        th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
      }
      for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
        s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
        s = s >> 8 ^ s & 255 ^ 99;
        sbox[x] = s;
        sboxInv[s] = x;
        x8 = d[x4 = d[x2 = d[x]]];
        tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        tEnc = d[s] * 0x101 ^ s * 0x1010100;
        for (i = 0; i < 4; i++) {
          encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
          decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
        }
      }
      for (i = 0; i < 5; i++) {
        encTable[i] = encTable[i].slice(0);
        decTable[i] = decTable[i].slice(0);
      }
      return tables;
    };
    var aesTables = null;
    var AES = function () {
      function AES(key) {
        if (!aesTables) {
          aesTables = precompute();
        }
        this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];
        var i;
        var j;
        var tmp;
        var sbox = this._tables[0][4];
        var decTable = this._tables[1];
        var keyLen = key.length;
        var rcon = 1;
        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
          throw new Error('Invalid aes key size');
        }
        var encKey = key.slice(0);
        var decKey = [];
        this._key = [encKey, decKey];
        for (i = keyLen; i < 4 * keyLen + 28; i++) {
          tmp = encKey[i - 1];
          if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
            tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
            if (i % keyLen === 0) {
              tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
              rcon = rcon << 1 ^ (rcon >> 7) * 283;
            }
          }
          encKey[i] = encKey[i - keyLen] ^ tmp;
        }
        for (j = 0; i; j++, i--) {
          tmp = encKey[j & 3 ? i : i - 4];
          if (i <= 4 || j < 4) {
            decKey[j] = tmp;
          } else {
            decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
          }
        }
      }
      var _proto = AES.prototype;
      _proto.decrypt = function decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {
        var key = this._key[1];
        var a = encrypted0 ^ key[0];
        var b = encrypted3 ^ key[1];
        var c = encrypted2 ^ key[2];
        var d = encrypted1 ^ key[3];
        var a2;
        var b2;
        var c2;
        var nInnerRounds = key.length / 4 - 2;
        var i;
        var kIndex = 4;
        var table = this._tables[1];
        var table0 = table[0];
        var table1 = table[1];
        var table2 = table[2];
        var table3 = table[3];
        var sbox = table[4];
        for (i = 0; i < nInnerRounds; i++) {
          a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];
          b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];
          c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];
          d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];
          kIndex += 4;
          a = a2;
          b = b2;
          c = c2;
        }
        for (i = 0; i < 4; i++) {
          out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
          a2 = a;
          a = b;
          b = c;
          c = d;
          d = a2;
        }
      };
      return AES;
    }();
    var AsyncStream = function (_Stream) {
      inheritsLoose(AsyncStream, _Stream);
      function AsyncStream() {
        var _this;
        _this = _Stream.call(this, Stream) || this;
        _this.jobs = [];
        _this.delay = 1;
        _this.timeout_ = null;
        return _this;
      }
      var _proto = AsyncStream.prototype;
      _proto.processJob_ = function processJob_() {
        this.jobs.shift()();
        if (this.jobs.length) {
          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
        } else {
          this.timeout_ = null;
        }
      }
      ;
      _proto.push = function push(job) {
        this.jobs.push(job);
        if (!this.timeout_) {
          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
        }
      };
      return AsyncStream;
    }(Stream);
    var ntoh = function ntoh(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    };
    var decrypt = function decrypt(encrypted, key, initVector) {
      var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);
      var decipher = new AES(Array.prototype.slice.call(key));
      var decrypted = new Uint8Array(encrypted.byteLength);
      var decrypted32 = new Int32Array(decrypted.buffer);
      var init0;
      var init1;
      var init2;
      var init3;
      var encrypted0;
      var encrypted1;
      var encrypted2;
      var encrypted3;
      var wordIx;
      init0 = initVector[0];
      init1 = initVector[1];
      init2 = initVector[2];
      init3 = initVector[3];
      for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
        encrypted0 = ntoh(encrypted32[wordIx]);
        encrypted1 = ntoh(encrypted32[wordIx + 1]);
        encrypted2 = ntoh(encrypted32[wordIx + 2]);
        encrypted3 = ntoh(encrypted32[wordIx + 3]);
        decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);
        decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);
        decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);
        decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);
        decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);
        init0 = encrypted0;
        init1 = encrypted1;
        init2 = encrypted2;
        init3 = encrypted3;
      }
      return decrypted;
    };
    var Decrypter = function () {
      function Decrypter(encrypted, key, initVector, done) {
        var step = Decrypter.STEP;
        var encrypted32 = new Int32Array(encrypted.buffer);
        var decrypted = new Uint8Array(encrypted.byteLength);
        var i = 0;
        this.asyncStream_ = new AsyncStream();
        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
        for (i = step; i < encrypted32.length; i += step) {
          initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);
          this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
        }
        this.asyncStream_.push(function () {
          done(null, unpad(decrypted));
        });
      }
      var _proto = Decrypter.prototype;
      _proto.decryptChunk_ = function decryptChunk_(encrypted, key, initVector, decrypted) {
        return function () {
          var bytes = decrypt(encrypted, key, initVector);
          decrypted.set(bytes, encrypted.byteOffset);
        };
      };
      createClass(Decrypter, null, [{
        key: "STEP",
        get: function get() {
          return 32000;
        }
      }]);
      return Decrypter;
    }();
    var createTransferableMessage = function createTransferableMessage(message) {
      var transferable = {};
      Object.keys(message).forEach(function (key) {
        var value = message[key];
        if (ArrayBuffer.isView(value)) {
          transferable[key] = {
            bytes: value.buffer,
            byteOffset: value.byteOffset,
            byteLength: value.byteLength
          };
        } else {
          transferable[key] = value;
        }
      });
      return transferable;
    };
    self.onmessage = function (event) {
      var data = event.data;
      var encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);
      var key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);
      var iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);
      new Decrypter(encrypted, key, iv, function (err, bytes) {
        self.postMessage(createTransferableMessage({
          source: data.source,
          decrypted: bytes
        }), [bytes.buffer]);
      });
    };
  }));
  var Decrypter = factory(workerCode);
  var audioTrackKind_ = function audioTrackKind_(properties) {
    var kind = properties["default"] ? 'main' : 'alternative';
    if (properties.characteristics && properties.characteristics.indexOf('public.accessibility.describes-video') >= 0) {
      kind = 'main-desc';
    }
    return kind;
  };
  var stopLoaders = function stopLoaders(segmentLoader, mediaType) {
    segmentLoader.abort();
    segmentLoader.pause();
    if (mediaType && mediaType.activePlaylistLoader) {
      mediaType.activePlaylistLoader.pause();
      mediaType.activePlaylistLoader = null;
    }
  };
  var startLoaders = function startLoaders(playlistLoader, mediaType) {
    mediaType.activePlaylistLoader = playlistLoader;
    playlistLoader.load();
  };
  var onGroupChanged = function onGroupChanged(type, settings) {
    return function () {
      var _settings$segmentLoad = settings.segmentLoaders,
          segmentLoader = _settings$segmentLoad[type],
          mainSegmentLoader = _settings$segmentLoad.main,
          mediaType = settings.mediaTypes[type];
      var activeTrack = mediaType.activeTrack();
      var activeGroup = mediaType.getActiveGroup();
      var previousActiveLoader = mediaType.activePlaylistLoader;
      var lastGroup = mediaType.lastGroup_;
      if (activeGroup && lastGroup && activeGroup.id === lastGroup.id) {
        return;
      }
      mediaType.lastGroup_ = activeGroup;
      mediaType.lastTrack_ = activeTrack;
      stopLoaders(segmentLoader, mediaType);
      if (!activeGroup || activeGroup.isMasterPlaylist) {
        return;
      }
      if (!activeGroup.playlistLoader) {
        if (previousActiveLoader) {
          mainSegmentLoader.resetEverything();
        }
        return;
      }
      segmentLoader.resyncLoader();
      startLoaders(activeGroup.playlistLoader, mediaType);
    };
  };
  var onGroupChanging = function onGroupChanging(type, settings) {
    return function () {
      var segmentLoader = settings.segmentLoaders[type],
          mediaType = settings.mediaTypes[type];
      mediaType.lastGroup_ = null;
      segmentLoader.abort();
      segmentLoader.pause();
    };
  };
  var onTrackChanged = function onTrackChanged(type, settings) {
    return function () {
      var masterPlaylistLoader = settings.masterPlaylistLoader,
          _settings$segmentLoad2 = settings.segmentLoaders,
          segmentLoader = _settings$segmentLoad2[type],
          mainSegmentLoader = _settings$segmentLoad2.main,
          mediaType = settings.mediaTypes[type];
      var activeTrack = mediaType.activeTrack();
      var activeGroup = mediaType.getActiveGroup();
      var previousActiveLoader = mediaType.activePlaylistLoader;
      var lastTrack = mediaType.lastTrack_;
      if (lastTrack && activeTrack && lastTrack.id === activeTrack.id) {
        return;
      }
      mediaType.lastGroup_ = activeGroup;
      mediaType.lastTrack_ = activeTrack;
      stopLoaders(segmentLoader, mediaType);
      if (!activeGroup) {
        return;
      }
      if (activeGroup.isMasterPlaylist) {
        if (!activeTrack || !lastTrack || activeTrack.id === lastTrack.id) {
          return;
        }
        var mpc = settings.vhs.masterPlaylistController_;
        var newPlaylist = mpc.selectPlaylist();
        if (mpc.media() === newPlaylist) {
          return;
        }
        mediaType.logger_("track change. Switching master audio from " + lastTrack.id + " to " + activeTrack.id);
        masterPlaylistLoader.pause();
        mainSegmentLoader.resetEverything();
        mpc.fastQualityChange_(newPlaylist);
        return;
      }
      if (type === 'AUDIO') {
        if (!activeGroup.playlistLoader) {
          mainSegmentLoader.setAudio(true);
          mainSegmentLoader.resetEverything();
          return;
        }
        segmentLoader.setAudio(true);
        mainSegmentLoader.setAudio(false);
      }
      if (previousActiveLoader === activeGroup.playlistLoader) {
        startLoaders(activeGroup.playlistLoader, mediaType);
        return;
      }
      if (segmentLoader.track) {
        segmentLoader.track(activeTrack);
      }
      segmentLoader.resetEverything();
      startLoaders(activeGroup.playlistLoader, mediaType);
    };
  };
  var onError = {
    AUDIO: function AUDIO(type, settings) {
      return function () {
        var segmentLoader = settings.segmentLoaders[type],
            mediaType = settings.mediaTypes[type],
            blacklistCurrentPlaylist = settings.blacklistCurrentPlaylist;
        stopLoaders(segmentLoader, mediaType);
        var activeTrack = mediaType.activeTrack();
        var activeGroup = mediaType.activeGroup();
        var id = (activeGroup.filter(function (group) {
          return group["default"];
        })[0] || activeGroup[0]).id;
        var defaultTrack = mediaType.tracks[id];
        if (activeTrack === defaultTrack) {
          blacklistCurrentPlaylist({
            message: 'Problem encountered loading the default audio track.'
          });
          return;
        }
        videojs.log.warn('Problem encountered loading the alternate audio track.' + 'Switching back to default.');
        for (var trackId in mediaType.tracks) {
          mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;
        }
        mediaType.onTrackChanged();
      };
    },
    SUBTITLES: function SUBTITLES(type, settings) {
      return function () {
        var segmentLoader = settings.segmentLoaders[type],
            mediaType = settings.mediaTypes[type];
        videojs.log.warn('Problem encountered loading the subtitle track.' + 'Disabling subtitle track.');
        stopLoaders(segmentLoader, mediaType);
        var track = mediaType.activeTrack();
        if (track) {
          track.mode = 'disabled';
        }
        mediaType.onTrackChanged();
      };
    }
  };
  var setupListeners = {
    AUDIO: function AUDIO(type, playlistLoader, settings) {
      if (!playlistLoader) {
        return;
      }
      var tech = settings.tech,
          requestOptions = settings.requestOptions,
          segmentLoader = settings.segmentLoaders[type];
      playlistLoader.on('loadedmetadata', function () {
        var media = playlistLoader.media();
        segmentLoader.playlist(media, requestOptions);
        if (!tech.paused() || media.endList && tech.preload() !== 'none') {
          segmentLoader.load();
        }
      });
      playlistLoader.on('loadedplaylist', function () {
        segmentLoader.playlist(playlistLoader.media(), requestOptions);
        if (!tech.paused()) {
          segmentLoader.load();
        }
      });
      playlistLoader.on('error', onError[type](type, settings));
    },
    SUBTITLES: function SUBTITLES(type, playlistLoader, settings) {
      var tech = settings.tech,
          requestOptions = settings.requestOptions,
          segmentLoader = settings.segmentLoaders[type],
          mediaType = settings.mediaTypes[type];
      playlistLoader.on('loadedmetadata', function () {
        var media = playlistLoader.media();
        segmentLoader.playlist(media, requestOptions);
        segmentLoader.track(mediaType.activeTrack());
        if (!tech.paused() || media.endList && tech.preload() !== 'none') {
          segmentLoader.load();
        }
      });
      playlistLoader.on('loadedplaylist', function () {
        segmentLoader.playlist(playlistLoader.media(), requestOptions);
        if (!tech.paused()) {
          segmentLoader.load();
        }
      });
      playlistLoader.on('error', onError[type](type, settings));
    }
  };
  var initialize = {
    'AUDIO': function AUDIO(type, settings) {
      var vhs = settings.vhs,
          sourceType = settings.sourceType,
          segmentLoader = settings.segmentLoaders[type],
          requestOptions = settings.requestOptions,
          mediaGroups = settings.master.mediaGroups,
          _settings$mediaTypes$ = settings.mediaTypes[type],
          groups = _settings$mediaTypes$.groups,
          tracks = _settings$mediaTypes$.tracks,
          logger_ = _settings$mediaTypes$.logger_,
          masterPlaylistLoader = settings.masterPlaylistLoader;
      var audioOnlyMaster = isAudioOnly(masterPlaylistLoader.master);
      if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {
        mediaGroups[type] = {
          main: {
            "default": {
              "default": true
            }
          }
        };
        if (audioOnlyMaster) {
          mediaGroups[type].main["default"].playlists = masterPlaylistLoader.master.playlists;
        }
      }
      for (var groupId in mediaGroups[type]) {
        if (!groups[groupId]) {
          groups[groupId] = [];
        }
        for (var variantLabel in mediaGroups[type][groupId]) {
          var properties = mediaGroups[type][groupId][variantLabel];
          var playlistLoader = void 0;
          if (audioOnlyMaster) {
            logger_("AUDIO group '" + groupId + "' label '" + variantLabel + "' is a master playlist");
            properties.isMasterPlaylist = true;
            playlistLoader = null;
          } else if (sourceType === 'vhs-json' && properties.playlists) {
            playlistLoader = new PlaylistLoader(properties.playlists[0], vhs, requestOptions);
          } else if (properties.resolvedUri) {
            playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);
          } else if (properties.playlists && sourceType === 'dash') {
            playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);
          } else {
            playlistLoader = null;
          }
          properties = videojs.mergeOptions({
            id: variantLabel,
            playlistLoader: playlistLoader
          }, properties);
          setupListeners[type](type, properties.playlistLoader, settings);
          groups[groupId].push(properties);
          if (typeof tracks[variantLabel] === 'undefined') {
            var track = new videojs.AudioTrack({
              id: variantLabel,
              kind: audioTrackKind_(properties),
              enabled: false,
              language: properties.language,
              "default": properties["default"],
              label: variantLabel
            });
            tracks[variantLabel] = track;
          }
        }
      }
      segmentLoader.on('error', onError[type](type, settings));
    },
    'SUBTITLES': function SUBTITLES(type, settings) {
      var tech = settings.tech,
          vhs = settings.vhs,
          sourceType = settings.sourceType,
          segmentLoader = settings.segmentLoaders[type],
          requestOptions = settings.requestOptions,
          mediaGroups = settings.master.mediaGroups,
          _settings$mediaTypes$2 = settings.mediaTypes[type],
          groups = _settings$mediaTypes$2.groups,
          tracks = _settings$mediaTypes$2.tracks,
          masterPlaylistLoader = settings.masterPlaylistLoader;
      for (var groupId in mediaGroups[type]) {
        if (!groups[groupId]) {
          groups[groupId] = [];
        }
        for (var variantLabel in mediaGroups[type][groupId]) {
          if (mediaGroups[type][groupId][variantLabel].forced) {
            continue;
          }
          var properties = mediaGroups[type][groupId][variantLabel];
          var playlistLoader = void 0;
          if (sourceType === 'hls') {
            playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);
          } else if (sourceType === 'dash') {
            var playlists = properties.playlists.filter(function (p) {
              return p.excludeUntil !== Infinity;
            });
            if (!playlists.length) {
              return;
            }
            playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);
          } else if (sourceType === 'vhs-json') {
            playlistLoader = new PlaylistLoader(
            properties.playlists ? properties.playlists[0] : properties.resolvedUri, vhs, requestOptions);
          }
          properties = videojs.mergeOptions({
            id: variantLabel,
            playlistLoader: playlistLoader
          }, properties);
          setupListeners[type](type, properties.playlistLoader, settings);
          groups[groupId].push(properties);
          if (typeof tracks[variantLabel] === 'undefined') {
            var track = tech.addRemoteTextTrack({
              id: variantLabel,
              kind: 'subtitles',
              "default": properties["default"] && properties.autoselect,
              language: properties.language,
              label: variantLabel
            }, false).track;
            tracks[variantLabel] = track;
          }
        }
      }
      segmentLoader.on('error', onError[type](type, settings));
    },
    'CLOSED-CAPTIONS': function CLOSEDCAPTIONS(type, settings) {
      var tech = settings.tech,
          mediaGroups = settings.master.mediaGroups,
          _settings$mediaTypes$3 = settings.mediaTypes[type],
          groups = _settings$mediaTypes$3.groups,
          tracks = _settings$mediaTypes$3.tracks;
      for (var groupId in mediaGroups[type]) {
        if (!groups[groupId]) {
          groups[groupId] = [];
        }
        for (var variantLabel in mediaGroups[type][groupId]) {
          var properties = mediaGroups[type][groupId][variantLabel];
          if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) {
            continue;
          }
          var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
          var newProps = {
            label: variantLabel,
            language: properties.language,
            instreamId: properties.instreamId,
            "default": properties["default"] && properties.autoselect
          };
          if (captionServices[newProps.instreamId]) {
            newProps = videojs.mergeOptions(newProps, captionServices[newProps.instreamId]);
          }
          if (newProps["default"] === undefined) {
            delete newProps["default"];
          }
          groups[groupId].push(videojs.mergeOptions({
            id: variantLabel
          }, properties));
          if (typeof tracks[variantLabel] === 'undefined') {
            var track = tech.addRemoteTextTrack({
              id: newProps.instreamId,
              kind: 'captions',
              "default": newProps["default"],
              language: newProps.language,
              label: newProps.label
            }, false).track;
            tracks[variantLabel] = track;
          }
        }
      }
    }
  };
  var groupMatch = function groupMatch(list, media) {
    for (var i = 0; i < list.length; i++) {
      if (playlistMatch(media, list[i])) {
        return true;
      }
      if (list[i].playlists && groupMatch(list[i].playlists, media)) {
        return true;
      }
    }
    return false;
  };
  var activeGroup = function activeGroup(type, settings) {
    return function (track) {
      var masterPlaylistLoader = settings.masterPlaylistLoader,
          groups = settings.mediaTypes[type].groups;
      var media = masterPlaylistLoader.media();
      if (!media) {
        return null;
      }
      var variants = null;
      if (media.attributes[type]) {
        variants = groups[media.attributes[type]];
      }
      var groupKeys = Object.keys(groups);
      if (!variants) {
        if (type === 'AUDIO' && groupKeys.length > 1 && isAudioOnly(settings.master)) {
          for (var i = 0; i < groupKeys.length; i++) {
            var groupPropertyList = groups[groupKeys[i]];
            if (groupMatch(groupPropertyList, media)) {
              variants = groupPropertyList;
              break;
            }
          }
        } else if (groups.main) {
          variants = groups.main;
        } else if (groupKeys.length === 1) {
          variants = groups[groupKeys[0]];
        }
      }
      if (typeof track === 'undefined') {
        return variants;
      }
      if (track === null || !variants) {
        return null;
      }
      return variants.filter(function (props) {
        return props.id === track.id;
      })[0] || null;
    };
  };
  var activeTrack = {
    AUDIO: function AUDIO(type, settings) {
      return function () {
        var tracks = settings.mediaTypes[type].tracks;
        for (var id in tracks) {
          if (tracks[id].enabled) {
            return tracks[id];
          }
        }
        return null;
      };
    },
    SUBTITLES: function SUBTITLES(type, settings) {
      return function () {
        var tracks = settings.mediaTypes[type].tracks;
        for (var id in tracks) {
          if (tracks[id].mode === 'showing' || tracks[id].mode === 'hidden') {
            return tracks[id];
          }
        }
        return null;
      };
    }
  };
  var getActiveGroup = function getActiveGroup(type, _ref) {
    var mediaTypes = _ref.mediaTypes;
    return function () {
      var activeTrack_ = mediaTypes[type].activeTrack();
      if (!activeTrack_) {
        return null;
      }
      return mediaTypes[type].activeGroup(activeTrack_);
    };
  };
  var setupMediaGroups = function setupMediaGroups(settings) {
    ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {
      initialize[type](type, settings);
    });
    var mediaTypes = settings.mediaTypes,
        masterPlaylistLoader = settings.masterPlaylistLoader,
        tech = settings.tech,
        vhs = settings.vhs,
        _settings$segmentLoad3 = settings.segmentLoaders,
        audioSegmentLoader = _settings$segmentLoad3['AUDIO'],
        mainSegmentLoader = _settings$segmentLoad3.main;
    ['AUDIO', 'SUBTITLES'].forEach(function (type) {
      mediaTypes[type].activeGroup = activeGroup(type, settings);
      mediaTypes[type].activeTrack = activeTrack[type](type, settings);
      mediaTypes[type].onGroupChanged = onGroupChanged(type, settings);
      mediaTypes[type].onGroupChanging = onGroupChanging(type, settings);
      mediaTypes[type].onTrackChanged = onTrackChanged(type, settings);
      mediaTypes[type].getActiveGroup = getActiveGroup(type, settings);
    });
    var audioGroup = mediaTypes.AUDIO.activeGroup();
    if (audioGroup) {
      var groupId = (audioGroup.filter(function (group) {
        return group["default"];
      })[0] || audioGroup[0]).id;
      mediaTypes.AUDIO.tracks[groupId].enabled = true;
      mediaTypes.AUDIO.onGroupChanged();
      mediaTypes.AUDIO.onTrackChanged();
      var activeAudioGroup = mediaTypes.AUDIO.getActiveGroup();
      if (!activeAudioGroup.playlistLoader) {
        mainSegmentLoader.setAudio(true);
      } else {
        mainSegmentLoader.setAudio(false);
        audioSegmentLoader.setAudio(true);
      }
    }
    masterPlaylistLoader.on('mediachange', function () {
      ['AUDIO', 'SUBTITLES'].forEach(function (type) {
        return mediaTypes[type].onGroupChanged();
      });
    });
    masterPlaylistLoader.on('mediachanging', function () {
      ['AUDIO', 'SUBTITLES'].forEach(function (type) {
        return mediaTypes[type].onGroupChanging();
      });
    });
    var onAudioTrackChanged = function onAudioTrackChanged() {
      mediaTypes.AUDIO.onTrackChanged();
      tech.trigger({
        type: 'usage',
        name: 'vhs-audio-change'
      });
      tech.trigger({
        type: 'usage',
        name: 'hls-audio-change'
      });
    };
    tech.audioTracks().addEventListener('change', onAudioTrackChanged);
    tech.remoteTextTracks().addEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);
    vhs.on('dispose', function () {
      tech.audioTracks().removeEventListener('change', onAudioTrackChanged);
      tech.remoteTextTracks().removeEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);
    });
    tech.clearTracks('audio');
    for (var id in mediaTypes.AUDIO.tracks) {
      tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);
    }
  };
  var createMediaTypes = function createMediaTypes() {
    var mediaTypes = {};
    ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {
      mediaTypes[type] = {
        groups: {},
        tracks: {},
        activePlaylistLoader: null,
        activeGroup: noop,
        activeTrack: noop,
        getActiveGroup: noop,
        onGroupChanged: noop,
        onTrackChanged: noop,
        lastTrack_: null,
        logger_: logger("MediaGroups[" + type + "]")
      };
    });
    return mediaTypes;
  };
  var ABORT_EARLY_BLACKLIST_SECONDS = 60 * 2;
  var Vhs$1;
  var loaderStats = ['mediaRequests', 'mediaRequestsAborted', 'mediaRequestsTimedout', 'mediaRequestsErrored', 'mediaTransferDuration', 'mediaBytesTransferred', 'mediaAppends'];
  var sumLoaderStat = function sumLoaderStat(stat) {
    return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];
  };
  var shouldSwitchToMedia = function shouldSwitchToMedia(_ref) {
    var currentPlaylist = _ref.currentPlaylist,
        buffered = _ref.buffered,
        currentTime = _ref.currentTime,
        nextPlaylist = _ref.nextPlaylist,
        bufferLowWaterLine = _ref.bufferLowWaterLine,
        bufferHighWaterLine = _ref.bufferHighWaterLine,
        duration = _ref.duration,
        experimentalBufferBasedABR = _ref.experimentalBufferBasedABR,
        log = _ref.log;
    if (!nextPlaylist) {
      videojs.log.warn('We received no playlist to switch to. Please check your stream.');
      return false;
    }
    var sharedLogLine = "allowing switch " + (currentPlaylist && currentPlaylist.id || 'null') + " -> " + nextPlaylist.id;
    if (!currentPlaylist) {
      log(sharedLogLine + " as current playlist is not set");
      return true;
    }
    if (nextPlaylist.id === currentPlaylist.id) {
      return false;
    }
    var isBuffered = Boolean(findRange(buffered, currentTime).length);
    if (!currentPlaylist.endList) {
      if (!isBuffered && typeof currentPlaylist.partTargetDuration === 'number') {
        log("not " + sharedLogLine + " as current playlist is live llhls, but currentTime isn't in buffered.");
        return false;
      }
      log(sharedLogLine + " as current playlist is live");
      return true;
    }
    var forwardBuffer = timeAheadOf(buffered, currentTime);
    var maxBufferLowWaterLine = experimentalBufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE;
    if (duration < maxBufferLowWaterLine) {
      log(sharedLogLine + " as duration < max low water line (" + duration + " < " + maxBufferLowWaterLine + ")");
      return true;
    }
    var nextBandwidth = nextPlaylist.attributes.BANDWIDTH;
    var currBandwidth = currentPlaylist.attributes.BANDWIDTH;
    if (nextBandwidth < currBandwidth && (!experimentalBufferBasedABR || forwardBuffer < bufferHighWaterLine)) {
      var logLine = sharedLogLine + " as next bandwidth < current bandwidth (" + nextBandwidth + " < " + currBandwidth + ")";
      if (experimentalBufferBasedABR) {
        logLine += " and forwardBuffer < bufferHighWaterLine (" + forwardBuffer + " < " + bufferHighWaterLine + ")";
      }
      log(logLine);
      return true;
    }
    if ((!experimentalBufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {
      var _logLine = sharedLogLine + " as forwardBuffer >= bufferLowWaterLine (" + forwardBuffer + " >= " + bufferLowWaterLine + ")";
      if (experimentalBufferBasedABR) {
        _logLine += " and next bandwidth > current bandwidth (" + nextBandwidth + " > " + currBandwidth + ")";
      }
      log(_logLine);
      return true;
    }
    log("not " + sharedLogLine + " as no switching criteria met");
    return false;
  };
  var MasterPlaylistController = function (_videojs$EventTarget) {
    inheritsLoose(MasterPlaylistController, _videojs$EventTarget);
    function MasterPlaylistController(options) {
      var _this;
      _this = _videojs$EventTarget.call(this) || this;
      var src = options.src,
          handleManifestRedirects = options.handleManifestRedirects,
          withCredentials = options.withCredentials,
          tech = options.tech,
          bandwidth = options.bandwidth,
          externVhs = options.externVhs,
          useCueTags = options.useCueTags,
          blacklistDuration = options.blacklistDuration,
          enableLowInitialPlaylist = options.enableLowInitialPlaylist,
          sourceType = options.sourceType,
          cacheEncryptionKeys = options.cacheEncryptionKeys,
          experimentalBufferBasedABR = options.experimentalBufferBasedABR,
          experimentalLeastPixelDiffSelector = options.experimentalLeastPixelDiffSelector,
          captionServices = options.captionServices;
      if (!src) {
        throw new Error('A non-empty playlist URL or JSON manifest string is required');
      }
      var maxPlaylistRetries = options.maxPlaylistRetries;
      if (maxPlaylistRetries === null || typeof maxPlaylistRetries === 'undefined') {
        maxPlaylistRetries = Infinity;
      }
      Vhs$1 = externVhs;
      _this.experimentalBufferBasedABR = Boolean(experimentalBufferBasedABR);
      _this.experimentalLeastPixelDiffSelector = Boolean(experimentalLeastPixelDiffSelector);
      _this.withCredentials = withCredentials;
      _this.tech_ = tech;
      _this.vhs_ = tech.vhs;
      _this.sourceType_ = sourceType;
      _this.useCueTags_ = useCueTags;
      _this.blacklistDuration = blacklistDuration;
      _this.maxPlaylistRetries = maxPlaylistRetries;
      _this.enableLowInitialPlaylist = enableLowInitialPlaylist;
      if (_this.useCueTags_) {
        _this.cueTagsTrack_ = _this.tech_.addTextTrack('metadata', 'ad-cues');
        _this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';
      }
      _this.requestOptions_ = {
        withCredentials: withCredentials,
        handleManifestRedirects: handleManifestRedirects,
        maxPlaylistRetries: maxPlaylistRetries,
        timeout: null
      };
      _this.on('error', _this.pauseLoading);
      _this.mediaTypes_ = createMediaTypes();
      _this.mediaSource = new window.MediaSource();
      _this.handleDurationChange_ = _this.handleDurationChange_.bind(assertThisInitialized(_this));
      _this.handleSourceOpen_ = _this.handleSourceOpen_.bind(assertThisInitialized(_this));
      _this.handleSourceEnded_ = _this.handleSourceEnded_.bind(assertThisInitialized(_this));
      _this.mediaSource.addEventListener('durationchange', _this.handleDurationChange_);
      _this.mediaSource.addEventListener('sourceopen', _this.handleSourceOpen_);
      _this.mediaSource.addEventListener('sourceended', _this.handleSourceEnded_);
      _this.seekable_ = videojs.createTimeRanges();
      _this.hasPlayed_ = false;
      _this.syncController_ = new SyncController(options);
      _this.segmentMetadataTrack_ = tech.addRemoteTextTrack({
        kind: 'metadata',
        label: 'segment-metadata'
      }, false).track;
      _this.decrypter_ = new Decrypter();
      _this.sourceUpdater_ = new SourceUpdater(_this.mediaSource);
      _this.inbandTextTracks_ = {};
      _this.timelineChangeController_ = new TimelineChangeController();
      var segmentLoaderSettings = {
        vhs: _this.vhs_,
        parse708captions: options.parse708captions,
        captionServices: captionServices,
        mediaSource: _this.mediaSource,
        currentTime: _this.tech_.currentTime.bind(_this.tech_),
        seekable: function seekable() {
          return _this.seekable();
        },
        seeking: function seeking() {
          return _this.tech_.seeking();
        },
        duration: function duration() {
          return _this.duration();
        },
        hasPlayed: function hasPlayed() {
          return _this.hasPlayed_;
        },
        goalBufferLength: function goalBufferLength() {
          return _this.goalBufferLength();
        },
        bandwidth: bandwidth,
        syncController: _this.syncController_,
        decrypter: _this.decrypter_,
        sourceType: _this.sourceType_,
        inbandTextTracks: _this.inbandTextTracks_,
        cacheEncryptionKeys: cacheEncryptionKeys,
        sourceUpdater: _this.sourceUpdater_,
        timelineChangeController: _this.timelineChangeController_,
        experimentalExactManifestTimings: options.experimentalExactManifestTimings
      };
      _this.masterPlaylistLoader_ = _this.sourceType_ === 'dash' ? new DashPlaylistLoader(src, _this.vhs_, _this.requestOptions_) : new PlaylistLoader(src, _this.vhs_, _this.requestOptions_);
      _this.setupMasterPlaylistLoaderListeners_();
      _this.mainSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
        segmentMetadataTrack: _this.segmentMetadataTrack_,
        loaderType: 'main'
      }), options);
      _this.audioSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
        loaderType: 'audio'
      }), options);
      _this.subtitleSegmentLoader_ = new VTTSegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
        loaderType: 'vtt',
        featuresNativeTextTracks: _this.tech_.featuresNativeTextTracks
      }), options);
      _this.setupSegmentLoaderListeners_();
      if (_this.experimentalBufferBasedABR) {
        _this.masterPlaylistLoader_.one('loadedplaylist', function () {
          return _this.startABRTimer_();
        });
        _this.tech_.on('pause', function () {
          return _this.stopABRTimer_();
        });
        _this.tech_.on('play', function () {
          return _this.startABRTimer_();
        });
      }
      loaderStats.forEach(function (stat) {
        _this[stat + '_'] = sumLoaderStat.bind(assertThisInitialized(_this), stat);
      });
      _this.logger_ = logger('MPC');
      _this.triggeredFmp4Usage = false;
      if (_this.tech_.preload() === 'none') {
        _this.loadOnPlay_ = function () {
          _this.loadOnPlay_ = null;
          _this.masterPlaylistLoader_.load();
        };
        _this.tech_.one('play', _this.loadOnPlay_);
      } else {
        _this.masterPlaylistLoader_.load();
      }
      _this.timeToLoadedData__ = -1;
      _this.mainAppendsToLoadedData__ = -1;
      _this.audioAppendsToLoadedData__ = -1;
      var event = _this.tech_.preload() === 'none' ? 'play' : 'loadstart';
      _this.tech_.one(event, function () {
        var timeToLoadedDataStart = Date.now();
        _this.tech_.one('loadeddata', function () {
          _this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;
          _this.mainAppendsToLoadedData__ = _this.mainSegmentLoader_.mediaAppends;
          _this.audioAppendsToLoadedData__ = _this.audioSegmentLoader_.mediaAppends;
        });
      });
      return _this;
    }
    var _proto = MasterPlaylistController.prototype;
    _proto.mainAppendsToLoadedData_ = function mainAppendsToLoadedData_() {
      return this.mainAppendsToLoadedData__;
    };
    _proto.audioAppendsToLoadedData_ = function audioAppendsToLoadedData_() {
      return this.audioAppendsToLoadedData__;
    };
    _proto.appendsToLoadedData_ = function appendsToLoadedData_() {
      var main = this.mainAppendsToLoadedData_();
      var audio = this.audioAppendsToLoadedData_();
      if (main === -1 || audio === -1) {
        return -1;
      }
      return main + audio;
    };
    _proto.timeToLoadedData_ = function timeToLoadedData_() {
      return this.timeToLoadedData__;
    }
    ;
    _proto.checkABR_ = function checkABR_() {
      var nextPlaylist = this.selectPlaylist();
      if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) {
        this.switchMedia_(nextPlaylist, 'abr');
      }
    };
    _proto.switchMedia_ = function switchMedia_(playlist, cause, delay) {
      var oldMedia = this.media();
      var oldId = oldMedia && (oldMedia.id || oldMedia.uri);
      var newId = playlist.id || playlist.uri;
      if (oldId && oldId !== newId) {
        this.logger_("switch media " + oldId + " -> " + newId + " from " + cause);
        this.tech_.trigger({
          type: 'usage',
          name: "vhs-rendition-change-" + cause
        });
      }
      this.masterPlaylistLoader_.media(playlist, delay);
    }
    ;
    _proto.startABRTimer_ = function startABRTimer_() {
      var _this2 = this;
      this.stopABRTimer_();
      this.abrTimer_ = window.setInterval(function () {
        return _this2.checkABR_();
      }, 250);
    }
    ;
    _proto.stopABRTimer_ = function stopABRTimer_() {
      if (this.tech_.scrubbing && this.tech_.scrubbing()) {
        return;
      }
      window.clearInterval(this.abrTimer_);
      this.abrTimer_ = null;
    }
    ;
    _proto.getAudioTrackPlaylists_ = function getAudioTrackPlaylists_() {
      var master = this.master();
      var defaultPlaylists = master && master.playlists || [];
      if (!master || !master.mediaGroups || !master.mediaGroups.AUDIO) {
        return defaultPlaylists;
      }
      var AUDIO = master.mediaGroups.AUDIO;
      var groupKeys = Object.keys(AUDIO);
      var track;
      if (Object.keys(this.mediaTypes_.AUDIO.groups).length) {
        track = this.mediaTypes_.AUDIO.activeTrack();
      } else {
        var defaultGroup = AUDIO.main || groupKeys.length && AUDIO[groupKeys[0]];
        for (var label in defaultGroup) {
          if (defaultGroup[label]["default"]) {
            track = {
              label: label
            };
            break;
          }
        }
      }
      if (!track) {
        return defaultPlaylists;
      }
      var playlists = [];
      for (var group in AUDIO) {
        if (AUDIO[group][track.label]) {
          var properties = AUDIO[group][track.label];
          if (properties.playlists && properties.playlists.length) {
            playlists.push.apply(playlists, properties.playlists);
          } else if (properties.uri) {
            playlists.push(properties);
          } else if (master.playlists.length) {
            for (var i = 0; i < master.playlists.length; i++) {
              var playlist = master.playlists[i];
              if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) {
                playlists.push(playlist);
              }
            }
          }
        }
      }
      if (!playlists.length) {
        return defaultPlaylists;
      }
      return playlists;
    }
    ;
    _proto.setupMasterPlaylistLoaderListeners_ = function setupMasterPlaylistLoaderListeners_() {
      var _this3 = this;
      this.masterPlaylistLoader_.on('loadedmetadata', function () {
        var media = _this3.masterPlaylistLoader_.media();
        var requestTimeout = media.targetDuration * 1.5 * 1000;
        if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {
          _this3.requestOptions_.timeout = 0;
        } else {
          _this3.requestOptions_.timeout = requestTimeout;
        }
        if (media.endList && _this3.tech_.preload() !== 'none') {
          _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);
          _this3.mainSegmentLoader_.load();
        }
        setupMediaGroups({
          sourceType: _this3.sourceType_,
          segmentLoaders: {
            AUDIO: _this3.audioSegmentLoader_,
            SUBTITLES: _this3.subtitleSegmentLoader_,
            main: _this3.mainSegmentLoader_
          },
          tech: _this3.tech_,
          requestOptions: _this3.requestOptions_,
          masterPlaylistLoader: _this3.masterPlaylistLoader_,
          vhs: _this3.vhs_,
          master: _this3.master(),
          mediaTypes: _this3.mediaTypes_,
          blacklistCurrentPlaylist: _this3.blacklistCurrentPlaylist.bind(_this3)
        });
        _this3.triggerPresenceUsage_(_this3.master(), media);
        _this3.setupFirstPlay();
        if (!_this3.mediaTypes_.AUDIO.activePlaylistLoader || _this3.mediaTypes_.AUDIO.activePlaylistLoader.media()) {
          _this3.trigger('selectedinitialmedia');
        } else {
          _this3.mediaTypes_.AUDIO.activePlaylistLoader.one('loadedmetadata', function () {
            _this3.trigger('selectedinitialmedia');
          });
        }
      });
      this.masterPlaylistLoader_.on('loadedplaylist', function () {
        if (_this3.loadOnPlay_) {
          _this3.tech_.off('play', _this3.loadOnPlay_);
        }
        var updatedPlaylist = _this3.masterPlaylistLoader_.media();
        if (!updatedPlaylist) {
          _this3.excludeUnsupportedVariants_();
          var selectedMedia;
          if (_this3.enableLowInitialPlaylist) {
            selectedMedia = _this3.selectInitialPlaylist();
          }
          if (!selectedMedia) {
            selectedMedia = _this3.selectPlaylist();
          }
          if (!selectedMedia || !_this3.shouldSwitchToMedia_(selectedMedia)) {
            return;
          }
          _this3.initialMedia_ = selectedMedia;
          _this3.switchMedia_(_this3.initialMedia_, 'initial');
          var haveJsonSource = _this3.sourceType_ === 'vhs-json' && _this3.initialMedia_.segments;
          if (!haveJsonSource) {
            return;
          }
          updatedPlaylist = _this3.initialMedia_;
        }
        _this3.handleUpdatedMediaPlaylist(updatedPlaylist);
      });
      this.masterPlaylistLoader_.on('error', function () {
        _this3.blacklistCurrentPlaylist(_this3.masterPlaylistLoader_.error);
      });
      this.masterPlaylistLoader_.on('mediachanging', function () {
        _this3.mainSegmentLoader_.abort();
        _this3.mainSegmentLoader_.pause();
      });
      this.masterPlaylistLoader_.on('mediachange', function () {
        var media = _this3.masterPlaylistLoader_.media();
        var requestTimeout = media.targetDuration * 1.5 * 1000;
        if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {
          _this3.requestOptions_.timeout = 0;
        } else {
          _this3.requestOptions_.timeout = requestTimeout;
        }
        _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);
        _this3.mainSegmentLoader_.load();
        _this3.tech_.trigger({
          type: 'mediachange',
          bubbles: true
        });
      });
      this.masterPlaylistLoader_.on('playlistunchanged', function () {
        var updatedPlaylist = _this3.masterPlaylistLoader_.media();
        if (updatedPlaylist.lastExcludeReason_ === 'playlist-unchanged') {
          return;
        }
        var playlistOutdated = _this3.stuckAtPlaylistEnd_(updatedPlaylist);
        if (playlistOutdated) {
          _this3.blacklistCurrentPlaylist({
            message: 'Playlist no longer updating.',
            reason: 'playlist-unchanged'
          });
          _this3.tech_.trigger('playliststuck');
        }
      });
      this.masterPlaylistLoader_.on('renditiondisabled', function () {
        _this3.tech_.trigger({
          type: 'usage',
          name: 'vhs-rendition-disabled'
        });
        _this3.tech_.trigger({
          type: 'usage',
          name: 'hls-rendition-disabled'
        });
      });
      this.masterPlaylistLoader_.on('renditionenabled', function () {
        _this3.tech_.trigger({
          type: 'usage',
          name: 'vhs-rendition-enabled'
        });
        _this3.tech_.trigger({
          type: 'usage',
          name: 'hls-rendition-enabled'
        });
      });
    }
    ;
    _proto.handleUpdatedMediaPlaylist = function handleUpdatedMediaPlaylist(updatedPlaylist) {
      if (this.useCueTags_) {
        this.updateAdCues_(updatedPlaylist);
      }
      this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);
      this.updateDuration(!updatedPlaylist.endList);
      if (!this.tech_.paused()) {
        this.mainSegmentLoader_.load();
        if (this.audioSegmentLoader_) {
          this.audioSegmentLoader_.load();
        }
      }
    }
    ;
    _proto.triggerPresenceUsage_ = function triggerPresenceUsage_(master, media) {
      var mediaGroups = master.mediaGroups || {};
      var defaultDemuxed = true;
      var audioGroupKeys = Object.keys(mediaGroups.AUDIO);
      for (var mediaGroup in mediaGroups.AUDIO) {
        for (var label in mediaGroups.AUDIO[mediaGroup]) {
          var properties = mediaGroups.AUDIO[mediaGroup][label];
          if (!properties.uri) {
            defaultDemuxed = false;
          }
        }
      }
      if (defaultDemuxed) {
        this.tech_.trigger({
          type: 'usage',
          name: 'vhs-demuxed'
        });
        this.tech_.trigger({
          type: 'usage',
          name: 'hls-demuxed'
        });
      }
      if (Object.keys(mediaGroups.SUBTITLES).length) {
        this.tech_.trigger({
          type: 'usage',
          name: 'vhs-webvtt'
        });
        this.tech_.trigger({
          type: 'usage',
          name: 'hls-webvtt'
        });
      }
      if (Vhs$1.Playlist.isAes(media)) {
        this.tech_.trigger({
          type: 'usage',
          name: 'vhs-aes'
        });
        this.tech_.trigger({
          type: 'usage',
          name: 'hls-aes'
        });
      }
      if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {
        this.tech_.trigger({
          type: 'usage',
          name: 'vhs-alternate-audio'
        });
        this.tech_.trigger({
          type: 'usage',
          name: 'hls-alternate-audio'
        });
      }
      if (this.useCueTags_) {
        this.tech_.trigger({
          type: 'usage',
          name: 'vhs-playlist-cue-tags'
        });
        this.tech_.trigger({
          type: 'usage',
          name: 'hls-playlist-cue-tags'
        });
      }
    };
    _proto.shouldSwitchToMedia_ = function shouldSwitchToMedia_(nextPlaylist) {
      var currentPlaylist = this.masterPlaylistLoader_.media() || this.masterPlaylistLoader_.pendingMedia_;
      var currentTime = this.tech_.currentTime();
      var bufferLowWaterLine = this.bufferLowWaterLine();
      var bufferHighWaterLine = this.bufferHighWaterLine();
      var buffered = this.tech_.buffered();
      return shouldSwitchToMedia({
        buffered: buffered,
        currentTime: currentTime,
        currentPlaylist: currentPlaylist,
        nextPlaylist: nextPlaylist,
        bufferLowWaterLine: bufferLowWaterLine,
        bufferHighWaterLine: bufferHighWaterLine,
        duration: this.duration(),
        experimentalBufferBasedABR: this.experimentalBufferBasedABR,
        log: this.logger_
      });
    }
    ;
    _proto.setupSegmentLoaderListeners_ = function setupSegmentLoaderListeners_() {
      var _this4 = this;
      if (!this.experimentalBufferBasedABR) {
        this.mainSegmentLoader_.on('bandwidthupdate', function () {
          var nextPlaylist = _this4.selectPlaylist();
          if (_this4.shouldSwitchToMedia_(nextPlaylist)) {
            _this4.switchMedia_(nextPlaylist, 'bandwidthupdate');
          }
          _this4.tech_.trigger('bandwidthupdate');
        });
        this.mainSegmentLoader_.on('progress', function () {
          _this4.trigger('progress');
        });
      }
      this.mainSegmentLoader_.on('error', function () {
        _this4.blacklistCurrentPlaylist(_this4.mainSegmentLoader_.error());
      });
      this.mainSegmentLoader_.on('appenderror', function () {
        _this4.error = _this4.mainSegmentLoader_.error_;
        _this4.trigger('error');
      });
      this.mainSegmentLoader_.on('syncinfoupdate', function () {
        _this4.onSyncInfoUpdate_();
      });
      this.mainSegmentLoader_.on('timestampoffset', function () {
        _this4.tech_.trigger({
          type: 'usage',
          name: 'vhs-timestamp-offset'
        });
        _this4.tech_.trigger({
          type: 'usage',
          name: 'hls-timestamp-offset'
        });
      });
      this.audioSegmentLoader_.on('syncinfoupdate', function () {
        _this4.onSyncInfoUpdate_();
      });
      this.audioSegmentLoader_.on('appenderror', function () {
        _this4.error = _this4.audioSegmentLoader_.error_;
        _this4.trigger('error');
      });
      this.mainSegmentLoader_.on('ended', function () {
        _this4.logger_('main segment loader ended');
        _this4.onEndOfStream();
      });
      this.mainSegmentLoader_.on('earlyabort', function (event) {
        if (_this4.experimentalBufferBasedABR) {
          return;
        }
        _this4.delegateLoaders_('all', ['abort']);
        _this4.blacklistCurrentPlaylist({
          message: 'Aborted early because there isn\'t enough bandwidth to complete the ' + 'request without rebuffering.'
        }, ABORT_EARLY_BLACKLIST_SECONDS);
      });
      var updateCodecs = function updateCodecs() {
        if (!_this4.sourceUpdater_.hasCreatedSourceBuffers()) {
          return _this4.tryToCreateSourceBuffers_();
        }
        var codecs = _this4.getCodecsOrExclude_();
        if (!codecs) {
          return;
        }
        _this4.sourceUpdater_.addOrChangeSourceBuffers(codecs);
      };
      this.mainSegmentLoader_.on('trackinfo', updateCodecs);
      this.audioSegmentLoader_.on('trackinfo', updateCodecs);
      this.mainSegmentLoader_.on('fmp4', function () {
        if (!_this4.triggeredFmp4Usage) {
          _this4.tech_.trigger({
            type: 'usage',
            name: 'vhs-fmp4'
          });
          _this4.tech_.trigger({
            type: 'usage',
            name: 'hls-fmp4'
          });
          _this4.triggeredFmp4Usage = true;
        }
      });
      this.audioSegmentLoader_.on('fmp4', function () {
        if (!_this4.triggeredFmp4Usage) {
          _this4.tech_.trigger({
            type: 'usage',
            name: 'vhs-fmp4'
          });
          _this4.tech_.trigger({
            type: 'usage',
            name: 'hls-fmp4'
          });
          _this4.triggeredFmp4Usage = true;
        }
      });
      this.audioSegmentLoader_.on('ended', function () {
        _this4.logger_('audioSegmentLoader ended');
        _this4.onEndOfStream();
      });
    };
    _proto.mediaSecondsLoaded_ = function mediaSecondsLoaded_() {
      return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
    }
    ;
    _proto.load = function load() {
      this.mainSegmentLoader_.load();
      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
        this.audioSegmentLoader_.load();
      }
      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
        this.subtitleSegmentLoader_.load();
      }
    }
    ;
    _proto.smoothQualityChange_ = function smoothQualityChange_(media) {
      if (media === void 0) {
        media = this.selectPlaylist();
      }
      this.fastQualityChange_(media);
    }
    ;
    _proto.fastQualityChange_ = function fastQualityChange_(media) {
      var _this5 = this;
      if (media === void 0) {
        media = this.selectPlaylist();
      }
      if (media === this.masterPlaylistLoader_.media()) {
        this.logger_('skipping fastQualityChange because new media is same as old');
        return;
      }
      this.switchMedia_(media, 'fast-quality');
      this.mainSegmentLoader_.resetEverything(function () {
        if (videojs.browser.IE_VERSION || videojs.browser.IS_EDGE) {
          _this5.tech_.setCurrentTime(_this5.tech_.currentTime() + 0.04);
        } else {
          _this5.tech_.setCurrentTime(_this5.tech_.currentTime());
        }
      });
    }
    ;
    _proto.play = function play() {
      if (this.setupFirstPlay()) {
        return;
      }
      if (this.tech_.ended()) {
        this.tech_.setCurrentTime(0);
      }
      if (this.hasPlayed_) {
        this.load();
      }
      var seekable = this.tech_.seekable();
      if (this.tech_.duration() === Infinity) {
        if (this.tech_.currentTime() < seekable.start(0)) {
          return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));
        }
      }
    }
    ;
    _proto.setupFirstPlay = function setupFirstPlay() {
      var _this6 = this;
      var media = this.masterPlaylistLoader_.media();
      if (!media || this.tech_.paused() || this.hasPlayed_) {
        return false;
      }
      if (!media.endList) {
        var seekable = this.seekable();
        if (!seekable.length) {
          return false;
        }
        if (videojs.browser.IE_VERSION && this.tech_.readyState() === 0) {
          this.tech_.one('loadedmetadata', function () {
            _this6.trigger('firstplay');
            _this6.tech_.setCurrentTime(seekable.end(0));
            _this6.hasPlayed_ = true;
          });
          return false;
        }
        this.trigger('firstplay');
        this.tech_.setCurrentTime(seekable.end(0));
      }
      this.hasPlayed_ = true;
      this.load();
      return true;
    }
    ;
    _proto.handleSourceOpen_ = function handleSourceOpen_() {
      this.tryToCreateSourceBuffers_();
      if (this.tech_.autoplay()) {
        var playPromise = this.tech_.play();
        if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {
          playPromise.then(null, function (e) {});
        }
      }
      this.trigger('sourceopen');
    }
    ;
    _proto.handleSourceEnded_ = function handleSourceEnded_() {
      if (!this.inbandTextTracks_.metadataTrack_) {
        return;
      }
      var cues = this.inbandTextTracks_.metadataTrack_.cues;
      if (!cues || !cues.length) {
        return;
      }
      var duration = this.duration();
      cues[cues.length - 1].endTime = isNaN(duration) || Math.abs(duration) === Infinity ? Number.MAX_VALUE : duration;
    }
    ;
    _proto.handleDurationChange_ = function handleDurationChange_() {
      this.tech_.trigger('durationchange');
    }
    ;
    _proto.onEndOfStream = function onEndOfStream() {
      var isEndOfStream = this.mainSegmentLoader_.ended_;
      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
        var mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_();
        if (!mainMediaInfo || mainMediaInfo.hasVideo) {
          isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;
        } else {
          isEndOfStream = this.audioSegmentLoader_.ended_;
        }
      }
      if (!isEndOfStream) {
        return;
      }
      this.stopABRTimer_();
      this.sourceUpdater_.endOfStream();
    }
    ;
    _proto.stuckAtPlaylistEnd_ = function stuckAtPlaylistEnd_(playlist) {
      var seekable = this.seekable();
      if (!seekable.length) {
        return false;
      }
      var expired = this.syncController_.getExpiredTime(playlist, this.duration());
      if (expired === null) {
        return false;
      }
      var absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);
      var currentTime = this.tech_.currentTime();
      var buffered = this.tech_.buffered();
      if (!buffered.length) {
        return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;
      }
      var bufferedEnd = buffered.end(buffered.length - 1);
      return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;
    }
    ;
    _proto.blacklistCurrentPlaylist = function blacklistCurrentPlaylist(error, blacklistDuration) {
      if (error === void 0) {
        error = {};
      }
      var currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();
      blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration;
      if (!currentPlaylist) {
        this.error = error;
        if (this.mediaSource.readyState !== 'open') {
          this.trigger('error');
        } else {
          this.sourceUpdater_.endOfStream('network');
        }
        return;
      }
      currentPlaylist.playlistErrors_++;
      var playlists = this.masterPlaylistLoader_.master.playlists;
      var enabledPlaylists = playlists.filter(isEnabled);
      var isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === currentPlaylist;
      if (playlists.length === 1 && blacklistDuration !== Infinity) {
        videojs.log.warn("Problem encountered with playlist " + currentPlaylist.id + ". " + 'Trying again since it is the only playlist.');
        this.tech_.trigger('retryplaylist');
        return this.masterPlaylistLoader_.load(isFinalRendition);
      }
      if (isFinalRendition) {
        var reincluded = false;
        playlists.forEach(function (playlist) {
          if (playlist === currentPlaylist) {
            return;
          }
          var excludeUntil = playlist.excludeUntil;
          if (typeof excludeUntil !== 'undefined' && excludeUntil !== Infinity) {
            reincluded = true;
            delete playlist.excludeUntil;
          }
        });
        if (reincluded) {
          videojs.log.warn('Removing other playlists from the exclusion list because the last ' + 'rendition is about to be excluded.');
          this.tech_.trigger('retryplaylist');
        }
      }
      var excludeUntil;
      if (currentPlaylist.playlistErrors_ > this.maxPlaylistRetries) {
        excludeUntil = Infinity;
      } else {
        excludeUntil = Date.now() + blacklistDuration * 1000;
      }
      currentPlaylist.excludeUntil = excludeUntil;
      if (error.reason) {
        currentPlaylist.lastExcludeReason_ = error.reason;
      }
      this.tech_.trigger('blacklistplaylist');
      this.tech_.trigger({
        type: 'usage',
        name: 'vhs-rendition-blacklisted'
      });
      this.tech_.trigger({
        type: 'usage',
        name: 'hls-rendition-blacklisted'
      });
      var nextPlaylist = this.selectPlaylist();
      if (!nextPlaylist) {
        this.error = 'Playback cannot continue. No available working or supported playlists.';
        this.trigger('error');
        return;
      }
      var logFn = error.internal ? this.logger_ : videojs.log.warn;
      var errorMessage = error.message ? ' ' + error.message : '';
      logFn((error.internal ? 'Internal problem' : 'Problem') + " encountered with playlist " + currentPlaylist.id + "." + (errorMessage + " Switching to playlist " + nextPlaylist.id + "."));
      if (nextPlaylist.attributes.AUDIO !== currentPlaylist.attributes.AUDIO) {
        this.delegateLoaders_('audio', ['abort', 'pause']);
      }
      if (nextPlaylist.attributes.SUBTITLES !== currentPlaylist.attributes.SUBTITLES) {
        this.delegateLoaders_('subtitle', ['abort', 'pause']);
      }
      this.delegateLoaders_('main', ['abort', 'pause']);
      var delayDuration = nextPlaylist.targetDuration / 2 * 1000 || 5 * 1000;
      var shouldDelay = typeof nextPlaylist.lastRequest === 'number' && Date.now() - nextPlaylist.lastRequest <= delayDuration;
      return this.switchMedia_(nextPlaylist, 'exclude', isFinalRendition || shouldDelay);
    }
    ;
    _proto.pauseLoading = function pauseLoading() {
      this.delegateLoaders_('all', ['abort', 'pause']);
      this.stopABRTimer_();
    }
    ;
    _proto.delegateLoaders_ = function delegateLoaders_(filter, fnNames) {
      var _this7 = this;
      var loaders = [];
      var dontFilterPlaylist = filter === 'all';
      if (dontFilterPlaylist || filter === 'main') {
        loaders.push(this.masterPlaylistLoader_);
      }
      var mediaTypes = [];
      if (dontFilterPlaylist || filter === 'audio') {
        mediaTypes.push('AUDIO');
      }
      if (dontFilterPlaylist || filter === 'subtitle') {
        mediaTypes.push('CLOSED-CAPTIONS');
        mediaTypes.push('SUBTITLES');
      }
      mediaTypes.forEach(function (mediaType) {
        var loader = _this7.mediaTypes_[mediaType] && _this7.mediaTypes_[mediaType].activePlaylistLoader;
        if (loader) {
          loaders.push(loader);
        }
      });
      ['main', 'audio', 'subtitle'].forEach(function (name) {
        var loader = _this7[name + "SegmentLoader_"];
        if (loader && (filter === name || filter === 'all')) {
          loaders.push(loader);
        }
      });
      loaders.forEach(function (loader) {
        return fnNames.forEach(function (fnName) {
          if (typeof loader[fnName] === 'function') {
            loader[fnName]();
          }
        });
      });
    }
    ;
    _proto.setCurrentTime = function setCurrentTime(currentTime) {
      var buffered = findRange(this.tech_.buffered(), currentTime);
      if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {
        return 0;
      }
      if (!this.masterPlaylistLoader_.media().segments) {
        return 0;
      }
      if (buffered && buffered.length) {
        return currentTime;
      }
      this.mainSegmentLoader_.resetEverything();
      this.mainSegmentLoader_.abort();
      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
        this.audioSegmentLoader_.resetEverything();
        this.audioSegmentLoader_.abort();
      }
      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
        this.subtitleSegmentLoader_.resetEverything();
        this.subtitleSegmentLoader_.abort();
      }
      this.load();
    }
    ;
    _proto.duration = function duration() {
      if (!this.masterPlaylistLoader_) {
        return 0;
      }
      var media = this.masterPlaylistLoader_.media();
      if (!media) {
        return 0;
      }
      if (!media.endList) {
        return Infinity;
      }
      if (this.mediaSource) {
        return this.mediaSource.duration;
      }
      return Vhs$1.Playlist.duration(media);
    }
    ;
    _proto.seekable = function seekable() {
      return this.seekable_;
    };
    _proto.onSyncInfoUpdate_ = function onSyncInfoUpdate_() {
      var audioSeekable;
      if (!this.masterPlaylistLoader_) {
        return;
      }
      var media = this.masterPlaylistLoader_.media();
      if (!media) {
        return;
      }
      var expired = this.syncController_.getExpiredTime(media, this.duration());
      if (expired === null) {
        return;
      }
      var master = this.masterPlaylistLoader_.master;
      var mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));
      if (mainSeekable.length === 0) {
        return;
      }
      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
        media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();
        expired = this.syncController_.getExpiredTime(media, this.duration());
        if (expired === null) {
          return;
        }
        audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));
        if (audioSeekable.length === 0) {
          return;
        }
      }
      var oldEnd;
      var oldStart;
      if (this.seekable_ && this.seekable_.length) {
        oldEnd = this.seekable_.end(0);
        oldStart = this.seekable_.start(0);
      }
      if (!audioSeekable) {
        this.seekable_ = mainSeekable;
      } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {
        this.seekable_ = mainSeekable;
      } else {
        this.seekable_ = videojs.createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);
      }
      if (this.seekable_ && this.seekable_.length) {
        if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {
          return;
        }
      }
      this.logger_("seekable updated [" + printableRange(this.seekable_) + "]");
      this.tech_.trigger('seekablechanged');
    }
    ;
    _proto.updateDuration = function updateDuration(isLive) {
      if (this.updateDuration_) {
        this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);
        this.updateDuration_ = null;
      }
      if (this.mediaSource.readyState !== 'open') {
        this.updateDuration_ = this.updateDuration.bind(this, isLive);
        this.mediaSource.addEventListener('sourceopen', this.updateDuration_);
        return;
      }
      if (isLive) {
        var seekable = this.seekable();
        if (!seekable.length) {
          return;
        }
        if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable.end(seekable.length - 1)) {
          this.sourceUpdater_.setDuration(seekable.end(seekable.length - 1));
        }
        return;
      }
      var buffered = this.tech_.buffered();
      var duration = Vhs$1.Playlist.duration(this.masterPlaylistLoader_.media());
      if (buffered.length > 0) {
        duration = Math.max(duration, buffered.end(buffered.length - 1));
      }
      if (this.mediaSource.duration !== duration) {
        this.sourceUpdater_.setDuration(duration);
      }
    }
    ;
    _proto.dispose = function dispose() {
      var _this8 = this;
      this.trigger('dispose');
      this.decrypter_.terminate();
      this.masterPlaylistLoader_.dispose();
      this.mainSegmentLoader_.dispose();
      if (this.loadOnPlay_) {
        this.tech_.off('play', this.loadOnPlay_);
      }
      ['AUDIO', 'SUBTITLES'].forEach(function (type) {
        var groups = _this8.mediaTypes_[type].groups;
        for (var id in groups) {
          groups[id].forEach(function (group) {
            if (group.playlistLoader) {
              group.playlistLoader.dispose();
            }
          });
        }
      });
      this.audioSegmentLoader_.dispose();
      this.subtitleSegmentLoader_.dispose();
      this.sourceUpdater_.dispose();
      this.timelineChangeController_.dispose();
      this.stopABRTimer_();
      if (this.updateDuration_) {
        this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);
      }
      this.mediaSource.removeEventListener('durationchange', this.handleDurationChange_);
      this.mediaSource.removeEventListener('sourceopen', this.handleSourceOpen_);
      this.mediaSource.removeEventListener('sourceended', this.handleSourceEnded_);
      this.off();
    }
    ;
    _proto.master = function master() {
      return this.masterPlaylistLoader_.master;
    }
    ;
    _proto.media = function media() {
      return this.masterPlaylistLoader_.media() || this.initialMedia_;
    };
    _proto.areMediaTypesKnown_ = function areMediaTypesKnown_() {
      var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
      var hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_();
      var hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_();
      if (!hasMainMediaInfo || !hasAudioMediaInfo) {
        return false;
      }
      return true;
    };
    _proto.getCodecsOrExclude_ = function getCodecsOrExclude_() {
      var _this9 = this;
      var media = {
        main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
        audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
      };
      media.video = media.main;
      var playlistCodecs = codecsForPlaylist(this.master(), this.media());
      var codecs = {};
      var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
      if (media.main.hasVideo) {
        codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;
      }
      if (media.main.isMuxed) {
        codecs.video += "," + (playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC);
      }
      if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {
        codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC;
        media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;
      }
      if (!codecs.audio && !codecs.video) {
        this.blacklistCurrentPlaylist({
          playlist: this.media(),
          message: 'Could not determine codecs for playlist.',
          blacklistDuration: Infinity
        });
        return;
      }
      var supportFunction = function supportFunction(isFmp4, codec) {
        return isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);
      };
      var unsupportedCodecs = {};
      var unsupportedAudio;
      ['video', 'audio'].forEach(function (type) {
        if (codecs.hasOwnProperty(type) && !supportFunction(media[type].isFmp4, codecs[type])) {
          var supporter = media[type].isFmp4 ? 'browser' : 'muxer';
          unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];
          unsupportedCodecs[supporter].push(codecs[type]);
          if (type === 'audio') {
            unsupportedAudio = supporter;
          }
        }
      });
      if (usingAudioLoader && unsupportedAudio && this.media().attributes.AUDIO) {
        var audioGroup = this.media().attributes.AUDIO;
        this.master().playlists.forEach(function (variant) {
          var variantAudioGroup = variant.attributes && variant.attributes.AUDIO;
          if (variantAudioGroup === audioGroup && variant !== _this9.media()) {
            variant.excludeUntil = Infinity;
          }
        });
        this.logger_("excluding audio group " + audioGroup + " as " + unsupportedAudio + " does not support codec(s): \"" + codecs.audio + "\"");
      }
      if (Object.keys(unsupportedCodecs).length) {
        var message = Object.keys(unsupportedCodecs).reduce(function (acc, supporter) {
          if (acc) {
            acc += ', ';
          }
          acc += supporter + " does not support codec(s): \"" + unsupportedCodecs[supporter].join(',') + "\"";
          return acc;
        }, '') + '.';
        this.blacklistCurrentPlaylist({
          playlist: this.media(),
          internal: true,
          message: message,
          blacklistDuration: Infinity
        });
        return;
      }
      if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
        var switchMessages = [];
        ['video', 'audio'].forEach(function (type) {
          var newCodec = (parseCodecs(_this9.sourceUpdater_.codecs[type] || '')[0] || {}).type;
          var oldCodec = (parseCodecs(codecs[type] || '')[0] || {}).type;
          if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {
            switchMessages.push("\"" + _this9.sourceUpdater_.codecs[type] + "\" -> \"" + codecs[type] + "\"");
          }
        });
        if (switchMessages.length) {
          this.blacklistCurrentPlaylist({
            playlist: this.media(),
            message: "Codec switching not supported: " + switchMessages.join(', ') + ".",
            blacklistDuration: Infinity,
            internal: true
          });
          return;
        }
      }
      return codecs;
    }
    ;
    _proto.tryToCreateSourceBuffers_ = function tryToCreateSourceBuffers_() {
      if (this.mediaSource.readyState !== 'open' || this.sourceUpdater_.hasCreatedSourceBuffers()) {
        return;
      }
      if (!this.areMediaTypesKnown_()) {
        return;
      }
      var codecs = this.getCodecsOrExclude_();
      if (!codecs) {
        return;
      }
      this.sourceUpdater_.createSourceBuffers(codecs);
      var codecString = [codecs.video, codecs.audio].filter(Boolean).join(',');
      this.excludeIncompatibleVariants_(codecString);
    }
    ;
    _proto.excludeUnsupportedVariants_ = function excludeUnsupportedVariants_() {
      var _this10 = this;
      var playlists = this.master().playlists;
      var ids = [];
      Object.keys(playlists).forEach(function (key) {
        var variant = playlists[key];
        if (ids.indexOf(variant.id) !== -1) {
          return;
        }
        ids.push(variant.id);
        var codecs = codecsForPlaylist(_this10.master, variant);
        var unsupported = [];
        if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) {
          unsupported.push("audio codec " + codecs.audio);
        }
        if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) {
          unsupported.push("video codec " + codecs.video);
        }
        if (codecs.text && codecs.text === 'stpp.ttml.im1t') {
          unsupported.push("text codec " + codecs.text);
        }
        if (unsupported.length) {
          variant.excludeUntil = Infinity;
          _this10.logger_("excluding " + variant.id + " for unsupported: " + unsupported.join(', '));
        }
      });
    }
    ;
    _proto.excludeIncompatibleVariants_ = function excludeIncompatibleVariants_(codecString) {
      var _this11 = this;
      var ids = [];
      var playlists = this.master().playlists;
      var codecs = unwrapCodecList(parseCodecs(codecString));
      var codecCount_ = codecCount(codecs);
      var videoDetails = codecs.video && parseCodecs(codecs.video)[0] || null;
      var audioDetails = codecs.audio && parseCodecs(codecs.audio)[0] || null;
      Object.keys(playlists).forEach(function (key) {
        var variant = playlists[key];
        if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === Infinity) {
          return;
        }
        ids.push(variant.id);
        var blacklistReasons = [];
        var variantCodecs = codecsForPlaylist(_this11.masterPlaylistLoader_.master, variant);
        var variantCodecCount = codecCount(variantCodecs);
        if (!variantCodecs.audio && !variantCodecs.video) {
          return;
        }
        if (variantCodecCount !== codecCount_) {
          blacklistReasons.push("codec count \"" + variantCodecCount + "\" !== \"" + codecCount_ + "\"");
        }
        if (!_this11.sourceUpdater_.canChangeType()) {
          var variantVideoDetails = variantCodecs.video && parseCodecs(variantCodecs.video)[0] || null;
          var variantAudioDetails = variantCodecs.audio && parseCodecs(variantCodecs.audio)[0] || null;
          if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) {
            blacklistReasons.push("video codec \"" + variantVideoDetails.type + "\" !== \"" + videoDetails.type + "\"");
          }
          if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) {
            blacklistReasons.push("audio codec \"" + variantAudioDetails.type + "\" !== \"" + audioDetails.type + "\"");
          }
        }
        if (blacklistReasons.length) {
          variant.excludeUntil = Infinity;
          _this11.logger_("blacklisting " + variant.id + ": " + blacklistReasons.join(' && '));
        }
      });
    };
    _proto.updateAdCues_ = function updateAdCues_(media) {
      var offset = 0;
      var seekable = this.seekable();
      if (seekable.length) {
        offset = seekable.start(0);
      }
      updateAdCues(media, this.cueTagsTrack_, offset);
    }
    ;
    _proto.goalBufferLength = function goalBufferLength() {
      var currentTime = this.tech_.currentTime();
      var initial = Config.GOAL_BUFFER_LENGTH;
      var rate = Config.GOAL_BUFFER_LENGTH_RATE;
      var max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);
      return Math.min(initial + currentTime * rate, max);
    }
    ;
    _proto.bufferLowWaterLine = function bufferLowWaterLine() {
      var currentTime = this.tech_.currentTime();
      var initial = Config.BUFFER_LOW_WATER_LINE;
      var rate = Config.BUFFER_LOW_WATER_LINE_RATE;
      var max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);
      var newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
      return Math.min(initial + currentTime * rate, this.experimentalBufferBasedABR ? newMax : max);
    };
    _proto.bufferHighWaterLine = function bufferHighWaterLine() {
      return Config.BUFFER_HIGH_WATER_LINE;
    };
    return MasterPlaylistController;
  }(videojs.EventTarget);
  var enableFunction = function enableFunction(loader, playlistID, changePlaylistFn) {
    return function (enable) {
      var playlist = loader.master.playlists[playlistID];
      var incompatible = isIncompatible(playlist);
      var currentlyEnabled = isEnabled(playlist);
      if (typeof enable === 'undefined') {
        return currentlyEnabled;
      }
      if (enable) {
        delete playlist.disabled;
      } else {
        playlist.disabled = true;
      }
      if (enable !== currentlyEnabled && !incompatible) {
        changePlaylistFn();
        if (enable) {
          loader.trigger('renditionenabled');
        } else {
          loader.trigger('renditiondisabled');
        }
      }
      return enable;
    };
  };
  var Representation = function Representation(vhsHandler, playlist, id) {
    var mpc = vhsHandler.masterPlaylistController_,
        smoothQualityChange = vhsHandler.options_.smoothQualityChange;
    var changeType = smoothQualityChange ? 'smooth' : 'fast';
    var qualityChangeFunction = mpc[changeType + "QualityChange_"].bind(mpc);
    if (playlist.attributes) {
      var resolution = playlist.attributes.RESOLUTION;
      this.width = resolution && resolution.width;
      this.height = resolution && resolution.height;
      this.bandwidth = playlist.attributes.BANDWIDTH;
    }
    this.codecs = codecsForPlaylist(mpc.master(), playlist);
    this.playlist = playlist;
    this.id = id;
    this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);
  };
  var renditionSelectionMixin = function renditionSelectionMixin(vhsHandler) {
    vhsHandler.representations = function () {
      var master = vhsHandler.masterPlaylistController_.master();
      var playlists = isAudioOnly(master) ? vhsHandler.masterPlaylistController_.getAudioTrackPlaylists_() : master.playlists;
      if (!playlists) {
        return [];
      }
      return playlists.filter(function (media) {
        return !isIncompatible(media);
      }).map(function (e, i) {
        return new Representation(vhsHandler, e, e.id);
      });
    };
  };
  var timerCancelEvents = ['seeking', 'seeked', 'pause', 'playing', 'error'];
  var PlaybackWatcher = function () {
    function PlaybackWatcher(options) {
      var _this = this;
      this.masterPlaylistController_ = options.masterPlaylistController;
      this.tech_ = options.tech;
      this.seekable = options.seekable;
      this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;
      this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;
      this.media = options.media;
      this.consecutiveUpdates = 0;
      this.lastRecordedTime = null;
      this.timer_ = null;
      this.checkCurrentTimeTimeout_ = null;
      this.logger_ = logger('PlaybackWatcher');
      this.logger_('initialize');
      var playHandler = function playHandler() {
        return _this.monitorCurrentTime_();
      };
      var canPlayHandler = function canPlayHandler() {
        return _this.monitorCurrentTime_();
      };
      var waitingHandler = function waitingHandler() {
        return _this.techWaiting_();
      };
      var cancelTimerHandler = function cancelTimerHandler() {
        return _this.cancelTimer_();
      };
      var mpc = this.masterPlaylistController_;
      var loaderTypes = ['main', 'subtitle', 'audio'];
      var loaderChecks = {};
      loaderTypes.forEach(function (type) {
        loaderChecks[type] = {
          reset: function reset() {
            return _this.resetSegmentDownloads_(type);
          },
          updateend: function updateend() {
            return _this.checkSegmentDownloads_(type);
          }
        };
        mpc[type + "SegmentLoader_"].on('appendsdone', loaderChecks[type].updateend);
        mpc[type + "SegmentLoader_"].on('playlistupdate', loaderChecks[type].reset);
        _this.tech_.on(['seeked', 'seeking'], loaderChecks[type].reset);
      });
      var setSeekingHandlers = function setSeekingHandlers(fn) {
        ['main', 'audio'].forEach(function (type) {
          mpc[type + "SegmentLoader_"][fn]('appended', _this.seekingAppendCheck_);
        });
      };
      this.seekingAppendCheck_ = function () {
        if (_this.fixesBadSeeks_()) {
          _this.consecutiveUpdates = 0;
          _this.lastRecordedTime = _this.tech_.currentTime();
          setSeekingHandlers('off');
        }
      };
      this.clearSeekingAppendCheck_ = function () {
        return setSeekingHandlers('off');
      };
      this.watchForBadSeeking_ = function () {
        _this.clearSeekingAppendCheck_();
        setSeekingHandlers('on');
      };
      this.tech_.on('seeked', this.clearSeekingAppendCheck_);
      this.tech_.on('seeking', this.watchForBadSeeking_);
      this.tech_.on('waiting', waitingHandler);
      this.tech_.on(timerCancelEvents, cancelTimerHandler);
      this.tech_.on('canplay', canPlayHandler);
      this.tech_.one('play', playHandler);
      this.dispose = function () {
        _this.clearSeekingAppendCheck_();
        _this.logger_('dispose');
        _this.tech_.off('waiting', waitingHandler);
        _this.tech_.off(timerCancelEvents, cancelTimerHandler);
        _this.tech_.off('canplay', canPlayHandler);
        _this.tech_.off('play', playHandler);
        _this.tech_.off('seeking', _this.watchForBadSeeking_);
        _this.tech_.off('seeked', _this.clearSeekingAppendCheck_);
        loaderTypes.forEach(function (type) {
          mpc[type + "SegmentLoader_"].off('appendsdone', loaderChecks[type].updateend);
          mpc[type + "SegmentLoader_"].off('playlistupdate', loaderChecks[type].reset);
          _this.tech_.off(['seeked', 'seeking'], loaderChecks[type].reset);
        });
        if (_this.checkCurrentTimeTimeout_) {
          window.clearTimeout(_this.checkCurrentTimeTimeout_);
        }
        _this.cancelTimer_();
      };
    }
    var _proto = PlaybackWatcher.prototype;
    _proto.monitorCurrentTime_ = function monitorCurrentTime_() {
      this.checkCurrentTime_();
      if (this.checkCurrentTimeTimeout_) {
        window.clearTimeout(this.checkCurrentTimeTimeout_);
      }
      this.checkCurrentTimeTimeout_ = window.setTimeout(this.monitorCurrentTime_.bind(this), 250);
    }
    ;
    _proto.resetSegmentDownloads_ = function resetSegmentDownloads_(type) {
      var loader = this.masterPlaylistController_[type + "SegmentLoader_"];
      if (this[type + "StalledDownloads_"] > 0) {
        this.logger_("resetting possible stalled download count for " + type + " loader");
      }
      this[type + "StalledDownloads_"] = 0;
      this[type + "Buffered_"] = loader.buffered_();
    }
    ;
    _proto.checkSegmentDownloads_ = function checkSegmentDownloads_(type) {
      var mpc = this.masterPlaylistController_;
      var loader = mpc[type + "SegmentLoader_"];
      var buffered = loader.buffered_();
      var isBufferedDifferent = isRangeDifferent(this[type + "Buffered_"], buffered);
      this[type + "Buffered_"] = buffered;
      if (isBufferedDifferent) {
        this.resetSegmentDownloads_(type);
        return;
      }
      this[type + "StalledDownloads_"]++;
      this.logger_("found #" + this[type + "StalledDownloads_"] + " " + type + " appends that did not increase buffer (possible stalled download)", {
        playlistId: loader.playlist_ && loader.playlist_.id,
        buffered: timeRangesToArray(buffered)
      });
      if (this[type + "StalledDownloads_"] < 10) {
        return;
      }
      this.logger_(type + " loader stalled download exclusion");
      this.resetSegmentDownloads_(type);
      this.tech_.trigger({
        type: 'usage',
        name: "vhs-" + type + "-download-exclusion"
      });
      if (type === 'subtitle') {
        return;
      }
      mpc.blacklistCurrentPlaylist({
        message: "Excessive " + type + " segment downloading detected."
      }, Infinity);
    }
    ;
    _proto.checkCurrentTime_ = function checkCurrentTime_() {
      if (this.tech_.paused() || this.tech_.seeking()) {
        return;
      }
      var currentTime = this.tech_.currentTime();
      var buffered = this.tech_.buffered();
      if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {
        return this.techWaiting_();
      }
      if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {
        this.consecutiveUpdates++;
        this.waiting_();
      } else if (currentTime === this.lastRecordedTime) {
        this.consecutiveUpdates++;
      } else {
        this.consecutiveUpdates = 0;
        this.lastRecordedTime = currentTime;
      }
    }
    ;
    _proto.cancelTimer_ = function cancelTimer_() {
      this.consecutiveUpdates = 0;
      if (this.timer_) {
        this.logger_('cancelTimer_');
        clearTimeout(this.timer_);
      }
      this.timer_ = null;
    }
    ;
    _proto.fixesBadSeeks_ = function fixesBadSeeks_() {
      var seeking = this.tech_.seeking();
      if (!seeking) {
        return false;
      }
      var seekable = this.seekable();
      var currentTime = this.tech_.currentTime();
      var isAfterSeekableRange = this.afterSeekableWindow_(seekable, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
      var seekTo;
      if (isAfterSeekableRange) {
        var seekableEnd = seekable.end(seekable.length - 1);
        seekTo = seekableEnd;
      }
      if (this.beforeSeekableWindow_(seekable, currentTime)) {
        var seekableStart = seekable.start(0);
        seekTo = seekableStart + (
        seekableStart === seekable.end(0) ? 0 : SAFE_TIME_DELTA);
      }
      if (typeof seekTo !== 'undefined') {
        this.logger_("Trying to seek outside of seekable at time " + currentTime + " with " + ("seekable range " + printableRange(seekable) + ". Seeking to ") + (seekTo + "."));
        this.tech_.setCurrentTime(seekTo);
        return true;
      }
      var sourceUpdater = this.masterPlaylistController_.sourceUpdater_;
      var buffered = this.tech_.buffered();
      var audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;
      var videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;
      var media = this.media();
      var minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2;
      var bufferedToCheck = [audioBuffered, videoBuffered];
      for (var i = 0; i < bufferedToCheck.length; i++) {
        if (!bufferedToCheck[i]) {
          continue;
        }
        var timeAhead = timeAheadOf(bufferedToCheck[i], currentTime);
        if (timeAhead < minAppendedDuration) {
          return false;
        }
      }
      var nextRange = findNextRange(buffered, currentTime);
      if (nextRange.length === 0) {
        return false;
      }
      seekTo = nextRange.start(0) + SAFE_TIME_DELTA;
      this.logger_("Buffered region starts (" + nextRange.start(0) + ") " + (" just beyond seek point (" + currentTime + "). Seeking to " + seekTo + "."));
      this.tech_.setCurrentTime(seekTo);
      return true;
    }
    ;
    _proto.waiting_ = function waiting_() {
      if (this.techWaiting_()) {
        return;
      }
      var currentTime = this.tech_.currentTime();
      var buffered = this.tech_.buffered();
      var currentRange = findRange(buffered, currentTime);
      if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {
        this.cancelTimer_();
        this.tech_.setCurrentTime(currentTime);
        this.logger_("Stopped at " + currentTime + " while inside a buffered region " + ("[" + currentRange.start(0) + " -> " + currentRange.end(0) + "]. Attempting to resume ") + 'playback by seeking to the current time.');
        this.tech_.trigger({
          type: 'usage',
          name: 'vhs-unknown-waiting'
        });
        this.tech_.trigger({
          type: 'usage',
          name: 'hls-unknown-waiting'
        });
        return;
      }
    }
    ;
    _proto.techWaiting_ = function techWaiting_() {
      var seekable = this.seekable();
      var currentTime = this.tech_.currentTime();
      if (this.tech_.seeking() || this.timer_ !== null) {
        return true;
      }
      if (this.beforeSeekableWindow_(seekable, currentTime)) {
        var livePoint = seekable.end(seekable.length - 1);
        this.logger_("Fell out of live window at time " + currentTime + ". Seeking to " + ("live point (seekable end) " + livePoint));
        this.cancelTimer_();
        this.tech_.setCurrentTime(livePoint);
        this.tech_.trigger({
          type: 'usage',
          name: 'vhs-live-resync'
        });
        this.tech_.trigger({
          type: 'usage',
          name: 'hls-live-resync'
        });
        return true;
      }
      var sourceUpdater = this.tech_.vhs.masterPlaylistController_.sourceUpdater_;
      var buffered = this.tech_.buffered();
      var videoUnderflow = this.videoUnderflow_({
        audioBuffered: sourceUpdater.audioBuffered(),
        videoBuffered: sourceUpdater.videoBuffered(),
        currentTime: currentTime
      });
      if (videoUnderflow) {
        this.cancelTimer_();
        this.tech_.setCurrentTime(currentTime);
        this.tech_.trigger({
          type: 'usage',
          name: 'vhs-video-underflow'
        });
        this.tech_.trigger({
          type: 'usage',
          name: 'hls-video-underflow'
        });
        return true;
      }
      var nextRange = findNextRange(buffered, currentTime);
      if (nextRange.length > 0) {
        var difference = nextRange.start(0) - currentTime;
        this.logger_("Stopped at " + currentTime + ", setting timer for " + difference + ", seeking " + ("to " + nextRange.start(0)));
        this.cancelTimer_();
        this.timer_ = setTimeout(this.skipTheGap_.bind(this), difference * 1000, currentTime);
        return true;
      }
      return false;
    };
    _proto.afterSeekableWindow_ = function afterSeekableWindow_(seekable, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow) {
      if (allowSeeksWithinUnsafeLiveWindow === void 0) {
        allowSeeksWithinUnsafeLiveWindow = false;
      }
      if (!seekable.length) {
        return false;
      }
      var allowedEnd = seekable.end(seekable.length - 1) + SAFE_TIME_DELTA;
      var isLive = !playlist.endList;
      if (isLive && allowSeeksWithinUnsafeLiveWindow) {
        allowedEnd = seekable.end(seekable.length - 1) + playlist.targetDuration * 3;
      }
      if (currentTime > allowedEnd) {
        return true;
      }
      return false;
    };
    _proto.beforeSeekableWindow_ = function beforeSeekableWindow_(seekable, currentTime) {
      if (seekable.length &&
      seekable.start(0) > 0 && currentTime < seekable.start(0) - this.liveRangeSafeTimeDelta) {
        return true;
      }
      return false;
    };
    _proto.videoUnderflow_ = function videoUnderflow_(_ref) {
      var videoBuffered = _ref.videoBuffered,
          audioBuffered = _ref.audioBuffered,
          currentTime = _ref.currentTime;
      if (!videoBuffered) {
        return;
      }
      var gap;
      if (videoBuffered.length && audioBuffered.length) {
        var lastVideoRange = findRange(videoBuffered, currentTime - 3);
        var videoRange = findRange(videoBuffered, currentTime);
        var audioRange = findRange(audioBuffered, currentTime);
        if (audioRange.length && !videoRange.length && lastVideoRange.length) {
          gap = {
            start: lastVideoRange.end(0),
            end: audioRange.end(0)
          };
        }
      } else {
        var nextRange = findNextRange(videoBuffered, currentTime);
        if (!nextRange.length) {
          gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);
        }
      }
      if (gap) {
        this.logger_("Encountered a gap in video from " + gap.start + " to " + gap.end + ". " + ("Seeking to current time " + currentTime));
        return true;
      }
      return false;
    }
    ;
    _proto.skipTheGap_ = function skipTheGap_(scheduledCurrentTime) {
      var buffered = this.tech_.buffered();
      var currentTime = this.tech_.currentTime();
      var nextRange = findNextRange(buffered, currentTime);
      this.cancelTimer_();
      if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {
        return;
      }
      this.logger_('skipTheGap_:', 'currentTime:', currentTime, 'scheduled currentTime:', scheduledCurrentTime, 'nextRange start:', nextRange.start(0));
      this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);
      this.tech_.trigger({
        type: 'usage',
        name: 'vhs-gap-skip'
      });
      this.tech_.trigger({
        type: 'usage',
        name: 'hls-gap-skip'
      });
    };
    _proto.gapFromVideoUnderflow_ = function gapFromVideoUnderflow_(buffered, currentTime) {
      var gaps = findGaps(buffered);
      for (var i = 0; i < gaps.length; i++) {
        var start = gaps.start(i);
        var end = gaps.end(i);
        if (currentTime - start < 4 && currentTime - start > 2) {
          return {
            start: start,
            end: end
          };
        }
      }
      return null;
    };
    return PlaybackWatcher;
  }();
  var defaultOptions = {
    errorInterval: 30,
    getSource: function getSource(next) {
      var tech = this.tech({
        IWillNotUseThisInPlugins: true
      });
      var sourceObj = tech.currentSource_ || this.currentSource();
      return next(sourceObj);
    }
  };
  var initPlugin = function initPlugin(player, options) {
    var lastCalled = 0;
    var seekTo = 0;
    var localOptions = videojs.mergeOptions(defaultOptions, options);
    player.ready(function () {
      player.trigger({
        type: 'usage',
        name: 'vhs-error-reload-initialized'
      });
      player.trigger({
        type: 'usage',
        name: 'hls-error-reload-initialized'
      });
    });
    var loadedMetadataHandler = function loadedMetadataHandler() {
      if (seekTo) {
        player.currentTime(seekTo);
      }
    };
    var setSource = function setSource(sourceObj) {
      if (sourceObj === null || sourceObj === undefined) {
        return;
      }
      seekTo = player.duration() !== Infinity && player.currentTime() || 0;
      player.one('loadedmetadata', loadedMetadataHandler);
      player.src(sourceObj);
      player.trigger({
        type: 'usage',
        name: 'vhs-error-reload'
      });
      player.trigger({
        type: 'usage',
        name: 'hls-error-reload'
      });
      player.play();
    };
    var errorHandler = function errorHandler() {
      if (Date.now() - lastCalled < localOptions.errorInterval * 1000) {
        player.trigger({
          type: 'usage',
          name: 'vhs-error-reload-canceled'
        });
        player.trigger({
          type: 'usage',
          name: 'hls-error-reload-canceled'
        });
        return;
      }
      if (!localOptions.getSource || typeof localOptions.getSource !== 'function') {
        videojs.log.error('ERROR: reloadSourceOnError - The option getSource must be a function!');
        return;
      }
      lastCalled = Date.now();
      return localOptions.getSource.call(player, setSource);
    };
    var cleanupEvents = function cleanupEvents() {
      player.off('loadedmetadata', loadedMetadataHandler);
      player.off('error', errorHandler);
      player.off('dispose', cleanupEvents);
    };
    var reinitPlugin = function reinitPlugin(newOptions) {
      cleanupEvents();
      initPlugin(player, newOptions);
    };
    player.on('error', errorHandler);
    player.on('dispose', cleanupEvents);
    player.reloadSourceOnError = reinitPlugin;
  };
  var reloadSourceOnError = function reloadSourceOnError(options) {
    initPlugin(this, options);
  };
  var version$4 = "2.13.1";
  var version$3 = "6.0.1";
  var version$2 = "0.21.0";
  var version$1 = "4.7.0";
  var version = "3.1.2";
  var Vhs = {
    PlaylistLoader: PlaylistLoader,
    Playlist: Playlist,
    utils: utils,
    STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,
    INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,
    lastBandwidthSelector: lastBandwidthSelector,
    movingAverageBandwidthSelector: movingAverageBandwidthSelector,
    comparePlaylistBandwidth: comparePlaylistBandwidth,
    comparePlaylistResolution: comparePlaylistResolution,
    xhr: xhrFactory()
  };
  Object.keys(Config).forEach(function (prop) {
    Object.defineProperty(Vhs, prop, {
      get: function get() {
        videojs.log.warn("using Vhs." + prop + " is UNSAFE be sure you know what you are doing");
        return Config[prop];
      },
      set: function set(value) {
        videojs.log.warn("using Vhs." + prop + " is UNSAFE be sure you know what you are doing");
        if (typeof value !== 'number' || value < 0) {
          videojs.log.warn("value of Vhs." + prop + " must be greater than or equal to 0");
          return;
        }
        Config[prop] = value;
      }
    });
  });
  var LOCAL_STORAGE_KEY = 'videojs-vhs';
  var handleVhsMediaChange = function handleVhsMediaChange(qualityLevels, playlistLoader) {
    var newPlaylist = playlistLoader.media();
    var selectedIndex = -1;
    for (var i = 0; i < qualityLevels.length; i++) {
      if (qualityLevels[i].id === newPlaylist.id) {
        selectedIndex = i;
        break;
      }
    }
    qualityLevels.selectedIndex_ = selectedIndex;
    qualityLevels.trigger({
      selectedIndex: selectedIndex,
      type: 'change'
    });
  };
  var handleVhsLoadedMetadata = function handleVhsLoadedMetadata(qualityLevels, vhs) {
    vhs.representations().forEach(function (rep) {
      qualityLevels.addQualityLevel(rep);
    });
    handleVhsMediaChange(qualityLevels, vhs.playlists);
  };
  Vhs.canPlaySource = function () {
    return videojs.log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\'s techOrder.');
  };
  var emeKeySystems = function emeKeySystems(keySystemOptions, mainPlaylist, audioPlaylist) {
    if (!keySystemOptions) {
      return keySystemOptions;
    }
    var codecs = {};
    if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) {
      codecs = unwrapCodecList(parseCodecs(mainPlaylist.attributes.CODECS));
    }
    if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) {
      codecs.audio = audioPlaylist.attributes.CODECS;
    }
    var videoContentType = getMimeForCodec(codecs.video);
    var audioContentType = getMimeForCodec(codecs.audio);
    var keySystemContentTypes = {};
    for (var keySystem in keySystemOptions) {
      keySystemContentTypes[keySystem] = {};
      if (audioContentType) {
        keySystemContentTypes[keySystem].audioContentType = audioContentType;
      }
      if (videoContentType) {
        keySystemContentTypes[keySystem].videoContentType = videoContentType;
      }
      if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) {
        keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;
      }
      if (typeof keySystemOptions[keySystem] === 'string') {
        keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];
      }
    }
    return videojs.mergeOptions(keySystemOptions, keySystemContentTypes);
  };
  var getAllPsshKeySystemsOptions = function getAllPsshKeySystemsOptions(playlists, keySystems) {
    return playlists.reduce(function (keySystemsArr, playlist) {
      if (!playlist.contentProtection) {
        return keySystemsArr;
      }
      var keySystemsOptions = keySystems.reduce(function (keySystemsObj, keySystem) {
        var keySystemOptions = playlist.contentProtection[keySystem];
        if (keySystemOptions && keySystemOptions.pssh) {
          keySystemsObj[keySystem] = {
            pssh: keySystemOptions.pssh
          };
        }
        return keySystemsObj;
      }, {});
      if (Object.keys(keySystemsOptions).length) {
        keySystemsArr.push(keySystemsOptions);
      }
      return keySystemsArr;
    }, []);
  };
  var waitForKeySessionCreation = function waitForKeySessionCreation(_ref) {
    var player = _ref.player,
        sourceKeySystems = _ref.sourceKeySystems,
        audioMedia = _ref.audioMedia,
        mainPlaylists = _ref.mainPlaylists;
    if (!player.eme.initializeMediaKeys) {
      return Promise.resolve();
    }
    var playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;
    var keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));
    var initializationFinishedPromises = [];
    var keySessionCreatedPromises = [];
    keySystemsOptionsArr.forEach(function (keySystemsOptions) {
      keySessionCreatedPromises.push(new Promise(function (resolve, reject) {
        player.tech_.one('keysessioncreated', resolve);
      }));
      initializationFinishedPromises.push(new Promise(function (resolve, reject) {
        player.eme.initializeMediaKeys({
          keySystems: keySystemsOptions
        }, function (err) {
          if (err) {
            reject(err);
            return;
          }
          resolve();
        });
      }));
    });
    return Promise.race([
    Promise.all(initializationFinishedPromises),
    Promise.race(keySessionCreatedPromises)]);
  };
  var setupEmeOptions = function setupEmeOptions(_ref2) {
    var player = _ref2.player,
        sourceKeySystems = _ref2.sourceKeySystems,
        media = _ref2.media,
        audioMedia = _ref2.audioMedia;
    var sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);
    if (!sourceOptions) {
      return false;
    }
    player.currentSource().keySystems = sourceOptions;
    if (sourceOptions && !player.eme) {
      videojs.log.warn('DRM encrypted source cannot be decrypted without a DRM plugin');
      return false;
    }
    return true;
  };
  var getVhsLocalStorage = function getVhsLocalStorage() {
    if (!window.localStorage) {
      return null;
    }
    var storedObject = window.localStorage.getItem(LOCAL_STORAGE_KEY);
    if (!storedObject) {
      return null;
    }
    try {
      return JSON.parse(storedObject);
    } catch (e) {
      return null;
    }
  };
  var updateVhsLocalStorage = function updateVhsLocalStorage(options) {
    if (!window.localStorage) {
      return false;
    }
    var objectToStore = getVhsLocalStorage();
    objectToStore = objectToStore ? videojs.mergeOptions(objectToStore, options) : options;
    try {
      window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));
    } catch (e) {
      return false;
    }
    return objectToStore;
  };
  var expandDataUri = function expandDataUri(dataUri) {
    if (dataUri.toLowerCase().indexOf('data:application/vnd.videojs.vhs+json,') === 0) {
      return JSON.parse(dataUri.substring(dataUri.indexOf(',') + 1));
    }
    return dataUri;
  };
  Vhs.supportsNativeHls = function () {
    if (!document || !document.createElement) {
      return false;
    }
    var video = document.createElement('video');
    if (!videojs.getTech('Html5').isSupported()) {
      return false;
    }
    var canPlay = [
    'application/vnd.apple.mpegurl',
    'audio/mpegurl',
    'audio/x-mpegurl',
    'application/x-mpegurl',
    'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];
    return canPlay.some(function (canItPlay) {
      return /maybe|probably/i.test(video.canPlayType(canItPlay));
    });
  }();
  Vhs.supportsNativeDash = function () {
    if (!document || !document.createElement || !videojs.getTech('Html5').isSupported()) {
      return false;
    }
    return /maybe|probably/i.test(document.createElement('video').canPlayType('application/dash+xml'));
  }();
  Vhs.supportsTypeNatively = function (type) {
    if (type === 'hls') {
      return Vhs.supportsNativeHls;
    }
    if (type === 'dash') {
      return Vhs.supportsNativeDash;
    }
    return false;
  };
  Vhs.isSupported = function () {
    return videojs.log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\'s techOrder.');
  };
  var Component = videojs.getComponent('Component');
  var VhsHandler = function (_Component) {
    inheritsLoose(VhsHandler, _Component);
    function VhsHandler(source, tech, options) {
      var _this;
      _this = _Component.call(this, tech, videojs.mergeOptions(options.hls, options.vhs)) || this;
      if (options.hls && Object.keys(options.hls).length) {
        videojs.log.warn('Using hls options is deprecated. Use vhs instead.');
      }
      if (typeof options.initialBandwidth === 'number') {
        _this.options_.bandwidth = options.initialBandwidth;
      }
      _this.logger_ = logger('VhsHandler');
      if (tech.options_ && tech.options_.playerId) {
        var _player = videojs(tech.options_.playerId);
        if (!_player.hasOwnProperty('hls')) {
          Object.defineProperty(_player, 'hls', {
            get: function get() {
              videojs.log.warn('player.hls is deprecated. Use player.tech().vhs instead.');
              tech.trigger({
                type: 'usage',
                name: 'hls-player-access'
              });
              return assertThisInitialized(_this);
            },
            configurable: true
          });
        }
        if (!_player.hasOwnProperty('vhs')) {
          Object.defineProperty(_player, 'vhs', {
            get: function get() {
              videojs.log.warn('player.vhs is deprecated. Use player.tech().vhs instead.');
              tech.trigger({
                type: 'usage',
                name: 'vhs-player-access'
              });
              return assertThisInitialized(_this);
            },
            configurable: true
          });
        }
        if (!_player.hasOwnProperty('dash')) {
          Object.defineProperty(_player, 'dash', {
            get: function get() {
              videojs.log.warn('player.dash is deprecated. Use player.tech().vhs instead.');
              return assertThisInitialized(_this);
            },
            configurable: true
          });
        }
        _this.player_ = _player;
      }
      _this.tech_ = tech;
      _this.source_ = source;
      _this.stats = {};
      _this.ignoreNextSeekingEvent_ = false;
      _this.setOptions_();
      if (_this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {
        tech.overrideNativeAudioTracks(true);
        tech.overrideNativeVideoTracks(true);
      } else if (_this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {
        throw new Error('Overriding native HLS requires emulated tracks. ' + 'See https://git.io/vMpjB');
      }
      _this.on(document, ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'], function (event) {
        var fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        if (fullscreenElement && fullscreenElement.contains(_this.tech_.el())) {
          _this.masterPlaylistController_.fastQualityChange_();
        } else {
          _this.masterPlaylistController_.checkABR_();
        }
      });
      _this.on(_this.tech_, 'seeking', function () {
        if (this.ignoreNextSeekingEvent_) {
          this.ignoreNextSeekingEvent_ = false;
          return;
        }
        this.setCurrentTime(this.tech_.currentTime());
      });
      _this.on(_this.tech_, 'error', function () {
        if (this.tech_.error() && this.masterPlaylistController_) {
          this.masterPlaylistController_.pauseLoading();
        }
      });
      _this.on(_this.tech_, 'play', _this.play);
      return _this;
    }
    var _proto = VhsHandler.prototype;
    _proto.setOptions_ = function setOptions_() {
      var _this2 = this;
      this.options_.withCredentials = this.options_.withCredentials || false;
      this.options_.handleManifestRedirects = this.options_.handleManifestRedirects === false ? false : true;
      this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;
      this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;
      this.options_.smoothQualityChange = this.options_.smoothQualityChange || false;
      this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== 'undefined' ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;
      this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;
      this.options_.customTagParsers = this.options_.customTagParsers || [];
      this.options_.customTagMappers = this.options_.customTagMappers || [];
      this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;
      if (typeof this.options_.blacklistDuration !== 'number') {
        this.options_.blacklistDuration = 5 * 60;
      }
      if (typeof this.options_.bandwidth !== 'number') {
        if (this.options_.useBandwidthFromLocalStorage) {
          var storedObject = getVhsLocalStorage();
          if (storedObject && storedObject.bandwidth) {
            this.options_.bandwidth = storedObject.bandwidth;
            this.tech_.trigger({
              type: 'usage',
              name: 'vhs-bandwidth-from-local-storage'
            });
            this.tech_.trigger({
              type: 'usage',
              name: 'hls-bandwidth-from-local-storage'
            });
          }
          if (storedObject && storedObject.throughput) {
            this.options_.throughput = storedObject.throughput;
            this.tech_.trigger({
              type: 'usage',
              name: 'vhs-throughput-from-local-storage'
            });
            this.tech_.trigger({
              type: 'usage',
              name: 'hls-throughput-from-local-storage'
            });
          }
        }
      }
      if (typeof this.options_.bandwidth !== 'number') {
        this.options_.bandwidth = Config.INITIAL_BANDWIDTH;
      }
      this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH;
      ['withCredentials', 'useDevicePixelRatio', 'limitRenditionByPlayerDimensions', 'bandwidth', 'smoothQualityChange', 'customTagParsers', 'customTagMappers', 'handleManifestRedirects', 'cacheEncryptionKeys', 'playlistSelector', 'initialPlaylistSelector', 'experimentalBufferBasedABR', 'liveRangeSafeTimeDelta', 'experimentalLLHLS', 'useNetworkInformationApi', 'experimentalExactManifestTimings', 'experimentalLeastPixelDiffSelector'].forEach(function (option) {
        if (typeof _this2.source_[option] !== 'undefined') {
          _this2.options_[option] = _this2.source_[option];
        }
      });
      this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;
      this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
    }
    ;
    _proto.src = function src(_src, type) {
      var _this3 = this;
      if (!_src) {
        return;
      }
      this.setOptions_();
      this.options_.src = expandDataUri(this.source_.src);
      this.options_.tech = this.tech_;
      this.options_.externVhs = Vhs;
      this.options_.sourceType = simpleTypeFromSourceType(type);
      this.options_.seekTo = function (time) {
        _this3.tech_.setCurrentTime(time);
      };
      if (this.options_.smoothQualityChange) {
        videojs.log.warn('smoothQualityChange is deprecated and will be removed in the next major version');
      }
      this.masterPlaylistController_ = new MasterPlaylistController(this.options_);
      var playbackWatcherOptions = videojs.mergeOptions({
        liveRangeSafeTimeDelta: SAFE_TIME_DELTA
      }, this.options_, {
        seekable: function seekable() {
          return _this3.seekable();
        },
        media: function media() {
          return _this3.masterPlaylistController_.media();
        },
        masterPlaylistController: this.masterPlaylistController_
      });
      this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);
      this.masterPlaylistController_.on('error', function () {
        var player = videojs.players[_this3.tech_.options_.playerId];
        var error = _this3.masterPlaylistController_.error;
        if (typeof error === 'object' && !error.code) {
          error.code = 3;
        } else if (typeof error === 'string') {
          error = {
            message: error,
            code: 3
          };
        }
        player.error(error);
      });
      var defaultSelector = this.options_.experimentalBufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR;
      this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);
      this.masterPlaylistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this);
      this.playlists = this.masterPlaylistController_.masterPlaylistLoader_;
      this.mediaSource = this.masterPlaylistController_.mediaSource;
      Object.defineProperties(this, {
        selectPlaylist: {
          get: function get() {
            return this.masterPlaylistController_.selectPlaylist;
          },
          set: function set(selectPlaylist) {
            this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);
          }
        },
        throughput: {
          get: function get() {
            return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;
          },
          set: function set(throughput) {
            this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = throughput;
            this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;
          }
        },
        bandwidth: {
          get: function get() {
            var playerBandwidthEst = this.masterPlaylistController_.mainSegmentLoader_.bandwidth;
            var networkInformation = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection;
            var tenMbpsAsBitsPerSecond = 10e6;
            if (this.options_.useNetworkInformationApi && networkInformation) {
              var networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1000 * 1000;
              if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) {
                playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec);
              } else {
                playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;
              }
            }
            return playerBandwidthEst;
          },
          set: function set(bandwidth) {
            this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth;
            this.masterPlaylistController_.mainSegmentLoader_.throughput = {
              rate: 0,
              count: 0
            };
          }
        },
        systemBandwidth: {
          get: function get() {
            var invBandwidth = 1 / (this.bandwidth || 1);
            var invThroughput;
            if (this.throughput > 0) {
              invThroughput = 1 / this.throughput;
            } else {
              invThroughput = 0;
            }
            var systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));
            return systemBitrate;
          },
          set: function set() {
            videojs.log.error('The "systemBandwidth" property is read-only');
          }
        }
      });
      if (this.options_.bandwidth) {
        this.bandwidth = this.options_.bandwidth;
      }
      if (this.options_.throughput) {
        this.throughput = this.options_.throughput;
      }
      Object.defineProperties(this.stats, {
        bandwidth: {
          get: function get() {
            return _this3.bandwidth || 0;
          },
          enumerable: true
        },
        mediaRequests: {
          get: function get() {
            return _this3.masterPlaylistController_.mediaRequests_() || 0;
          },
          enumerable: true
        },
        mediaRequestsAborted: {
          get: function get() {
            return _this3.masterPlaylistController_.mediaRequestsAborted_() || 0;
          },
          enumerable: true
        },
        mediaRequestsTimedout: {
          get: function get() {
            return _this3.masterPlaylistController_.mediaRequestsTimedout_() || 0;
          },
          enumerable: true
        },
        mediaRequestsErrored: {
          get: function get() {
            return _this3.masterPlaylistController_.mediaRequestsErrored_() || 0;
          },
          enumerable: true
        },
        mediaTransferDuration: {
          get: function get() {
            return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;
          },
          enumerable: true
        },
        mediaBytesTransferred: {
          get: function get() {
            return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;
          },
          enumerable: true
        },
        mediaSecondsLoaded: {
          get: function get() {
            return _this3.masterPlaylistController_.mediaSecondsLoaded_() || 0;
          },
          enumerable: true
        },
        mediaAppends: {
          get: function get() {
            return _this3.masterPlaylistController_.mediaAppends_() || 0;
          },
          enumerable: true
        },
        mainAppendsToLoadedData: {
          get: function get() {
            return _this3.masterPlaylistController_.mainAppendsToLoadedData_() || 0;
          },
          enumerable: true
        },
        audioAppendsToLoadedData: {
          get: function get() {
            return _this3.masterPlaylistController_.audioAppendsToLoadedData_() || 0;
          },
          enumerable: true
        },
        appendsToLoadedData: {
          get: function get() {
            return _this3.masterPlaylistController_.appendsToLoadedData_() || 0;
          },
          enumerable: true
        },
        timeToLoadedData: {
          get: function get() {
            return _this3.masterPlaylistController_.timeToLoadedData_() || 0;
          },
          enumerable: true
        },
        buffered: {
          get: function get() {
            return timeRangesToArray(_this3.tech_.buffered());
          },
          enumerable: true
        },
        currentTime: {
          get: function get() {
            return _this3.tech_.currentTime();
          },
          enumerable: true
        },
        currentSource: {
          get: function get() {
            return _this3.tech_.currentSource_;
          },
          enumerable: true
        },
        currentTech: {
          get: function get() {
            return _this3.tech_.name_;
          },
          enumerable: true
        },
        duration: {
          get: function get() {
            return _this3.tech_.duration();
          },
          enumerable: true
        },
        master: {
          get: function get() {
            return _this3.playlists.master;
          },
          enumerable: true
        },
        playerDimensions: {
          get: function get() {
            return _this3.tech_.currentDimensions();
          },
          enumerable: true
        },
        seekable: {
          get: function get() {
            return timeRangesToArray(_this3.tech_.seekable());
          },
          enumerable: true
        },
        timestamp: {
          get: function get() {
            return Date.now();
          },
          enumerable: true
        },
        videoPlaybackQuality: {
          get: function get() {
            return _this3.tech_.getVideoPlaybackQuality();
          },
          enumerable: true
        }
      });
      this.tech_.one('canplay', this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_));
      this.tech_.on('bandwidthupdate', function () {
        if (_this3.options_.useBandwidthFromLocalStorage) {
          updateVhsLocalStorage({
            bandwidth: _this3.bandwidth,
            throughput: Math.round(_this3.throughput)
          });
        }
      });
      this.masterPlaylistController_.on('selectedinitialmedia', function () {
        renditionSelectionMixin(_this3);
      });
      this.masterPlaylistController_.sourceUpdater_.on('createdsourcebuffers', function () {
        _this3.setupEme_();
      });
      this.on(this.masterPlaylistController_, 'progress', function () {
        this.tech_.trigger('progress');
      });
      this.on(this.masterPlaylistController_, 'firstplay', function () {
        this.ignoreNextSeekingEvent_ = true;
      });
      this.setupQualityLevels_();
      if (!this.tech_.el()) {
        return;
      }
      this.mediaSourceUrl_ = window.URL.createObjectURL(this.masterPlaylistController_.mediaSource);
      this.tech_.src(this.mediaSourceUrl_);
    };
    _proto.createKeySessions_ = function createKeySessions_() {
      var _this4 = this;
      var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
      this.logger_('waiting for EME key session creation');
      waitForKeySessionCreation({
        player: this.player_,
        sourceKeySystems: this.source_.keySystems,
        audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),
        mainPlaylists: this.playlists.master.playlists
      }).then(function () {
        _this4.logger_('created EME key session');
        _this4.masterPlaylistController_.sourceUpdater_.initializedEme();
      })["catch"](function (err) {
        _this4.logger_('error while creating EME key session', err);
        _this4.player_.error({
          message: 'Failed to initialize media keys for EME',
          code: 3
        });
      });
    };
    _proto.handleWaitingForKey_ = function handleWaitingForKey_() {
      this.logger_('waitingforkey fired, attempting to create any new key sessions');
      this.createKeySessions_();
    }
    ;
    _proto.setupEme_ = function setupEme_() {
      var _this5 = this;
      var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
      var didSetupEmeOptions = setupEmeOptions({
        player: this.player_,
        sourceKeySystems: this.source_.keySystems,
        media: this.playlists.media(),
        audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()
      });
      this.player_.tech_.on('keystatuschange', function (e) {
        if (e.status === 'output-restricted') {
          _this5.masterPlaylistController_.blacklistCurrentPlaylist({
            playlist: _this5.masterPlaylistController_.media(),
            message: "DRM keystatus changed to " + e.status + ". Playlist will fail to play. Check for HDCP content.",
            blacklistDuration: Infinity
          });
        }
      });
      this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);
      this.player_.tech_.on('waitingforkey', this.handleWaitingForKey_);
      if (videojs.browser.IE_VERSION === 11 || !didSetupEmeOptions) {
        this.masterPlaylistController_.sourceUpdater_.initializedEme();
        return;
      }
      this.createKeySessions_();
    }
    ;
    _proto.setupQualityLevels_ = function setupQualityLevels_() {
      var _this6 = this;
      var player = videojs.players[this.tech_.options_.playerId];
      if (!player || !player.qualityLevels || this.qualityLevels_) {
        return;
      }
      this.qualityLevels_ = player.qualityLevels();
      this.masterPlaylistController_.on('selectedinitialmedia', function () {
        handleVhsLoadedMetadata(_this6.qualityLevels_, _this6);
      });
      this.playlists.on('mediachange', function () {
        handleVhsMediaChange(_this6.qualityLevels_, _this6.playlists);
      });
    }
    ;
    VhsHandler.version = function version$5() {
      return {
        '@videojs/http-streaming': version$4,
        'mux.js': version$3,
        'mpd-parser': version$2,
        'm3u8-parser': version$1,
        'aes-decrypter': version
      };
    }
    ;
    _proto.version = function version() {
      return this.constructor.version();
    };
    _proto.canChangeType = function canChangeType() {
      return SourceUpdater.canChangeType();
    }
    ;
    _proto.play = function play() {
      this.masterPlaylistController_.play();
    }
    ;
    _proto.setCurrentTime = function setCurrentTime(currentTime) {
      this.masterPlaylistController_.setCurrentTime(currentTime);
    }
    ;
    _proto.duration = function duration() {
      return this.masterPlaylistController_.duration();
    }
    ;
    _proto.seekable = function seekable() {
      return this.masterPlaylistController_.seekable();
    }
    ;
    _proto.dispose = function dispose() {
      if (this.playbackWatcher_) {
        this.playbackWatcher_.dispose();
      }
      if (this.masterPlaylistController_) {
        this.masterPlaylistController_.dispose();
      }
      if (this.qualityLevels_) {
        this.qualityLevels_.dispose();
      }
      if (this.player_) {
        delete this.player_.vhs;
        delete this.player_.dash;
        delete this.player_.hls;
      }
      if (this.tech_ && this.tech_.vhs) {
        delete this.tech_.vhs;
      }
      if (this.tech_) {
        delete this.tech_.hls;
      }
      if (this.mediaSourceUrl_ && window.URL.revokeObjectURL) {
        window.URL.revokeObjectURL(this.mediaSourceUrl_);
        this.mediaSourceUrl_ = null;
      }
      if (this.tech_) {
        this.tech_.off('waitingforkey', this.handleWaitingForKey_);
      }
      _Component.prototype.dispose.call(this);
    };
    _proto.convertToProgramTime = function convertToProgramTime(time, callback) {
      return getProgramTime({
        playlist: this.masterPlaylistController_.media(),
        time: time,
        callback: callback
      });
    }
    ;
    _proto.seekToProgramTime = function seekToProgramTime$1(programTime, callback, pauseAfterSeek, retryCount) {
      if (pauseAfterSeek === void 0) {
        pauseAfterSeek = true;
      }
      if (retryCount === void 0) {
        retryCount = 2;
      }
      return seekToProgramTime({
        programTime: programTime,
        playlist: this.masterPlaylistController_.media(),
        retryCount: retryCount,
        pauseAfterSeek: pauseAfterSeek,
        seekTo: this.options_.seekTo,
        tech: this.options_.tech,
        callback: callback
      });
    };
    return VhsHandler;
  }(Component);
  var VhsSourceHandler = {
    name: 'videojs-http-streaming',
    VERSION: version$4,
    canHandleSource: function canHandleSource(srcObj, options) {
      if (options === void 0) {
        options = {};
      }
      var localOptions = videojs.mergeOptions(videojs.options, options);
      return VhsSourceHandler.canPlayType(srcObj.type, localOptions);
    },
    handleSource: function handleSource(source, tech, options) {
      if (options === void 0) {
        options = {};
      }
      var localOptions = videojs.mergeOptions(videojs.options, options);
      tech.vhs = new VhsHandler(source, tech, localOptions);
      if (!videojs.hasOwnProperty('hls')) {
        Object.defineProperty(tech, 'hls', {
          get: function get() {
            videojs.log.warn('player.tech().hls is deprecated. Use player.tech().vhs instead.');
            return tech.vhs;
          },
          configurable: true
        });
      }
      tech.vhs.xhr = xhrFactory();
      tech.vhs.src(source.src, source.type);
      return tech.vhs;
    },
    canPlayType: function canPlayType(type, options) {
      if (options === void 0) {
        options = {};
      }
      var _videojs$mergeOptions = videojs.mergeOptions(videojs.options, options),
          _videojs$mergeOptions2 = _videojs$mergeOptions.vhs;
      _videojs$mergeOptions2 = _videojs$mergeOptions2 === void 0 ? {} : _videojs$mergeOptions2;
      var _videojs$mergeOptions3 = _videojs$mergeOptions2.overrideNative,
          overrideNative = _videojs$mergeOptions3 === void 0 ? !videojs.browser.IS_ANY_SAFARI : _videojs$mergeOptions3,
          _videojs$mergeOptions4 = _videojs$mergeOptions.hls;
      _videojs$mergeOptions4 = _videojs$mergeOptions4 === void 0 ? {} : _videojs$mergeOptions4;
      var _videojs$mergeOptions5 = _videojs$mergeOptions4.overrideNative,
          legacyOverrideNative = _videojs$mergeOptions5 === void 0 ? false : _videojs$mergeOptions5;
      var supportedType = simpleTypeFromSourceType(type);
      var canUseMsePlayback = supportedType && (!Vhs.supportsTypeNatively(supportedType) || legacyOverrideNative || overrideNative);
      return canUseMsePlayback ? 'maybe' : '';
    }
  };
  var supportsNativeMediaSources = function supportsNativeMediaSources() {
    return browserSupportsCodec('avc1.4d400d,mp4a.40.2');
  };
  if (supportsNativeMediaSources()) {
    videojs.getTech('Html5').registerSourceHandler(VhsSourceHandler, 0);
  }
  videojs.VhsHandler = VhsHandler;
  Object.defineProperty(videojs, 'HlsHandler', {
    get: function get() {
      videojs.log.warn('videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead.');
      return VhsHandler;
    },
    configurable: true
  });
  videojs.VhsSourceHandler = VhsSourceHandler;
  Object.defineProperty(videojs, 'HlsSourceHandler', {
    get: function get() {
      videojs.log.warn('videojs.HlsSourceHandler is deprecated. ' + 'Use videojs.VhsSourceHandler instead.');
      return VhsSourceHandler;
    },
    configurable: true
  });
  videojs.Vhs = Vhs;
  Object.defineProperty(videojs, 'Hls', {
    get: function get() {
      videojs.log.warn('videojs.Hls is deprecated. Use videojs.Vhs instead.');
      return Vhs;
    },
    configurable: true
  });
  if (!videojs.use) {
    videojs.registerComponent('Hls', Vhs);
    videojs.registerComponent('Vhs', Vhs);
  }
  videojs.options.vhs = videojs.options.vhs || {};
  videojs.options.hls = videojs.options.hls || {};
  if (!videojs.getPlugin || !videojs.getPlugin('reloadSourceOnError')) {
    var registerPlugin = videojs.registerPlugin || videojs.plugin;
    registerPlugin('reloadSourceOnError', reloadSourceOnError);
  }
  return videojs;
})));
}(video));
var videojs = getDefaultExportFromCjs(video.exports);

const DefaultVideoEventsMap = {
    abort: 'abort',
    canplay: 'canplay',
    canplaythrough: 'canplaythrough',
    durationchange: 'durationchange',
    emptied: 'emptied',
    ended: 'ended',
    error: 'error',
    loadeddata: 'loadeddata',
    loadedmetadata: 'loadedmetadata',
    loadstart: 'loadstart',
    pause: 'pause',
    play: 'play',
    playing: 'playing',
    progress: 'progress',
    ratechange: 'ratechange',
    seeked: 'seeked',
    seeking: 'seeking',
    stalled: 'stalled',
    suspend: 'suspend',
    timeupdate: 'timeupdate',
    volumechange: 'volumechange',
    waiting: 'waiting',
};

/**
 * Validate dataSetup JSON string & convert it to a DataSetup object.
 * @param value
 * @returns {DataSetup}
 */
const convertDataSetupStringToObject = (input) => {
    if (!input) {
        return {};
    }
    let options = {};
    // if typeof input is an object, return it
    if (typeof input === 'object') {
        return input;
    }
    // otherwise, attempt to parse it as JSON
    try {
        options = JSON.parse(input);
    }
    catch (e) {
        console.error('ix-video: invalid video.js dataSetup options json string');
        console.error('ix-video: ' + e);
    }
    return options;
};

const generateUid = function () {
    let ID = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    for (let i = 0; i < 12; i++) {
        ID += characters.charAt(Math.floor(Math.random() * 36));
    }
    return ID;
};
/**
 * Build a Map of the Lit element's attributes and their values.
 * @param customElement - The customElement to read the attributes from.
 * @returns {Map} An Map containing all the attributes of the element.
 */
const buildAttributeMap = function (customElement) {
    const attributes = customElement.getAttributeNames();
    const map = new Map();
    return attributes.reduce((acc, attr) => {
        acc.set(attr, customElement.getAttribute(attr) || '');
        return acc;
    }, map);
};
/**
 * Set all the attributes defined on the Lit element but not on the target
 * element to the target element.
 * @param {Map<string, string>} attributeMap - Map containing all the attributes of an element.
 * @param {HTMLElement} targetElement - The HTML element to set the attributes on.
 * @param {Array} excludeList - A list of attributes to exclude from the spread.
 * @returns void;
 */
const spreadHostAttributesToElement = function (attributeMap, targetElement, excludeList) {
    attributeMap.forEach((value, key) => {
        if (!excludeList || !excludeList.includes(key)) {
            targetElement === null || targetElement === void 0 ? void 0 : targetElement.setAttribute(key, value);
        }
    });
};
/**
 * Depending on the type of event, create an object that stores the event and
 * the video node's relevant attributes for that event.
 *
 * This is used to create custom event details that can be dispatched to the
 * component's event listeners.
 *
 * @param eventName - The name of the event to listen for.
 * @param event - The Event object that was dispatched.
 * @param video - The video element that the event was dispatched on.
 * @returns An object containing the `event` object and information about the
 * video.
 */
const createEventDetails = (eventName, event, video) => {
    switch (eventName.toLowerCase()) {
        case 'abort':
        case 'emptied':
        case 'loadstart':
        case 'seeking':
        case 'stalled':
        case 'suspend': {
            return { event };
        }
        case 'canplay':
        case 'canplaythrough':
        case 'durationchange':
        case 'loadeddata':
        case 'progress':
        case 'timeupdate':
        case 'waiting': {
            return {
                buffered: video === null || video === void 0 ? void 0 : video.buffered,
                currentTime: video === null || video === void 0 ? void 0 : video.currentTime,
                duration: video === null || video === void 0 ? void 0 : video.duration,
                event,
            };
        }
        case 'ended':
        case 'pause':
        case 'play':
        case 'playing':
        case 'seeked': {
            return {
                currentTime: video === null || video === void 0 ? void 0 : video.currentTime,
                duration: video === null || video === void 0 ? void 0 : video.duration,
                event,
            };
        }
        case 'error': {
            return { event, error: video === null || video === void 0 ? void 0 : video.error };
        }
        case 'loadedmetadata': {
            return {
                buffered: video === null || video === void 0 ? void 0 : video.buffered,
                currentTime: video === null || video === void 0 ? void 0 : video.currentTime,
                duration: video === null || video === void 0 ? void 0 : video.duration,
                width: video === null || video === void 0 ? void 0 : video.videoWidth,
                height: video === null || video === void 0 ? void 0 : video.videoHeight,
                event,
            };
        }
        case 'ratechange': {
            return {
                currentTime: video === null || video === void 0 ? void 0 : video.currentTime,
                duration: video === null || video === void 0 ? void 0 : video.duration,
                playbackRate: video === null || video === void 0 ? void 0 : video.playbackRate,
                event,
            };
        }
        case 'volumechange': {
            return {
                currentTime: video === null || video === void 0 ? void 0 : video.currentTime,
                duration: video === null || video === void 0 ? void 0 : video.duration,
                volume: video === null || video === void 0 ? void 0 : video.volume,
                muted: video === null || video === void 0 ? void 0 : video.muted,
                event,
            };
        }
        default:
            return { event };
    }
};

/**
 * ix-video is a custom element that can be used to display a video.
 * It wraps the video.js player in a LitElement.
 * @class IxVideo
 * @extends {LitElement}
 * @property {string} source - Required. The source URL of the video.
 * @property {string} controls - Whether or not the video should display controls. Defaults to false.
 * @property {string} dataSetup - A dataSetup JSON string used by video.js. Defaults to an empty string.
 * @property {string} height - The height of the video. Defaults to an empty string.
 * @property {string} type - The type of the video. Default: 'application/x-mpegURL'.
 * @property {string} width - The width of the video. Defaults to an empty string.
 */
let IxVideo = class IxVideo extends s {
    constructor() {
        super(...arguments);
        /**
         * ------------------------------------------------------------------------
         * Instance Variables
         * ------------------------------------------------------------------------
         */
        /**
         * HTMLVideoElement reference.
         * @default Ref<HTMLVideoElement>
         */
        this.videoRef = e();
        /**
         * ------------------------------------------------------------------------
         * Component Properties
         * ------------------------------------------------------------------------
         */
        /**
         * Show/hide the video controls
         * @default true
         */
        this.controls = false;
        /**
         * Video player height
         */
        this.height = undefined;
        /**
         * The source of the video
         */
        this.source = undefined;
        /**
         * MIME type of the video
         */
        this.type = 'application/x-mpegURL';
        /**
         * Video player width
         */
        this.width = undefined;
        /**
         * Video.js data-setup options json string. Users should not set them same
         * options on both on the element and in data-setup. If they do, data-setup
         * takes precedence.
         * @see https://docs.videojs.com/tutorial-options.html
         */
        this.dataSetup = {};
        this.fixed = false;
        this.poster = undefined;
        /**
         * ------------------------------------------------------------------------
         * Component State
         * ------------------------------------------------------------------------
         */
        /**
         * Generate a unique ID for the video element.
         *
         * We need to do this to avoid collisions with other video elements, since
         * we've disabled the shadow dom. This ID is also used to dispose of the
         * video player when the element is removed from the DOM.
         */
        this.uid = generateUid();
        this.vjsPlayer = undefined;
        this._addEventListener = (type, listener, options) => {
            var _a, _b;
            (_b = (_a = this.videoRef) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.addEventListener(type, listener, options);
        };
        this._removeEventListener = (type, listener, options) => {
            var _a, _b;
            (_b = (_a = this.videoRef) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.removeEventListener(type, listener, options);
        };
        /**
         * Add an event listener for every `<video>` event to `<ix-video>` and
         * dispatch a custom event with the same name. This allows us to emulate the
         * native `<video>` events on the custom element.
         * @returns {void} void;
         * @private
         * @memberof IxVideo
         */
        this._bubbleUpEventListeners = () => {
            Object.keys(DefaultVideoEventsMap).forEach((_type) => {
                const type = _type;
                this._addEventListener(type, (event) => {
                    var _a;
                    this.dispatchEvent(new CustomEvent(DefaultVideoEventsMap[type], {
                        detail: createEventDetails(type, event, (_a = this.videoRef) === null || _a === void 0 ? void 0 : _a.value),
                    }));
                });
            });
        };
        /**
         * Remove every `<video>` event listener from to `<ix-video>` and dispatch a
         * custom event with the same name. This should be invoked during cleanup,
         * when the video player is removed from the DOM.
         * @returns {void} void;
         * @private
         * @memberof IxVideo
         */
        this._removeEventListeners = () => {
            // Remove DefaultVideoEventsMap event listeners
            Object.keys(DefaultVideoEventsMap).forEach((_type) => {
                const type = _type;
                this._removeEventListener(type, (event) => {
                    var _a;
                    this.dispatchEvent(new CustomEvent(DefaultVideoEventsMap[type], {
                        detail: createEventDetails(type, event, (_a = this.videoRef) === null || _a === void 0 ? void 0 : _a.value),
                    }));
                });
            });
        };
        /**
         * Get the updated video player's options and merge them with the data-setup
         * options.
         *
         * Merging the data-setup options with the element options allows users to
         * set VJS-specific options on the element. We assume users will not set the
         * same option twice, and explain as much in the docs.
         *
         * @see https://docs.videojs.com/tutorial-options.html
         * @returns {void} void;
         * @private
         * @memberof IxVideo
         */
        this._getOptions = () => {
            var _a, _b;
            return {
                width: (_a = this.width) !== null && _a !== void 0 ? _a : '',
                height: (_b = this.height) !== null && _b !== void 0 ? _b : '',
                controls: this.controls,
                sources: this.source ? [{ src: this.source, type: this.type }] : [],
                fluid: !this.fixed,
                ...this.dataSetup,
            };
        };
        /**
         * Update the host style properties to match the style object.
         * @param {CSSStyleDeclaration} styles - CSSStyleDeclaration style object
         * @returns {void} void;
         */
        this._setStyles = (styles) => {
            for (const key in styles) {
                if (styles.hasOwnProperty(key)) {
                    const value = styles[key];
                    this.style.setProperty(key, value);
                }
            }
        };
        this._getPoster = () => {
            var _a, _b, _c;
            const width = this.width || ((_a = this.videoRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth) || '';
            const height = this.height || ((_b = this.videoRef.value) === null || _b === void 0 ? void 0 : _b.offsetHeight) || '';
            if ((_c = this.poster) === null || _c === void 0 ? void 0 : _c.includes('://')) {
                return `${this.poster}?w=${width}&h=${height}`;
            }
            return null;
        };
    }
    /**
     * ------------------------------------------------------------------------
     * Instance Methods
     * ------------------------------------------------------------------------
     */
    /**
     * Set all the attributes defined on the `<ix-video>` element and not on the
     * `<video>` element to the `<video>` element.
     *
     * We do this because we want to support all `<video>` attributes but
     * we don't want to override the custom element's attributes.
     *
     * @returns void;
     */
    _spreadHostAttributesToPlayer(player) {
        const attributeMap = buildAttributeMap(this);
        const excludeList = [
            'controls',
            'dataSetup',
            'height',
            'source',
            'style',
            'type',
            'width',
            'data-test-id',
            'class',
            'poster',
        ];
        spreadHostAttributesToElement(attributeMap, player, excludeList);
    }
    /**
     * ------------------------------------------------------------------------
     * Render Lifecycle Methods
     * ------------------------------------------------------------------------
     */
    render() {
        return $ `
      <style>
        .vjs-poster {
          background-size: cover;
        }
      </style>
      <video
        ${n(this.videoRef)}
        class="video-js vjs-default-skin vjs-big-play-centered ${this
            .className}"
        id="ix-video-${this.uid}"
        part="video"
      ></video>
    `;
    }
    updated(changed) {
        super.updated(changed);
        const { controls, height, width, fluid } = this._getOptions();
        let stylesChanged = false;
        // For each changed property, update the the vjsPlayer attribute value
        changed.forEach((_, propName) => {
            var _a, _b, _c, _d, _e, _f;
            if (propName === 'source') {
                (_a = this.vjsPlayer) === null || _a === void 0 ? void 0 : _a.src(this.source ? [{ src: this.source, type: this.type }] : []);
            }
            if (propName === 'controls') {
                (_b = this.vjsPlayer) === null || _b === void 0 ? void 0 : _b.controls(!!controls);
            }
            if (propName === 'height' && height) {
                (_c = this.vjsPlayer) === null || _c === void 0 ? void 0 : _c.height(Number(height));
                stylesChanged = true;
            }
            if (propName === 'width' && width) {
                (_d = this.vjsPlayer) === null || _d === void 0 ? void 0 : _d.width(Number(width));
                stylesChanged = true;
            }
            if (propName === 'fixed') {
                (_e = this.vjsPlayer) === null || _e === void 0 ? void 0 : _e.fluid(!!fluid);
                stylesChanged = true;
            }
            if (propName === 'poster') {
                // Update the player poster to match the video element dimensions
                const poster = this._getPoster();
                poster && ((_f = this.vjsPlayer) === null || _f === void 0 ? void 0 : _f.poster(poster));
            }
        });
        // If width/heigh/fixed props change, update ix-video's style properties.
        if (stylesChanged) {
            const newStyles = {
                width: width ? width + 'px' : '100%',
                height: height ? height + 'px' : '100%',
                // Need to set a display value otherwise w/h styles are not applied
                display: 'block',
            };
            this._setStyles(newStyles);
        }
    }
    firstUpdated() {
        var _a;
        const player = (_a = this.videoRef) === null || _a === void 0 ? void 0 : _a.value;
        const options = this._getOptions();
        this._spreadHostAttributesToPlayer(player);
        this._bubbleUpEventListeners();
        // Initialize the videojs player, which will modify the DOM to add the
        // video player and its controls.
        const vjs = videojs;
        const vjsPlayer = vjs(player, options, () => {
            // Prevent VJS error logging in console
            videojs.log.level('off');
            // Update the player poster to match the video element dimensions
            const poster = this._getPoster();
            poster && vjsPlayer.poster(poster);
        });
        // store a reference to the videojs player in state
        this.vjsPlayer = vjsPlayer;
    }
    disconnectedCallback() {
        var _a;
        super.disconnectedCallback();
        // Remove the VJS markup when the element is removed from the DOM.
        (_a = this.vjsPlayer) === null || _a === void 0 ? void 0 : _a.dispose();
        // Remove DefaultVideoEventsMap event listeners
        this._removeEventListeners();
    }
    createRenderRoot() {
        /**
         * Remove the shadow root and renders the elements as children of the host.
         *
         * This is necessary because Video.js assumes access to the parent document.
         * Moreover, Video.js also uses custom `@fontface` rules, which are not
         * supported by Lit and more generally web-components. You can read more
         * about the `@fontface` issues here:
         * https://bugs.chromium.org/p/chromium/issues/detail?id=336876#c28
         */
        return this;
    }
};
// Will insert a style tag to the document head. If we had the shadow-dom
// enabled, this would mean the styles would be scoped to this component.
IxVideo.styles = [css_248z];
__decorate([
    e$3({ type: Boolean, attribute: 'controls', reflect: true })
], IxVideo.prototype, "controls", void 0);
__decorate([
    e$3({ reflect: true, attribute: 'height' })
], IxVideo.prototype, "height", void 0);
__decorate([
    e$3({ reflect: true })
], IxVideo.prototype, "source", void 0);
__decorate([
    e$3({ reflect: true })
], IxVideo.prototype, "type", void 0);
__decorate([
    e$3({ reflect: true })
], IxVideo.prototype, "width", void 0);
__decorate([
    e$3({
        type: Object,
        attribute: 'data-setup',
        converter: (value) => convertDataSetupStringToObject(value !== null && value !== void 0 ? value : ''),
    })
], IxVideo.prototype, "dataSetup", void 0);
__decorate([
    e$3({ type: Boolean })
], IxVideo.prototype, "fixed", void 0);
__decorate([
    e$3({ type: String })
], IxVideo.prototype, "poster", void 0);
__decorate([
    t$1()
], IxVideo.prototype, "uid", void 0);
IxVideo = __decorate([
    n$3('ix-video')
], IxVideo);

export { IxVideo };
